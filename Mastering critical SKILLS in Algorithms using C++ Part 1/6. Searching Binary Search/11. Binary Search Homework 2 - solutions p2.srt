1
00:00:01,100 --> 00:00:03,200
Let's move to the second problem.

2
00:00:03,610 --> 00:00:05,810
Uh, the book, it's one.

3
00:00:09,230 --> 00:00:14,300
OK, again, I would like you to be very systematic in buying the research because it will work well

4
00:00:14,300 --> 00:00:16,280
in like 80 percent of the cases.

5
00:00:16,670 --> 00:00:19,880
What is a goal of this problem finding a number of days?

6
00:00:20,060 --> 00:00:23,300
So the first thing you tell yourself, can we buy in the session days?

7
00:00:23,690 --> 00:00:25,420
OK, we need to verify it's Montana.

8
00:00:26,180 --> 00:00:31,210
So the possible function we should be able to take, the possible function is based on some competition.

9
00:00:31,220 --> 00:00:33,360
We need to verify the competitions are monotonic.

10
00:00:34,010 --> 00:00:35,150
So here is the point.

11
00:00:35,660 --> 00:00:39,030
Let's say we have there is the one day to day three the.

12
00:00:40,250 --> 00:00:44,240
If let's say that five buckets are possible today.

13
00:00:45,220 --> 00:00:50,980
Then tomorrow, we at least have five book, it's after tomorrow, maybe you have one more book it after

14
00:00:50,980 --> 00:00:52,480
after tomorrow, we have one more book.

15
00:00:52,930 --> 00:01:00,190
So the more they use, the more flowers are blooming and we have more, more book.

16
00:01:00,190 --> 00:01:00,850
It's ready.

17
00:01:01,120 --> 00:01:04,260
This is clearly a binary search function.

18
00:01:04,270 --> 00:01:06,370
I want tonic function so we can buy another associate.

19
00:01:06,760 --> 00:01:11,690
So now the question is, let's imagine the research that that there is the first.

20
00:01:11,690 --> 00:01:15,100
The question is, and what is the smallest day and what is the largest day?

21
00:01:15,790 --> 00:01:17,950
So the smallest day is typically one day.

22
00:01:19,330 --> 00:01:22,020
The largest day is the maximum day in the blooms days.

23
00:01:22,690 --> 00:01:26,230
And here is our variable that we will see if the answer, isn't it?

24
00:01:26,560 --> 00:01:30,340
This is just some optimization if there is no way anyway to make the answer.

25
00:01:31,000 --> 00:01:34,090
The good is, as usual, this is a quality.

26
00:01:34,090 --> 00:01:35,620
We can build the method as usual.

27
00:01:35,980 --> 00:01:37,420
And what do we need year?

28
00:01:37,600 --> 00:01:38,860
We need the minimum days.

29
00:01:39,040 --> 00:01:43,090
So if this one is okay, D2 is OK, this three is OK, the four is OK.

30
00:01:43,360 --> 00:01:45,970
We need the smallest one of them, which is the one.

31
00:01:46,360 --> 00:01:52,120
So again, we need the lake the first two appearance, but we need the smallest among all of them,

32
00:01:52,270 --> 00:01:55,840
so we would like to merge the condition of their little zen.

33
00:01:57,080 --> 00:02:00,230
With the equality, so here we have the result of equality.

34
00:02:00,560 --> 00:02:04,280
So what I'm saying here, I'm calling the function, it's called possible.

35
00:02:04,490 --> 00:02:06,770
I give it out of this bunch of information.

36
00:02:06,980 --> 00:02:10,790
So the possible function here, bill here is the first one.

37
00:02:10,940 --> 00:02:15,110
Now I'm mixing the merging, the possible with the the competition.

38
00:02:15,410 --> 00:02:23,480
So this good will take the number of waiting days so far and will tell me how many buckets are ready

39
00:02:23,690 --> 00:02:26,720
if at any point of time the total number of buckets are enough.

40
00:02:26,930 --> 00:02:28,670
We are done and we returned it through.

41
00:02:28,710 --> 00:02:29,870
Otherwise we return false.

42
00:02:30,170 --> 00:02:33,080
So here we iterate on the bloom days.

43
00:02:33,380 --> 00:02:38,240
If the Bloom Day is less than or equal to the waiting days, like, let's say, the flower need for

44
00:02:38,750 --> 00:02:42,800
these to bloom and we wait seven days, then this is a flower with us.

45
00:02:43,280 --> 00:02:46,400
I am having year a variable adjacent to flowers.

46
00:02:46,670 --> 00:02:49,850
It keeps telling me how many additions the flower they have so far.

47
00:02:50,090 --> 00:02:52,040
So let's say waiting days is seven.

48
00:02:52,520 --> 00:02:57,260
The first the flower has blooming of two, then five, then three, then eight.

49
00:02:57,770 --> 00:02:58,730
So I am iterating.

50
00:02:59,030 --> 00:03:00,130
Blooming day is OK.

51
00:03:00,140 --> 00:03:01,430
Yes, count is one.

52
00:03:01,760 --> 00:03:07,300
Blooming day is a case count to blooming day is a case count to three, but every day is okay.

53
00:03:07,310 --> 00:03:08,300
No, it isn't okay.

54
00:03:09,380 --> 00:03:16,160
So this is how I'm updating that dozens of laws now, Gridley, if at any point of time the current

55
00:03:16,170 --> 00:03:19,250
adjustment, the flowers are enough for an extra bucket.

56
00:03:19,580 --> 00:03:23,990
Then we have one more bucket from here and we remove its adjacent flower.

57
00:03:24,230 --> 00:03:27,740
I believe this is a trivial function to write like its basic logic.

58
00:03:28,340 --> 00:03:33,230
You have waiting days and you have things, then just iterate and get them together.

59
00:03:33,770 --> 00:03:38,490
The sense of grouping the first elements is a very trivial, greedy idea.

60
00:03:38,510 --> 00:03:39,740
Again, you do need to know what is good.

61
00:03:39,740 --> 00:03:40,730
Great is just very logical.

62
00:03:40,730 --> 00:03:43,700
As we mentioned before, this was.
