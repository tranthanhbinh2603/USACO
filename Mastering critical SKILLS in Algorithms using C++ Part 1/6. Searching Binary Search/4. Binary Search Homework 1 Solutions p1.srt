0
1
00:00:01,160 --> 00:00:03,350
Let's solve the homework number one.
1

2
00:00:03,590 --> 00:00:10,610
So in the first problem, we have an array of integers, and we would like to find the first occurrence of
2

3
00:00:10,610 --> 00:00:11,090
the element,
3

4
00:00:11,420 --> 00:00:18,350
and the last occurrence for it, index twice. If there are no such targets, we should return just
4

5
00:00:18,770 --> 00:00:19,820
[-1, -1].
5

6
00:00:20,300 --> 00:00:28,550
I hope that this assignment probably taught you how it could end up really hard to fix
6

7
00:00:28,550 --> 00:00:28,760
it.
7

8
00:00:28,790 --> 00:00:31,070
There are a bunch of different mistakes that could happen.
8

9
00:00:31,670 --> 00:00:34,670
I'm going to show you one way to implement it.
9

10
00:00:35,450 --> 00:00:38,930
It's a good way, but it's really, like, actually problematic.
10

11
00:00:38,960 --> 00:00:44,180
Then I will show you another way that's more decent, and you should keep it as an implementation style.
11

12
00:00:44,660 --> 00:00:47,160
So let's start with the find first.
12

13
00:00:47,210 --> 00:00:51,200
The first_first function is returning
13

14
00:00:52,070 --> 00:00:55,280
the first index of the element in the array.
14

15
00:00:56,000 --> 00:00:56,510
.
15

16
00:00:59,890 --> 00:01:03,460
So here is an array of elements, let's say
16

17
00:01:05,840 --> 00:01:09,260
zero, one, two, three, four, five, and six.
17

18
00:01:09,530 --> 00:01:17,910
Here are our elements, let's say [1, 3, 5, 7, 8, 9, 20], and now we would like to find, oh,
18

19
00:01:17,960 --> 00:01:19,940
let's make it like a seven and seven.
19

20
00:01:20,510 --> 00:01:24,050
We would like to find the first occurrence of seven, which is at position three.
20

21
00:01:24,620 --> 00:01:27,890
Now, when you think about it, this is an array, and the array has a start and end.
21

22
00:01:28,070 --> 00:01:29,210
The start is at zero.
22

23
00:01:29,630 --> 00:01:31,640
The end is at (size -1).
23

24
00:01:32,600 --> 00:01:34,080
There should be some condition here.
24

25
00:01:34,100 --> 00:01:37,070
Let's leave it for now. The middle is as usual.
25

26
00:01:37,700 --> 00:01:40,840
previously, we have three conditions.
26

27
00:01:40,850 --> 00:01:41,920
We found the element.
27

28
00:01:41,930 --> 00:01:42,590
It is less.
28

29
00:01:42,590 --> 00:01:43,190
It is more.
29

30
00:01:44,030 --> 00:01:45,910
But now,
30

31
00:01:47,360 --> 00:01:54,320
we have here the case of if it's less than, then definitely we need to go to the right part of the
31

32
00:01:54,500 --> 00:01:55,250
search space.
32

33
00:01:55,760 --> 00:01:58,070
If it is greater than, we need to go to the left part.
33

34
00:01:58,490 --> 00:02:00,410
This is also previous
34

35
00:02:00,410 --> 00:02:01,790
code, and we will not change it.
35

36
00:02:02,450 --> 00:02:04,760
Now the problem is if we found it.
36

37
00:02:05,540 --> 00:02:10,520
So let's say at the moment the index of the middle was, for example, at five, let's pretend
37

38
00:02:10,520 --> 00:02:10,820
that.
38

39
00:02:11,420 --> 00:02:15,050
So we found it, but we don't know if this is the first seven or not.
39

40
00:02:15,680 --> 00:02:17,810
So we would like to say, Hey, you know what,
40

41
00:02:17,810 --> 00:02:25,460
I would like you to have this part as my search space. So I'm going to put the end equal to the middle,
41

42
00:02:25,730 --> 00:02:27,560
the end equal to the middle.
42

43
00:02:28,790 --> 00:02:31,880
But this will start to create different types of problems.
43

44
00:02:32,720 --> 00:02:39,200
And to fix these problems, we will start with something like putting this only less than to be less than or
44

45
00:02:39,230 --> 00:02:39,540
equal.
45

46
00:02:39,560 --> 00:02:46,640
So this is the first change. After that, we need to do here some further conditions to verify it.
46

47
00:02:47,030 --> 00:02:49,130
If the start ended up less than zero.
47

48
00:02:49,430 --> 00:02:51,880
Then it actually doesn't exist.
48

49
00:02:52,610 --> 00:02:55,460
If the start is after the array, it doesn't exist.
49

50
00:02:55,850 --> 00:02:59,960
We also need to verify that the found index is actually the target index.
50

51
00:03:00,470 --> 00:03:03,680
If so, then we found it, otherwise, minus one.
51

52
00:03:04,820 --> 00:03:05,900
Let me repeat that again.
52

53
00:03:06,410 --> 00:03:13,730
The whole trick of this implementation is when we find a position, we update our search to include this position.
53

54
00:03:14,150 --> 00:03:16,760
So the middle will be part of the new search space.
54

55
00:03:17,480 --> 00:03:21,710
This is mainly the find_first here implementation.
55

56
00:03:22,250 --> 00:03:24,710
The last way is very similar.
56

57
00:03:25,700 --> 00:03:33,920
However, finding the last index is more problematic, finding the last index is more problematic.
57

58
00:03:35,150 --> 00:03:41,300
Let me show you why. So we are going to follow the same trick, which means this is the goal of this
58

59
00:03:41,330 --> 00:03:43,070
way of implementation to use the middle.
59

60
00:03:43,790 --> 00:03:50,630
So this is the same, again, we have here indices, and let's say somewhere we have seven, seven,
60

61
00:03:51,110 --> 00:03:52,670
seven, and seven.
61

62
00:03:53,120 --> 00:03:55,130
And let's say the middle is here at the moment.
62

63
00:03:56,030 --> 00:04:00,590
And here is some start and some end. As usual,
63

64
00:04:00,620 --> 00:04:02,630
the first two conditions will not change.
64

65
00:04:03,440 --> 00:04:07,970
The start is middle means we found the seven, but we don't know if this is the last element or not.
65

66
00:04:08,330 --> 00:04:12,140
So we create a new search window from this element to the current element.
66

67
00:04:13,790 --> 00:04:19,910
OK, we know that this trick in the previous solution ended up that we needed only here less not less than
67

68
00:04:19,910 --> 00:04:20,990
equal to let it works.
68

69
00:04:21,020 --> 00:04:22,430
Otherwise, it might go infinity or so.
69

70
00:04:22,430 --> 00:04:26,420
Now here is another nightmare from this solution.
70

71
00:04:27,170 --> 00:04:33,110
Assume that the positions are consecutive values, let's say five and six.
71

72
00:04:33,120 --> 00:04:34,610
So these are the indices now.
72

73
00:04:37,290 --> 00:04:38,990
And let's here value seven and value seven.
73

74
00:04:39,740 --> 00:04:42,230
So our start is at zero.
74

75
00:04:42,740 --> 00:04:44,180
Our end is at one.
75

76
00:04:44,390 --> 00:04:46,040
Sorry, our start is at five.
76

77
00:04:46,070 --> 00:04:47,210
Our end is at six.
77

78
00:04:47,690 --> 00:04:54,680
Now ignore this plus one for now. If we used the normal equation, we will have
78

79
00:04:55,040 --> 00:05:00,110
(6-5) equals one, over two
79

80
00:05:00,110 --> 00:05:02,390
is zero, plus start is same the start.
80

81
00:05:02,540 --> 00:05:03,830
So the middle is the start.
81

82
00:05:07,140 --> 00:05:08,490
The middle is the start.
82

83
00:05:08,690 --> 00:05:10,290
Now we found it.
83

84
00:05:10,980 --> 00:05:13,650
We found it here, right?
84

85
00:05:13,860 --> 00:05:19,140
So the new search involves putting the start again equal to the middle.
85

86
00:05:20,010 --> 00:05:25,860
And this means the new start is again equal to five, and the end is still six.
86

87
00:05:26,340 --> 00:05:28,800
We are repeating the same start and end again.
87

88
00:05:28,950 --> 00:05:30,990
This code will go infinity.
88

89
00:05:32,130 --> 00:05:33,870
So what is the value of this plus one?
89

90
00:05:34,230 --> 00:05:39,180
I am forcing it if just two consecutive elements to use the second one first.
90

91
00:05:39,630 --> 00:05:46,530
So here is the point if we have (start + end - 1) here and we have five and six.
91

92
00:05:46,800 --> 00:05:49,560
So (6 - 5) is one, plus one is two,
92

93
00:05:49,560 --> 00:05:52,750
over two is one, plus five.
93

94
00:05:53,100 --> 00:05:54,990
So it will be five plus one equals six.
94

95
00:05:55,350 --> 00:05:56,730
Now the middle equals six.
95

96
00:05:57,450 --> 00:06:02,610
So here the next it will be like start equals end equals six.
96

97
00:06:03,390 --> 00:06:04,290
The moral of that.
97

98
00:06:06,270 --> 00:06:12,150
First of all, we decided to go with start = middle, so that we include the target element.
98

99
00:06:12,360 --> 00:06:15,750
But this ended up that we cannot have here equal.
99

100
00:06:16,230 --> 00:06:18,210
And also we have to put conditions here.
100

101
00:06:18,930 --> 00:06:25,170
The second problem, in finding the last occurrence, the equation will result in an infinite loop.
101

102
00:06:25,620 --> 00:06:31,730
And to solve this problem, we added +1 here, so that we force consecutive indices to next
102

103
00:06:31,750 --> 00:06:32,340
use the next one.
103

104
00:06:32,520 --> 00:06:35,700
Otherwise, it will go to infinity if you are unlucky.
104

105
00:06:36,090 --> 00:06:40,350
So as you see, this is now a very problematic way to solve the problem.
105

106
00:06:40,900 --> 00:06:44,250
I'm going to show you a way easier implementation
106

107
00:06:44,700 --> 00:06:50,250
than this style, which is very nice, has good thoughts behind it, but isn't really the best way to
107

108
00:06:50,250 --> 00:06:50,910
implement it.
108

109
00:06:52,560 --> 00:06:58,200
So here is the way that I would like you to use it, which will save your life, and very close to our
109

110
00:06:58,200 --> 00:06:59,490
usual implementations.
110

111
00:06:59,970 --> 00:07:02,130
The whole trick is very trivial.
111

112
00:07:02,640 --> 00:07:03,990
The idea is as following.
112

113
00:07:06,210 --> 00:07:11,310
We will have an extra variable, initially, for example, position = -1.
113

114
00:07:11,790 --> 00:07:13,230
And this one,
114

115
00:07:13,560 --> 00:07:16,620
we will keep assigning it the found solutions.
115

116
00:07:17,100 --> 00:07:19,420
So now here we will back to go
116

117
00:07:19,850 --> 00:07:21,420
use less than or equal as it is.
117

118
00:07:21,690 --> 00:07:26,910
We will have a condition for less than, and we'll have a condition for greater than.
118

119
00:07:26,920 --> 00:07:28,770
And we'll have a condition for the equal.
119

120
00:07:29,850 --> 00:07:31,950
These two conditions are as usual.
120

121
00:07:32,670 --> 00:07:35,940
Now, the condition of the equality is as following.
121

122
00:07:36,810 --> 00:07:42,190
We will put the (end = mid - 1) as usual, but we will mark the position with the middle.
122

123
00:07:42,210 --> 00:07:44,130
So let's use the grid here.
123

124
00:07:46,600 --> 00:07:51,470
Let's say we have seven, seven, seven, seven, and let's say that the middle is here.
124

125
00:07:52,510 --> 00:07:55,290
Once we found it, I will say, Hey, you know what,
125

126
00:07:55,300 --> 00:07:56,170
we found it.
126

127
00:07:57,150 --> 00:08:03,630
And then in the next time, I will use the (middle - 1) as usual. If it happened that this new
127

128
00:08:03,630 --> 00:08:08,280
range found a better answer, it will update our position. If it couldn't,
128

129
00:08:08,370 --> 00:08:10,350
we just have our previous value.
129

130
00:08:10,950 --> 00:08:13,920
So the moral of that is, with this saving one,
130

131
00:08:14,130 --> 00:08:19,710
we don't anymore need to write something like end = middle, which will fire back on us
131

132
00:08:19,950 --> 00:08:20,880
in the recursion.
132

133
00:08:21,600 --> 00:08:27,120
Now in exactly the same logic here in the second code, we have the less than as usual, we have the
133

134
00:08:27,120 --> 00:08:27,300
greater
134

135
00:08:27,300 --> 00:08:33,430
than as usual. For the equality, we'll say the position = middle, and then move to the right part.
135

136
00:08:33,450 --> 00:08:39,840
As you see the good advantage of this code, it is almost very similar to what we write.
136

137
00:08:40,110 --> 00:08:42,090
It involves here less than or equal.
137

138
00:08:42,330 --> 00:08:44,070
It involves normal conditions.
138

139
00:08:44,250 --> 00:08:46,290
It doesn't involve any post-processing.
139

140
00:08:46,530 --> 00:08:47,590
Very straightforward.
140

141
00:08:47,850 --> 00:08:49,110
No runtime loops.
141

142
00:08:49,350 --> 00:08:51,360
No infinite loop.
142

143
00:08:51,720 --> 00:08:52,950
Uh, no
143

144
00:08:52,950 --> 00:08:54,270
all of these weird tricks.
144

145
00:08:54,270 --> 00:08:55,440
No changes for...
145

146
00:08:55,650 --> 00:08:57,120
I don't think that we need this change.
146

147
00:08:57,120 --> 00:08:57,450
Sorry.
147

148
00:08:58,050 --> 00:08:59,690
I don't think that this change,
148

149
00:08:59,700 --> 00:09:00,390
we don't need it.
149

150
00:09:00,540 --> 00:09:03,390
This plus one, I'm sure we don't need anymore.
150

151
00:09:04,200 --> 00:09:05,580
I will update the code to remove it.
151

152
00:09:06,150 --> 00:09:08,880
So this is the way that I would like you to use
152

153
00:09:08,880 --> 00:09:09,390
this code.
153

154
00:09:12,020 --> 00:09:18,380
OK, the final code that I would like to share with you is about the STL, which we can use
154

155
00:09:18,380 --> 00:09:23,090
STL as I told you before, stl equal range already finds the first element and the last element.
155

156
00:09:23,390 --> 00:09:32,060
So the solution is as following, you will call the equal_range, return two iterators.
156

157
00:09:32,120 --> 00:09:34,070
The first iterator for the lower bound.
157

158
00:09:34,340 --> 00:09:35,690
The second one for the upper bound.
158

159
00:09:36,080 --> 00:09:42,650
If we couldn't find it anyway {-1, -1}, then X here will be for the first element,
159

160
00:09:42,650 --> 00:09:43,910
which is good.
160

161
00:09:44,150 --> 00:09:45,740
But why is after it?
161

162
00:09:46,190 --> 00:09:46,670
And we know,
162

163
00:09:47,120 --> 00:09:48,170
let me give you example.
163

164
00:09:48,410 --> 00:09:54,120
Let's say we have here 5, 6, 7, 7, 7, 10.
164

165
00:09:54,890 --> 00:09:57,670
The lower bound is seven, which is good what we need.
165

166
00:09:57,950 --> 00:09:59,780
The upper bound is ten.
166

167
00:09:59,990 --> 00:10:01,440
We need one step before it.
167

168
00:10:01,490 --> 00:10:04,700
So this is the minus one here.
168

169
00:10:05,300 --> 00:10:08,390
So this is the STL style. That's all.
