0
1
00:00:01,180 --> 00:00:08,320
In this problem, we would like to compute the number of triplets that are creating a valid triangle.
1

2
00:00:08,320 --> 00:00:14,680
A valid triangle is a triangle that has a summation of any two sides greater than
2

3
00:00:14,980 --> 00:00:16,150
the third side always.
3

4
00:00:16,570 --> 00:00:19,050
And this is, as we said, a counting problem.
4

5
00:00:19,120 --> 00:00:21,460
This is one type of the algorithms.
5

6
00:00:22,180 --> 00:00:28,840
So going to the implementation here, if we thought, and this is, by the way, a very good strategy
6

7
00:00:28,840 --> 00:00:33,940
that I would like you to keep in mind. When you have a problem, start by thinking about the brute
7

8
00:00:33,940 --> 00:00:34,980
force solution.
8

9
00:00:36,180 --> 00:00:42,420
There is a big chance, maybe 60 percent, in many problems the brute force solution can
9

10
00:00:42,420 --> 00:00:45,810
be improved to a better solution.
10

11
00:00:46,380 --> 00:00:51,480
And all cases thinking and starting from brute force will let your mind think about it. So never,
11

12
00:00:51,480 --> 00:00:54,150
ever start a problem by thinking about the optimal solution.
12

13
00:00:54,390 --> 00:00:57,390
Just go ahead with the brute force solution, which shouldn't be hard to implement.
13

14
00:00:57,990 --> 00:01:02,550
Now, when you think about this problem, the brute force solution will be three nested loops,
14

15
00:01:02,550 --> 00:01:06,270
loop one, loop two, and loop three. For trying three indices, i, j, and k.
15

16
00:01:06,840 --> 00:01:09,630
And now you check if the triangle is valid or not.
16

17
00:01:09,630 --> 00:01:11,210
If it's valid, just count++.
17

18
00:01:11,650 --> 00:01:12,840
Now, this is O(n^3).
18

19
00:01:14,490 --> 00:01:17,320
Uh, the hope now with binary search,
19

20
00:01:17,340 --> 00:01:19,950
maybe we can improve this performance.
20

21
00:01:20,520 --> 00:01:26,430
So first of all, like any binary search problem, you should start thinking about the sorting of
21

22
00:01:26,430 --> 00:01:28,050
the values themselves.
22

23
00:01:28,380 --> 00:01:35,010
So let's take a bunch of the values and start to sort them here, like the edges, two, five, seven, ten,
23

24
00:01:35,010 --> 00:01:37,470
twenty, thirty, and so on.
24

25
00:01:39,170 --> 00:01:46,670
Now we will brute force on two dimensions, and sometimes the optimal solutions involve
25

26
00:01:46,670 --> 00:01:50,480
some kind of brute force and some kind of smart ideas.
26

27
00:01:50,780 --> 00:01:55,490
So it isn't like a completely brute force solution and a completely smart solution.
27

28
00:01:55,880 --> 00:02:00,770
Many solutions will involve brute force on something and continuing on something else.
28

29
00:02:01,370 --> 00:02:06,110
So in this one, we will brute force on two of the variables.
29

30
00:02:06,470 --> 00:02:12,650
So, for example, I will have here the i, and I will have here the j. Now,
30

31
00:02:14,240 --> 00:02:16,130
starting from here, where is the k?
31

32
00:02:16,160 --> 00:02:18,530
Let's say the k can be anything here.
32

33
00:02:19,750 --> 00:02:23,830
So the brute force k will just try the seven, and ten, and twenty, and thirty.
33

34
00:02:24,340 --> 00:02:28,090
But there is a question here, what creates a valid triangle?
34

35
00:02:28,720 --> 00:02:36,910
The valid triangle must have values less than the two sides we have.
35

36
00:02:37,180 --> 00:02:45,930
For example, if we have two and five, seven, we must find, let's pretend there is a
36

37
00:02:46,030 --> 00:02:49,560
value six here.
37

38
00:02:49,570 --> 00:02:52,390
Any valid value must be less than or equal
38

39
00:02:52,390 --> 00:02:56,280
six, must be less than or equal the value
39

40
00:02:56,290 --> 00:02:56,740
six.
40

41
00:03:01,420 --> 00:03:04,540
So any value greater than six,
41

42
00:03:04,570 --> 00:03:05,860
doesn't make sense for us.
42

43
00:03:06,310 --> 00:03:11,200
So, now, the moral of that is if we have the first two values, and we summed them here together.
43

44
00:03:12,590 --> 00:03:18,620
Then in the remaining of the array, find the first element greater than or equal to this value.
44

45
00:03:20,030 --> 00:03:24,200
So I want to use a better array.
45

46
00:03:26,100 --> 00:03:32,580
So let's say we have here, for example, value 10, and we have the value, for example,
46

47
00:03:32,580 --> 00:03:33,270
15.
47

48
00:03:34,600 --> 00:03:37,060
OK, so 10 and 15 is 25.
48

49
00:03:37,330 --> 00:03:41,470
Any value less than 25 is a valid value. So let's pretend we have here 17.
49

50
00:03:41,800 --> 00:03:42,820
We have 19.
50

51
00:03:43,090 --> 00:03:43,910
We have 20.
51

52
00:03:43,960 --> 00:03:45,010
We have 22.
52

53
00:03:45,220 --> 00:03:46,840
We have 25.
53

54
00:03:47,020 --> 00:03:48,010
We have 26.
54

55
00:03:48,190 --> 00:03:49,870
We have 30, 31,
55

56
00:03:49,870 --> 00:03:50,440
and so on.
56

57
00:03:50,950 --> 00:03:51,910
Now here is the i,
57

58
00:03:53,170 --> 00:04:00,880
and here is the j, i and j summation is twenty-five, then any value greater than or equal to 25 is invalid.
58

59
00:04:01,120 --> 00:04:03,760
So let's find the lower bound in these values.
59

60
00:04:03,910 --> 00:04:10,480
Remember, the lower bound is greater than or equal. Where is the lower bound? Here 25, then from 25
60

61
00:04:10,480 --> 00:04:11,440
to 30,
61

62
00:04:11,710 --> 00:04:13,200
this is invalid.
62

63
00:04:13,210 --> 00:04:16,300
Where is the valid range? Only from here to here.
63

64
00:04:16,960 --> 00:04:20,410
So we find the first index that is greater than or equal to you.
64

65
00:04:20,890 --> 00:04:27,360
And then from j to this index here, the in-between range, are all valid triangles.
65

66
00:04:27,370 --> 00:04:29,330
So one, two, three, and four
66

67
00:04:29,350 --> 00:04:29,740
are valid triangles.
67

68
00:04:30,280 --> 00:04:35,770
So we are adding here the four elements that represent the valid triangles.
68

69
00:04:36,700 --> 00:04:39,490
Next step, j is moving here.
69

70
00:04:42,120 --> 00:04:43,420
So now here is the i and j.
70

71
00:04:44,460 --> 00:04:46,860
Ten and seventeen is twenty-seven.
71

72
00:04:47,130 --> 00:04:51,160
Any value greater than or equal to twenty-seven is invalid, lower bound twenty-seven.
72

73
00:04:51,180 --> 00:04:52,140
What is the answer?
73

74
00:04:52,320 --> 00:04:53,000
Thirty.
74

75
00:04:53,400 --> 00:04:58,830
So from after seventeen to twenty-six are valid triangles.
75

76
00:04:59,100 --> 00:05:06,270
So the moral of that is we brute force it two of the dimensions, and we used a binary search to trail
76

77
00:05:06,270 --> 00:05:08,850
us a range of valid values.
77

78
00:05:09,060 --> 00:05:11,550
I hope the overall idea is clear now for you.
78

79
00:05:11,850 --> 00:05:14,970
So the winners this year, as you see, is a very simple one.
79

80
00:05:15,180 --> 00:05:17,250
We we need the following exchanges.
80

81
00:05:17,250 --> 00:05:22,260
First of all, this one here does he want to buy the research on the whole array?
81

82
00:05:22,530 --> 00:05:25,070
It would like to bring the researcher from a specific story.
82

83
00:05:25,410 --> 00:05:29,560
So instead of usually having gives thought equals zero, we will bust the start of the race.
83

84
00:05:29,970 --> 00:05:36,090
So here we bust key, which we started here I +1 to search for the target value.
84

85
00:05:37,620 --> 00:05:42,120
Uh, so this is the first thing that we need to do here.
85

86
00:05:43,730 --> 00:05:46,270
Umm hmm.
86

87
00:05:49,220 --> 00:05:54,680
Yes, I have an impression that we should update did with something bigger than just care here.
87

88
00:05:55,460 --> 00:05:56,690
But it will it anyway.
88

89
00:05:56,690 --> 00:06:00,830
It's going to work because what anyway, finding the first element that's greater than or equal to?
89

90
00:06:00,920 --> 00:06:03,290
But for more efficient, we can actually keep reducing.
90

91
00:06:03,290 --> 00:06:05,330
The key was increasing here.
91

92
00:06:06,120 --> 00:06:09,050
Uh, I would say maybe we can always bus here.
92

93
00:06:09,050 --> 00:06:13,580
K was something like, uh, plus one.
93

94
00:06:14,560 --> 00:06:21,190
Yes, probably we should always, but the simplest one here in a way, I verify that later this is a
94

95
00:06:21,190 --> 00:06:22,180
normal binary search.
95

96
00:06:22,180 --> 00:06:26,320
We just implemented it in the previous problem, which is finding the lower bound.
96

97
00:06:26,530 --> 00:06:31,510
So the lower bound, as we mentioned before, is MIT is merging the condition for the greeter with the
97

98
00:06:31,510 --> 00:06:32,890
merging with the condition of the equal.
98

99
00:06:33,070 --> 00:06:35,650
And we would use the normal position track.
99

100
00:06:36,220 --> 00:06:37,540
So this is the first solution.
100

101
00:06:38,020 --> 00:06:42,250
And in the second solution, I'm asking you to use the lower bound function or they still.
101

102
00:06:42,550 --> 00:06:44,590
So it is exactly the same logic.
102

103
00:06:45,070 --> 00:06:52,020
Uh, and here we would like to use the internet a lower bound, then then law, don't take it to.
103

104
00:06:52,330 --> 00:06:54,400
Was it written for the beginning and trigger would end.
104

105
00:06:54,730 --> 00:06:56,290
So that here is the biggest hit.
105

106
00:06:56,620 --> 00:06:58,240
Refer to the like victor.
106

107
00:06:58,350 --> 00:06:59,170
Number of zero.
107

108
00:06:59,560 --> 00:07:03,700
If we added B+ key like pointers, it would be shifting it to be key elements.
108

109
00:07:03,970 --> 00:07:06,820
So again, this is exactly there the same logic.
109

110
00:07:08,150 --> 00:07:13,760
Now, in the second, the question I'm asking you if we can get rid of even the binary search, more
110

111
00:07:13,760 --> 00:07:22,790
and more so for the binary search helped us to find their interval like they're the end of the interval.
111

112
00:07:23,330 --> 00:07:27,860
So we now will know from after to the interval is all what we need.
112

113
00:07:29,110 --> 00:07:36,550
He would like to take it one more step, I would like only to use two loops to brute force with it and
113

114
00:07:36,550 --> 00:07:40,990
in a smart way, get the same message as their binary search.
114

115
00:07:41,650 --> 00:07:42,730
So it is a trick.
115

116
00:07:44,020 --> 00:07:58,360
Let's again pretend we have 10, 15, then 17, 20, 22, 23, 23, 25, 30, 40, 50.
116

117
00:07:58,990 --> 00:08:02,350
And let's say we have here an AI and we have Reggie.
117

118
00:08:04,400 --> 00:08:05,770
Let's start the brute forcing.
118

119
00:08:06,230 --> 00:08:07,640
Let's start the brute forcing.
119

120
00:08:08,240 --> 00:08:10,040
We will start with key here.
120

121
00:08:11,810 --> 00:08:16,760
And we will count this is now look like you see here we have two loops and it seems like we have the
121

122
00:08:16,760 --> 00:08:21,050
third it, but I will show you why this is a smarter and actually it's one over here.
122

123
00:08:21,950 --> 00:08:31,310
Uh, it started from 17 and finding all of that, all of their valid indices for key.
123

124
00:08:32,790 --> 00:08:35,340
So 17 here will check is.
124

125
00:08:36,060 --> 00:08:39,630
We have 10 and 15 is 17 valid point.
125

126
00:08:40,170 --> 00:08:44,970
So as long as greeter that is valid, yes valid is valid.
126

127
00:08:44,970 --> 00:08:45,570
Yes, valid.
127

128
00:08:45,570 --> 00:08:46,280
Yes, valid.
128

129
00:08:46,290 --> 00:08:47,970
Yes, it is valid.
129

130
00:08:47,970 --> 00:08:48,270
No.
130

131
00:08:49,020 --> 00:08:55,650
So now we stop the here and we added the count of all of these elements in between as we did before.
131

132
00:08:57,390 --> 00:08:59,430
Now here is the optimization track.
132

133
00:09:00,420 --> 00:09:02,910
Let's say we moved from I.
133

134
00:09:04,180 --> 00:09:05,680
We move to hear.
134

135
00:09:07,080 --> 00:09:08,940
15 and 17 is 27.
135

136
00:09:09,480 --> 00:09:14,880
The point is, all of the values that are here are pretty good values.
136

137
00:09:15,630 --> 00:09:18,960
So all what we need is we will just, you see this key.
137

138
00:09:19,800 --> 00:09:21,180
We'll just keep updating.
138

139
00:09:21,180 --> 00:09:22,850
The key will not reset it again.
139

140
00:09:22,860 --> 00:09:23,940
We will not receive the key.
140

141
00:09:24,180 --> 00:09:27,260
We'll just keep updating it to check is 25 is OK.
141

142
00:09:27,270 --> 00:09:28,470
Was done in 17 years.
142

143
00:09:28,650 --> 00:09:32,160
So this is our new location is 27 Aquino.
143

144
00:09:32,280 --> 00:09:35,190
So this is not our location and from 20.
144

145
00:09:36,540 --> 00:09:41,640
From 20 to 25 is our new valid Rich Letson will.
145

146
00:09:41,850 --> 00:09:44,970
The next is 20, 10 and 20 is 30.
146

147
00:09:45,360 --> 00:09:47,140
All of these valleys are buried already.
147

148
00:09:47,170 --> 00:09:48,210
You started from here.
148

149
00:09:48,240 --> 00:09:52,110
Let's pretend that this 35 35 and let's pretend this is 39.
149

150
00:09:52,980 --> 00:09:53,420
What what?
150

151
00:09:53,430 --> 00:09:54,210
What was the number?
151

152
00:09:55,020 --> 00:09:55,380
Oh.
152

153
00:09:57,360 --> 00:09:58,560
OK, here.
153

154
00:10:03,130 --> 00:10:07,360
Let's pretend that this was a twenty six, twenty seven.
154

155
00:10:08,840 --> 00:10:10,160
Twenty eight, thirty.
155

156
00:10:11,100 --> 00:10:16,020
Now we are at Didn't 20, which is 30, anybody that lives of 30 is good value.
156

157
00:10:16,260 --> 00:10:19,610
So we check from the lost the key 26 is okay.
157

158
00:10:19,620 --> 00:10:20,790
Yes, 27 is okay.
158

159
00:10:20,790 --> 00:10:22,980
Yes, 28 is a key, as 30 is a key.
159

160
00:10:22,980 --> 00:10:23,790
No stop here.
160

161
00:10:24,030 --> 00:10:27,930
So again, from 30, up to 22 is the new added value.
161

162
00:10:29,190 --> 00:10:35,280
In summary, we brute force it two variables and we searched for the first element to greater than or
162

163
00:10:35,280 --> 00:10:37,620
equal so that we consider the range before it.
163

164
00:10:37,920 --> 00:10:43,950
But the more of it and is to keep counting all of that, which we already did it.
164

165
00:10:44,010 --> 00:10:48,450
We already know if didn't, 17 is greater than 20.
165

166
00:10:48,840 --> 00:10:56,700
Then if didn't, 17 is greater than 22 definitely did and 22 2010 and 20 is greater than 22 because
166

167
00:10:56,700 --> 00:10:57,660
that is sorted.
167

168
00:10:58,530 --> 00:11:07,380
So every every I and G and I and jobless one is greater than I, and G and I and G goes to is greater
168

169
00:11:07,380 --> 00:11:12,450
than angel +1 because the values are sorted and we win this kind of optimizations.
169

170
00:11:12,450 --> 00:11:17,520
Before you need to avoid the unnecessary operations, you need to avoid the doubling operations.
170

171
00:11:17,730 --> 00:11:21,430
And I just see this need very decent analysis.
171

172
00:11:21,450 --> 00:11:26,670
If this algorithm is hard for you at the moment, but is a skip it come back in the future and right
172

173
00:11:26,670 --> 00:11:29,760
again, the system, by the way, the complexity.
173

174
00:11:29,880 --> 00:11:33,990
So this is to insist that loops that are clearly in the square.
174

175
00:11:34,350 --> 00:11:37,470
The moral of this why this could doesn't increase their complexity.
175

176
00:11:37,740 --> 00:11:41,250
The key here will be increased and better to the G once.
176

177
00:11:41,520 --> 00:11:45,750
So it's more like I and G G G and get an increase together.
177

178
00:11:45,960 --> 00:11:49,260
So this loop doesn't have an effect on the performance.
178

179
00:11:49,530 --> 00:11:53,760
There is a different way if you would like to write this good so that it actually looks like just two
179

180
00:11:53,760 --> 00:11:54,330
nested loops.
180

181
00:11:54,540 --> 00:11:56,490
You can you can find it here.
181

182
00:11:57,030 --> 00:11:57,510
That's all.
