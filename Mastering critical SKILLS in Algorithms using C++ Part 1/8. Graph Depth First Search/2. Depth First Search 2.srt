1
00:00:01,130 --> 00:00:07,340
Let's continue our discussion about the Dipasupil research, I would like to start with another three

2
00:00:07,340 --> 00:00:12,170
who just to refresh the the terracing, but this time in a very short rest light.

3
00:00:12,530 --> 00:00:15,440
So let's see, we'd like to make a defense of two here.

4
00:00:15,740 --> 00:00:23,450
So in the first step, remember the defense tomb has zero three four five as the children, so this

5
00:00:23,460 --> 00:00:26,840
rule will be running four times.

6
00:00:28,270 --> 00:00:32,350
The defense zero will proceed after it come back from the region.

7
00:00:32,800 --> 00:00:35,410
It will check with three after it came back from the collision.

8
00:00:35,410 --> 00:00:35,920
If it did it.

9
00:00:36,280 --> 00:00:38,290
It will come back to four, then five.

10
00:00:38,620 --> 00:00:40,000
This is something very important to do.

11
00:00:40,600 --> 00:00:44,980
So now that if you're going to start with the effects of zero, the first route is, you know, vested

12
00:00:44,980 --> 00:00:46,240
no workers on it.

13
00:00:46,570 --> 00:00:50,560
So now this is, you know, it would be bolded here as a three edged with us.

14
00:00:51,340 --> 00:00:55,300
Now we are at zero and zero has only one node, which is one.

15
00:00:55,300 --> 00:00:55,990
Is it visited?

16
00:00:55,990 --> 00:00:58,420
No, we recurs air defense of one.

17
00:00:58,600 --> 00:01:02,260
So now we won't be here and this now we know this vista.

18
00:01:03,430 --> 00:01:08,470
And one has also won two children, which is forward is four wasted, no.

19
00:01:08,740 --> 00:01:11,710
So we jump here to four recursively here.

20
00:01:11,710 --> 00:01:16,720
A market as wasted food doesn't have any children, so it's full of bull, not work.

21
00:01:17,140 --> 00:01:19,120
And then it will start to come back to one.

22
00:01:20,470 --> 00:01:24,990
But one also doesn't have wanted children, so it will come back to zero zero.

23
00:01:24,990 --> 00:01:26,410
Also, does it have more children?

24
00:01:26,710 --> 00:01:27,370
So it's done.

25
00:01:27,880 --> 00:01:33,490
Now we go back to two, which has three four and five zero three, four and five would be continued

26
00:01:33,490 --> 00:01:34,000
from here.

27
00:01:34,630 --> 00:01:40,630
Now the next edge is three defense of three.

28
00:01:41,350 --> 00:01:44,650
So we jump to the first of three.

29
00:01:45,400 --> 00:01:46,720
Is it visited more than John?

30
00:01:46,720 --> 00:01:47,050
Be here.

31
00:01:47,050 --> 00:01:50,860
And this is one more bolded edge here at three.

32
00:01:51,250 --> 00:01:53,590
We have um.

33
00:01:55,060 --> 00:01:55,670
No, no.

34
00:01:55,720 --> 00:01:57,660
No three has no no for A. No.

35
00:01:57,670 --> 00:02:00,580
Six now with three with a chick is four visited.

36
00:02:00,670 --> 00:02:01,570
The answer is yes.

37
00:02:01,780 --> 00:02:03,990
You know it is six harvested.

38
00:02:04,010 --> 00:02:05,500
The answer is no reverse.

39
00:02:05,830 --> 00:02:09,610
So with the cursor here and number six is it is accursed now.

40
00:02:09,820 --> 00:02:10,120
Six.

41
00:02:10,120 --> 00:02:15,130
It doesn't have any children so directly go back to three, which go back literally to two.

42
00:02:15,910 --> 00:02:16,900
And the next step.

43
00:02:17,050 --> 00:02:19,180
Remember, we go back to two to continue.

44
00:02:19,180 --> 00:02:20,200
This is very important.

45
00:02:20,560 --> 00:02:22,330
The next edges were four and five.

46
00:02:22,870 --> 00:02:25,390
Now four node is four wasted.

47
00:02:25,390 --> 00:02:26,890
Yes, ignore this edge.

48
00:02:28,030 --> 00:02:30,670
OK, what does the next five now?

49
00:02:30,670 --> 00:02:40,360
Node number five is this did not go from here, so five is listed and then five have one node, which

50
00:02:40,360 --> 00:02:42,100
at six whenever is visited.

51
00:02:42,100 --> 00:02:43,060
Yes, so ignore it.

52
00:02:43,600 --> 00:02:47,140
So as you see this are we?

53
00:02:47,140 --> 00:02:52,150
We managed to reach one two three four five six seven nodes.

54
00:02:52,600 --> 00:02:53,130
How many?

55
00:02:53,140 --> 00:02:55,480
Just one two three four five six.

56
00:02:55,870 --> 00:02:57,550
So as you see seven nodes.

57
00:02:58,910 --> 00:02:59,900
Six pages.

58
00:03:00,500 --> 00:03:04,760
This bolded images are a DFS first three.

59
00:03:05,270 --> 00:03:08,720
So this is mineral tracing in case you would like something to refresh.

60
00:03:09,170 --> 00:03:12,410
Now let's move further to important questions.

61
00:03:12,920 --> 00:03:17,690
The first question is what is the time complexity of the algorithm we just implemented?

62
00:03:19,070 --> 00:03:20,690
Let's make it easy for you at the beginning.

63
00:03:21,020 --> 00:03:23,510
Assuming we have a rota three as this one here.

64
00:03:24,600 --> 00:03:31,640
Now, as you know, this one would have like an inwards and in the minus one edges, but pretend it's

65
00:03:31,650 --> 00:03:32,120
in the name.

66
00:03:32,580 --> 00:03:35,040
Now what's the time complexity of defense on this one here?

67
00:03:35,460 --> 00:03:40,200
These take five or 10 minutes to think about it when you think about it as a defense.

68
00:03:40,280 --> 00:03:42,210
Three, We will never meet a vested node.

69
00:03:42,210 --> 00:03:43,620
Everyone would be treated.

70
00:03:43,830 --> 00:03:50,550
So if I would go here, go here, go here, go here, go back, go back here, go back here, go here.

71
00:03:50,850 --> 00:03:55,350
So as you see, every node would be visited, every edge would be listed.

72
00:03:55,620 --> 00:03:59,160
So we say that this is oh in blossom.

73
00:04:03,120 --> 00:04:09,570
OK, so in the next step, just remember that as Emma is already in the minus one, this actually,

74
00:04:09,570 --> 00:04:12,800
practically speaking, is just because Emma is already in.

75
00:04:12,840 --> 00:04:20,490
So this is like, oh, two enemies, this one, which is so and so very interesting, very, hopefully

76
00:04:20,490 --> 00:04:21,120
easy for you.

77
00:04:21,300 --> 00:04:29,790
Let's opposite to the actual case now, assume we have a directed Densey graph of any nudes and images.

78
00:04:30,270 --> 00:04:32,250
What is the time complexity of this function?

79
00:04:35,570 --> 00:04:37,180
Again, it is in Nablus.

80
00:04:37,520 --> 00:04:38,390
Can you think why?

81
00:04:40,280 --> 00:04:41,420
What do you think about it?

82
00:04:41,930 --> 00:04:51,080
First of all, the recursive function itself, the device to not function, this function will be called

83
00:04:51,200 --> 00:04:53,330
only at most times.

84
00:04:54,140 --> 00:04:54,720
Why?

85
00:04:55,190 --> 00:04:57,740
Because you never visit and that is visited.

86
00:04:58,370 --> 00:05:04,220
So our recursive code will be made for the root if and only if it has never been visited.

87
00:05:04,670 --> 00:05:12,590
And as we visit every node only once, then the defense code will will never be called more than in

88
00:05:12,590 --> 00:05:13,160
the times.

89
00:05:13,640 --> 00:05:16,160
So at most would have in the recursive calls.

90
00:05:20,340 --> 00:05:23,790
Why not exactly, Nichols, because some loser might not be eligible.

91
00:05:24,450 --> 00:05:29,010
Now when you reach A. Then you start to iterate on its neighbors.

92
00:05:29,850 --> 00:05:31,500
So, for example, node number two.

93
00:05:31,590 --> 00:05:37,260
So now we know that we will visit this once, once, once, once, once, once, once and once.

94
00:05:37,680 --> 00:05:41,970
But no, that occasion might give us a hard time about what really happened here.

95
00:05:43,230 --> 00:05:44,860
There are two ways to think about it.

96
00:05:45,390 --> 00:05:50,520
The first way, which is the easiest way mathematically also possible is to think in terms of the total

97
00:05:50,520 --> 00:05:53,820
number of edges, how this node it is used for ages.

98
00:05:54,060 --> 00:05:59,250
This one will treat one edge, one edge, one two edges and so on.

99
00:05:59,520 --> 00:06:05,820
So you might be puzzled because this four look will do a different number of steps in each school.

100
00:06:06,270 --> 00:06:13,230
But remember that if you thought in a global way the total number of iterations he had equal to the

101
00:06:13,230 --> 00:06:17,130
total number of edges, equal to the total number of edges.

102
00:06:17,550 --> 00:06:24,620
So the total submission of this for loop here is actually well e it will just iterate on it at most

103
00:06:24,630 --> 00:06:25,020
once.

104
00:06:25,350 --> 00:06:27,090
So again, this end up in a closet.

105
00:06:27,660 --> 00:06:33,990
If you'd like to think from another perspective, remember that the DFS created the S3 so very relevant

106
00:06:33,990 --> 00:06:35,880
to the previous example the rooted tree.

107
00:06:36,240 --> 00:06:38,190
Every edge users would be visited only once.

108
00:06:38,730 --> 00:06:44,770
So even like if you if you have a if the graph has cycles, the seekers are all are ignored, right?

109
00:06:44,790 --> 00:06:52,440
Like if if two five go to two and four go to zero and one go to two and three go to five on five to

110
00:06:52,440 --> 00:06:52,710
six.

111
00:06:53,070 --> 00:06:59,010
All of this edges are part of E, but all of them would be ignored because we are just creating a tree

112
00:06:59,010 --> 00:07:01,650
among all of these cycles inside the graph.

113
00:07:01,980 --> 00:07:04,410
So this is another way to think about it this time.

114
00:07:04,410 --> 00:07:07,860
Complexity is very important, so please make sure that you get it.

115
00:07:11,080 --> 00:07:14,230
Um, yeah.

116
00:07:15,990 --> 00:07:22,180
What call the order of what the edges with this, yeah, this is just more more logic here that I already

117
00:07:22,180 --> 00:07:22,570
mentioned.

118
00:07:22,930 --> 00:07:25,450
What if the graph is adjacency matrix?

119
00:07:25,540 --> 00:07:27,160
The code definitely will need to be changed.

120
00:07:27,160 --> 00:07:31,480
If this is just in semantics, then you would have to iterate for integer I.

121
00:07:33,480 --> 00:07:42,030
Equals zero and then oil is then end and plus plus I and then you need to check if a graph of node.

122
00:07:43,240 --> 00:07:49,450
And the equal one, then this is right, remember, how do we trace on the adjacency graph for the brain

123
00:07:49,450 --> 00:07:52,810
to function in that just as a matrix, we have to treat in a different way.

124
00:07:52,990 --> 00:07:55,330
So this look is trading on a decency list.

125
00:07:55,810 --> 00:08:01,570
Is it heaven that we have to iterate, treat allergies as the graph the now we are actually iterating

126
00:08:02,590 --> 00:08:06,010
in the square on the wall graph, right?

127
00:08:06,250 --> 00:08:07,570
Because we are rotating on every day.

128
00:08:07,570 --> 00:08:13,480
So it ended up like in Nablus, in the square, in the square for all of the rules or just even in the

129
00:08:13,480 --> 00:08:14,320
square overall.

130
00:08:15,340 --> 00:08:22,450
So this is mainly the time complex and as you see the there that the blossom is generally speaking more

131
00:08:22,450 --> 00:08:24,940
efficient here, especially the graphic spots.

132
00:08:28,630 --> 00:08:30,160
What about the memory complexity?

133
00:08:30,820 --> 00:08:33,670
We created a Boolean array of any nodes.

134
00:08:33,880 --> 00:08:34,930
So this is all in.

135
00:08:35,650 --> 00:08:39,850
And also we have a recursion that will do at most in the recursive calls.

136
00:08:40,450 --> 00:08:42,700
And this is something that students always miss.

137
00:08:42,910 --> 00:08:45,820
Remember that recursion has an auxiliary space.

138
00:08:46,570 --> 00:08:53,110
So if you have, generally speaking, if you have any recursive calls and each school has it in local

139
00:08:53,110 --> 00:08:56,050
memory, then this is all in memory.

140
00:08:56,590 --> 00:08:58,900
Our algorithm body is all one memory.

141
00:08:59,260 --> 00:09:01,780
So the overall is in accelerator space.

142
00:09:02,200 --> 00:09:04,000
End the from here or in the from here.

143
00:09:04,210 --> 00:09:08,500
In total, we have an all in an auxiliary auxiliary space.

144
00:09:11,190 --> 00:09:12,750
I would like to give you a tip.

145
00:09:13,200 --> 00:09:15,540
I explained it during my explanation.

146
00:09:15,810 --> 00:09:22,110
Sometimes it is easier to think about the total number of steps of a block rather than a specific line

147
00:09:22,110 --> 00:09:22,470
of code.

148
00:09:22,710 --> 00:09:28,680
And the example that I give here is that neighbors, if you started to think about every node by itself,

149
00:09:28,920 --> 00:09:33,150
you will get lost because this loop will do a dynamic number of steps, Bernard.

150
00:09:33,540 --> 00:09:38,970
But if you thought you know what, all of the total steps here are just to the total number of edges.

151
00:09:39,330 --> 00:09:45,030
So it's actually the submission of the neighbors of node number I, which is just E.

152
00:09:45,540 --> 00:09:47,870
So this is in a way, the total number of coverages.

153
00:09:48,660 --> 00:09:54,360
Generally speaking, traversal graphs are linear in terms of the time complexity in terms of the nodes

154
00:09:54,630 --> 00:10:00,710
and terms of their just the device for their direct care for the American Graph is the same could,

155
00:10:00,780 --> 00:10:03,150
as I mentioned, but just iterate on the different way.

156
00:10:03,150 --> 00:10:04,620
Look, as I mentioned I0.

157
00:10:05,740 --> 00:10:09,050
I listen in and the time complex is also the same.

158
00:10:09,070 --> 00:10:12,370
There is just one minor change here in the office.

159
00:10:12,370 --> 00:10:13,990
Every edge is visited twice.

160
00:10:13,990 --> 00:10:14,950
What undirected graph?

161
00:10:15,280 --> 00:10:21,820
Because if we have not no to go to rule number seven, then two has a seven as a neighbor and seven

162
00:10:21,820 --> 00:10:22,570
has to as a neighbor.

163
00:10:22,570 --> 00:10:24,040
So we trade on this issue twice.

164
00:10:24,580 --> 00:10:30,660
But if the directed Graph two and the seven, then only two go to seven on the one, so the edges traverse

165
00:10:30,680 --> 00:10:32,110
reverted here only once.

166
00:10:36,440 --> 00:10:40,070
I would like to mention something, but I don't want you to get lost about it, it is.

167
00:10:40,070 --> 00:10:41,880
It is something that you rarely used.

168
00:10:41,900 --> 00:10:44,270
All I wanted you to know is just to.

169
00:10:44,690 --> 00:10:46,820
You're here to to to know this name.

170
00:10:47,120 --> 00:10:48,920
There is something called iterative living.

171
00:10:49,160 --> 00:10:51,500
The idea is this following of this variant.

172
00:10:52,470 --> 00:10:56,600
Let's say that the graph is very deep, very, very deep.

173
00:10:57,820 --> 00:11:03,100
And let's see what searching for something that should be answered in the very early ages here.

174
00:11:03,700 --> 00:11:04,750
The problem is.

175
00:11:06,100 --> 00:11:09,070
That occasion would keep going very, very, very deep.

176
00:11:10,000 --> 00:11:16,240
If we would like to force that algorithm to not go through DBR before finishing the early levels, there

177
00:11:16,240 --> 00:11:16,630
is a race.

178
00:11:16,930 --> 00:11:17,710
The nice trick?

179
00:11:18,010 --> 00:11:22,990
Let's say you would like the graph to even never go beyond the 10 edges, for example.

180
00:11:23,860 --> 00:11:27,460
Like if the graph has 100 edge, you just want to be limited to 10 edges.

181
00:11:27,790 --> 00:11:32,560
You can add a depth of variable for your defense function, such as that.

182
00:11:32,830 --> 00:11:36,910
If the current dips is greater than equal, the limit depth just return.

183
00:11:37,990 --> 00:11:40,780
OK, now I would like to get, for example, the reachable nodes.

184
00:11:40,780 --> 00:11:41,620
What should we do?

185
00:11:42,160 --> 00:11:43,600
You will iterate in the mean.

186
00:11:45,980 --> 00:11:50,410
Starting from the maybe minimum deposit that you need, maybe six, maybe up to the maximum depths,

187
00:11:50,420 --> 00:11:51,410
maybe 15.

188
00:11:51,860 --> 00:11:57,590
And every time you run your graph starting from the depths, but every time you will reset the vested

189
00:11:57,590 --> 00:12:02,630
victor and then the graph will burst the graph up to this depth.

190
00:12:03,080 --> 00:12:04,580
Let me give you some tracing.

191
00:12:04,970 --> 00:12:09,260
Let's say that in the first time, maybe you ask, could the depth to be just one?

192
00:12:09,650 --> 00:12:10,940
So graph of depth equals one.

193
00:12:11,510 --> 00:12:12,950
So now the rule started from here.

194
00:12:12,950 --> 00:12:14,120
Vested go to here.

195
00:12:14,120 --> 00:12:17,200
Vested now who need good to hear it will come back directly.

196
00:12:17,210 --> 00:12:17,630
Why?

197
00:12:17,990 --> 00:12:20,140
Because the deep sea it is more than to it.

198
00:12:20,150 --> 00:12:21,290
More than one should return.

199
00:12:21,770 --> 00:12:23,120
Now try 021.

200
00:12:23,720 --> 00:12:27,890
So this is the research was a divisive one would only try.

201
00:12:28,870 --> 00:12:29,710
This news here.

202
00:12:30,490 --> 00:12:34,190
Now, let's say we didn't find our target, so we need to expand our test.

203
00:12:34,210 --> 00:12:36,940
But he said the vista vector and try dips too.

204
00:12:37,210 --> 00:12:40,310
So now we try up to here, up to here, up to it, up to you.

205
00:12:40,750 --> 00:12:45,910
If we imagine that there are more nodes here and nodes here and nodes here that what would be visited

206
00:12:45,910 --> 00:12:47,350
early would be this.

207
00:12:48,450 --> 00:12:56,310
To live apart so that say this is the reason behind this new iterative dipping, it means dry depth

208
00:12:56,310 --> 00:12:59,460
of by depth iteratively and try to find your good.

209
00:12:59,940 --> 00:13:05,920
Generally speaking, I rarely use this vision, even in competitive programming.

210
00:13:05,940 --> 00:13:13,020
I used only maybe twice in my whole life, so it is neither like coming in in competitions or even in

211
00:13:13,050 --> 00:13:16,200
normal algorithms, but said I wanted you to be familiar with it.

212
00:13:16,710 --> 00:13:22,770
Uh, there is another algorithm that we will learn that could be a service which actually most of the

213
00:13:22,770 --> 00:13:25,590
time would be used instead of this kind of iterative debate.

214
00:13:26,490 --> 00:13:26,690
Of.
