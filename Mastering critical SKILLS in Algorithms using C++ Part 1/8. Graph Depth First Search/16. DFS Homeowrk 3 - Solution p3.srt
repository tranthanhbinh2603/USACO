1
00:00:00,750 --> 00:00:06,100
Let's solve the third problem, the longest consecutive sequence this problem Lake.

2
00:00:06,390 --> 00:00:10,560
Contrary to the previous two problems, like the previous two problems of the graph solution is playing

3
00:00:10,560 --> 00:00:17,310
a big role in this problem is actually the right way isn't a great business solution, but we will still

4
00:00:17,310 --> 00:00:22,350
show how a graph based solution can be used in this problem, which will certainly be very interesting

5
00:00:22,350 --> 00:00:23,850
but still tricky to implement.

6
00:00:24,510 --> 00:00:30,970
So the first the question here, how can we represent a set of numbers as a graph?

7
00:00:30,990 --> 00:00:33,210
We did that so far several times, right?

8
00:00:33,630 --> 00:00:35,910
This is the fourth time to do that.

9
00:00:36,000 --> 00:00:41,340
So I hope that you note that how many times of this problem, the numbers can be represented as a graph.

10
00:00:41,850 --> 00:00:48,780
So if we have numbers like one two three four five, what make it in terms of a graph as a conservative?

11
00:00:49,500 --> 00:00:54,330
So again, again, let's say one, two, three, four and five are nodes.

12
00:00:55,050 --> 00:00:57,840
Now let's see also that we have here it was us.

13
00:00:58,860 --> 00:01:02,100
In terms of consecutive to create a graph, what makes sense is.

14
00:01:03,220 --> 00:01:08,980
Conservative values need to be connected, so if that is it, it also we don't connected with anyone.

15
00:01:09,700 --> 00:01:10,240
Why?

16
00:01:10,480 --> 00:01:11,830
Because there is no relationship.

17
00:01:12,370 --> 00:01:17,560
So the sense of here is as following if you have a bunch of conservative numbers, you better connected

18
00:01:17,560 --> 00:01:18,550
them with each other.

19
00:01:19,390 --> 00:01:21,310
So the idea now would be pretty simple.

20
00:01:21,760 --> 00:01:25,600
Dig the array converted to graph that symbol.

21
00:01:26,290 --> 00:01:28,810
OK, how can we build the graph efficiently?

22
00:01:29,140 --> 00:01:32,030
We would like only to make it just between consecutive numbers.

23
00:01:32,050 --> 00:01:35,380
How can I know if these two numbers are conservative?

24
00:01:36,160 --> 00:01:37,720
As simple as the following.

25
00:01:39,080 --> 00:01:43,100
Let's say I give you the input as following.

26
00:01:43,520 --> 00:01:52,640
I told you that the input is one seven two three six 10.

27
00:01:55,180 --> 00:01:59,550
Now we know that we have all of this as news for us, so let's say we have the rule number one now.

28
00:01:59,670 --> 00:02:05,260
Now we know that there is between one two, but how to know that simply check if one plus one exist

29
00:02:05,260 --> 00:02:08,740
or not, one plus one is two does to exist in the in the numbers.

30
00:02:08,980 --> 00:02:09,370
Yes.

31
00:02:09,670 --> 00:02:11,350
Then there must be one or two here.

32
00:02:12,290 --> 00:02:13,130
Now take seven.

33
00:02:13,520 --> 00:02:16,910
So we have seven, as in the civilian six exists.

34
00:02:17,330 --> 00:02:18,630
What is after seven eight?

35
00:02:18,650 --> 00:02:19,620
Does it exist?

36
00:02:19,690 --> 00:02:20,300
It doesn't exist.

37
00:02:20,300 --> 00:02:22,040
So leave it now to.

38
00:02:23,090 --> 00:02:25,020
Does 2+1, which is three, exist?

39
00:02:25,040 --> 00:02:25,470
Yes.

40
00:02:25,490 --> 00:02:26,930
No, there must be an edge here.

41
00:02:28,130 --> 00:02:29,860
Six, the seven exists.

42
00:02:29,990 --> 00:02:32,300
Yes, then six and seven must be connected.

43
00:02:32,990 --> 00:02:34,700
10 does 10 exist?

44
00:02:35,770 --> 00:02:36,560
Does 11 exist?

45
00:02:36,590 --> 00:02:36,830
No.

46
00:02:37,220 --> 00:02:38,510
So the idea is very trivial.

47
00:02:38,900 --> 00:02:41,390
We would like to build the edges between that and Verblitz one.

48
00:02:41,930 --> 00:02:47,510
So for every value check of the next one for it, exist or not, if it exists, then we have an edge.

49
00:02:48,260 --> 00:02:49,160
Now we build two there.

50
00:02:49,400 --> 00:02:53,690
The graph, the graph consist of simple nodes like then here or a chains.

51
00:02:53,870 --> 00:02:59,810
This is actually a bunch of chains, and the task now is as simple as justifying the chain that has

52
00:02:59,810 --> 00:03:01,640
the longest number of nodes that symbol.

53
00:03:02,270 --> 00:03:03,410
And as we did before.

54
00:03:03,680 --> 00:03:09,530
How to know the start or the end of the chain, the fittest or the end would have degree of one.

55
00:03:09,800 --> 00:03:11,300
But the middle values would have to.

56
00:03:11,900 --> 00:03:12,440
That's all.

57
00:03:12,500 --> 00:03:18,020
The problem is solved, but sadly you have to be careful in your implementation about a few special

58
00:03:18,020 --> 00:03:18,410
cases.

59
00:03:18,740 --> 00:03:22,190
One case, if the graph is empty, then the answer is logically zero.

60
00:03:22,730 --> 00:03:26,690
Another case is the graph has maybe like, let's say we have like one in 10.

61
00:03:27,140 --> 00:03:29,390
So this is actually two separate nodes.

62
00:03:31,070 --> 00:03:35,060
And it might be tricky, like it depends on your implementation.

63
00:03:35,300 --> 00:03:40,820
So for me, I need to make sure of if there are no edges and there are at least nodes, then there are

64
00:03:40,820 --> 00:03:41,300
stability.

65
00:03:41,360 --> 00:03:42,290
So the answer is one.

66
00:03:43,810 --> 00:03:45,250
So let's see the implementation here.

67
00:03:51,150 --> 00:03:55,980
One other one, one more, one more tricky here, like, as I said, you should be able to get a careful

68
00:03:56,130 --> 00:04:00,630
implementation, doubling good values like, let's say we have 0001.

69
00:04:00,930 --> 00:04:03,840
So you will go to the first number and say zero is what exists.

70
00:04:03,850 --> 00:04:04,830
Yes, zero one here.

71
00:04:04,830 --> 00:04:06,180
Exist now.

72
00:04:06,180 --> 00:04:07,470
Oh, zero and one exists.

73
00:04:07,470 --> 00:04:08,520
Yes, zero one exists.

74
00:04:08,520 --> 00:04:09,260
Zero one exists.

75
00:04:09,270 --> 00:04:10,230
Yes, zero one exists.

76
00:04:10,500 --> 00:04:11,690
What's the problem with that?

77
00:04:11,710 --> 00:04:12,090
You will.

78
00:04:12,160 --> 00:04:15,930
We will not be able to figure it out there first, the value of the chain.

79
00:04:16,200 --> 00:04:21,390
So you only need to keep one of them because we said that the chain is mainly based on the one that

80
00:04:21,390 --> 00:04:22,380
has only one neighbor.

81
00:04:22,380 --> 00:04:24,990
But this now it has three neighbors and they are useless.

82
00:04:25,320 --> 00:04:27,450
So be careful also about duplicate value.

83
00:04:27,660 --> 00:04:30,870
Overall, it's nice, but it's a bit tricky to implement.

84
00:04:32,200 --> 00:04:35,860
OK, we will use an order, the map, because the values are big.

85
00:04:36,130 --> 00:04:37,270
This is a normal way.

86
00:04:37,630 --> 00:04:42,250
This is a defense that returned their number of nodes in their.

87
00:04:43,250 --> 00:04:44,770
We'll come back to it now later.

88
00:04:45,370 --> 00:04:47,350
So let's go to the implementation here.

89
00:04:47,740 --> 00:04:52,480
First of all, I take all of the victor values and add them in the set.

90
00:04:52,660 --> 00:04:54,850
So now we have an order that has all of the values.

91
00:04:55,510 --> 00:05:02,290
If the set size is zero, return is zero cinemagraph, otherwise create a graph iterate on the values.

92
00:05:02,530 --> 00:05:04,870
This is how we treat on a certain model C++.

93
00:05:05,620 --> 00:05:08,230
If the set we have the value here, let's say seven.

94
00:05:08,890 --> 00:05:13,420
If this it has a value of eight, then we know that seven and eight are an inch.

95
00:05:14,020 --> 00:05:16,630
Now the graph is done next.

96
00:05:17,850 --> 00:05:21,970
Well, I'm going to initialize the maximum 6cm bullet with the value one.

97
00:05:21,990 --> 00:05:22,650
Why?

98
00:05:22,680 --> 00:05:27,330
Because now we know, we don't know there are some nodes, so maybe in the worst case, we would have

99
00:05:27,330 --> 00:05:28,110
something like that.

100
00:05:28,740 --> 00:05:31,710
So that said, in a way is one node that one values are considered consecutive.

101
00:05:31,740 --> 00:05:35,910
Otherwise we will have a change of like one and two and three and so on.

102
00:05:36,180 --> 00:05:38,010
So this is mainly for a case like one in 10.

103
00:05:39,080 --> 00:05:41,390
In a very normal way would make our defense.

104
00:05:41,960 --> 00:05:48,740
And here we will say the following if this note hasn't been visited before and the size of the decency,

105
00:05:48,740 --> 00:05:51,850
this is one which you mean it is ahead of the adjacency test.

106
00:05:52,100 --> 00:05:54,350
I'm going to make defense from this note.

107
00:05:54,680 --> 00:05:56,180
The defense will return for me.

108
00:05:56,390 --> 00:05:59,540
The size of the connected component, the size of the connected component.

109
00:05:59,960 --> 00:06:05,990
Then I'm going to maximize on the slice, observe that I could do it in the normal way and attach a

110
00:06:05,990 --> 00:06:09,230
vector of integer for then visited nodes and just use the length of it.

111
00:06:09,590 --> 00:06:12,980
I would like to show you another way, given that we don't care about that.

112
00:06:13,400 --> 00:06:17,840
The connected component values itself we could just connect about would care about the number of values

113
00:06:17,840 --> 00:06:18,080
here.

114
00:06:19,700 --> 00:06:26,990
So this good is is going to make a difference, but it will return also the total number of nodes in

115
00:06:26,990 --> 00:06:28,010
the connected components.

116
00:06:28,370 --> 00:06:35,030
But but actually it's for a team like we know the values are one two three and the four of you will

117
00:06:35,030 --> 00:06:35,610
be like that.

118
00:06:35,960 --> 00:06:41,350
So I'm doing the following whenever I have a neighbor, I see one blast there.

119
00:06:41,780 --> 00:06:43,790
The first two from here, which will eternity.

120
00:06:44,090 --> 00:06:47,000
And this is the first we have seen one plus difficile here.

121
00:06:47,180 --> 00:06:48,170
One plus one plus.

122
00:06:48,170 --> 00:06:48,500
I hope.

123
00:06:48,830 --> 00:06:49,100
I hope.

124
00:06:49,100 --> 00:06:51,950
No, this is a pretty easy decision for you anyway.

125
00:06:52,760 --> 00:06:53,710
It's pretty simple.

126
00:06:53,720 --> 00:06:54,890
You can do it in many ways.

127
00:06:55,310 --> 00:07:01,880
You can make here a reference counter zero and every time you visit and you just do calculus.

128
00:07:01,880 --> 00:07:06,850
Plus this is would be good and valid if even you would like to make a difference.

129
00:07:07,490 --> 00:07:12,290
A could a collector component to the number of nodes on a general graph like here, I'm assuming that,

130
00:07:12,800 --> 00:07:17,000
um, is this as a chain, I'm returning with the first to neighbor.

131
00:07:18,010 --> 00:07:20,080
What if we have a corrected graph like that?

132
00:07:22,050 --> 00:07:27,480
The school do not return to the total size, OK, so maybe if you have here a reference for the total

133
00:07:27,480 --> 00:07:32,700
vested nodes and increment here with every new node, then you got the total number of votes.

134
00:07:33,150 --> 00:07:39,570
So now we implemented the code and we are we are done with that, by the way here.

135
00:07:39,780 --> 00:07:40,770
This is very important.

136
00:07:41,040 --> 00:07:45,240
I am iterating on that set, not on the array because they have duplicate values.

137
00:07:45,250 --> 00:07:46,530
This one, does it have to be converted?

138
00:07:46,740 --> 00:07:49,230
If you didn't do that, you would get I don't answer.

139
00:07:50,410 --> 00:07:53,130
Now the last thing is, I would like to show you one more thing here.

140
00:07:53,610 --> 00:07:54,780
A very simple observation.

141
00:07:57,350 --> 00:08:03,800
How to do the chin first value without the it's up with the graph who said that if we have nodes, the

142
00:08:03,800 --> 00:08:05,840
one two three four.

143
00:08:06,110 --> 00:08:10,100
We mentioned that the Roots one and four will have only one neighbor.

144
00:08:10,460 --> 00:08:13,130
How to know the answer without the graph at all?

145
00:08:13,520 --> 00:08:14,990
Very simple observation.

146
00:08:16,710 --> 00:08:20,970
So let's say we have the consecutive values 10, 11 and 12 and 13.

147
00:08:21,450 --> 00:08:25,500
How to know that 10 is the fittest, the smallest, the value in the chain.

148
00:08:26,680 --> 00:08:33,970
Simply, the value nine doesn't exist in the city, so at any point of time, if the value does it have

149
00:08:33,970 --> 00:08:37,240
some value before it, it must be the first the value in it.

150
00:08:37,930 --> 00:08:41,350
So this is a very interesting way to know that this is a starting value.

151
00:08:42,690 --> 00:08:48,150
Now, this even means we can now, like in the previous good, I implemented the graph as a undirected

152
00:08:48,150 --> 00:08:48,540
graph.

153
00:08:48,780 --> 00:08:52,710
Now you can even be limited as a directed graph.

154
00:08:54,170 --> 00:08:59,060
Like in the previous one, it was undirected and the like, the degree here was one.

155
00:08:59,300 --> 00:09:00,230
And here was one.

156
00:09:00,560 --> 00:09:04,460
Now I have one one one and this one has zero, so it's a bit different.

157
00:09:04,490 --> 00:09:05,670
It doesn't matter a lot.

158
00:09:05,960 --> 00:09:07,190
But just as an idea here.

159
00:09:07,580 --> 00:09:09,170
So let's see the implementation.

160
00:09:10,550 --> 00:09:12,410
No imitation is pretty the same here.

161
00:09:14,750 --> 00:09:17,240
Uh, everything is set.

162
00:09:17,270 --> 00:09:19,280
I'm just here this time, adding the wretched one.

163
00:09:19,700 --> 00:09:21,080
Yeah, one simplification.

164
00:09:21,080 --> 00:09:22,780
I don't need any vested values anymore.

165
00:09:22,790 --> 00:09:25,040
I do need I do need the vista value here.

166
00:09:25,370 --> 00:09:32,720
So because the graph is is directed, remember again and we stress that this it is important for two

167
00:09:32,720 --> 00:09:33,170
reasons.

168
00:09:33,500 --> 00:09:35,570
You visit your parents again.

169
00:09:36,290 --> 00:09:38,930
You visit something that you visited before.

170
00:09:40,250 --> 00:09:41,300
If you are in a dark.

171
00:09:43,530 --> 00:09:45,610
Which is a graph that doesn't have cycles.

172
00:09:46,410 --> 00:09:49,320
Direct one, you would never have these two cases.

173
00:09:50,070 --> 00:09:55,890
So you do need visited array when you are there face on air directed graph.

174
00:09:56,160 --> 00:09:58,950
You only need it in two cases.

175
00:09:59,250 --> 00:10:03,270
If the graph is uncorrected or the graph is the electoral cycles.

176
00:10:03,270 --> 00:10:05,370
But for DAG, you didn't need it.

177
00:10:05,910 --> 00:10:09,450
When we built it, a graph like one go two to go to three.

178
00:10:09,780 --> 00:10:11,100
This is a direct to the chain.

179
00:10:11,520 --> 00:10:14,070
So this is a dag, so you don't need any more.

180
00:10:14,070 --> 00:10:15,900
They're vested because you would never visited.

181
00:10:16,380 --> 00:10:21,180
So here are the this is the second to tell you the time in the code we can make now a difference in

182
00:10:21,180 --> 00:10:24,150
a very simple way without worrying about the vista that.

183
00:10:25,270 --> 00:10:27,670
So I want to take the good here in two different ways.

184
00:10:27,970 --> 00:10:29,680
It is the first one which is recursive.

185
00:10:30,070 --> 00:10:30,910
I just.

186
00:10:31,910 --> 00:10:32,270
Take the.

187
00:10:32,570 --> 00:10:35,850
Return one, bless the naval one, bless the neighboring blustery.

188
00:10:36,560 --> 00:10:38,690
If that doesn't have any neighbors, we return one.

189
00:10:39,350 --> 00:10:43,680
And also, as we know that there's just a single chin now directed, we can make it very iterative like.

190
00:10:44,150 --> 00:10:47,450
We have one, two, three and four.

191
00:10:47,840 --> 00:10:51,920
I want to start from one count, one move count, one move, move, move.

192
00:10:51,920 --> 00:10:54,710
We cannot anything else return so we can even return.

193
00:10:54,730 --> 00:10:56,060
It developed iterative.

194
00:10:56,570 --> 00:11:01,790
So as you see, this simple observation actually resulted in a could that is a bit smaller the crab

195
00:11:01,790 --> 00:11:03,260
business, mortar and so on.

196
00:11:03,800 --> 00:11:08,150
Now I want to tell you about something very weird that it wasted my time and I couldn't reach anything

197
00:11:08,930 --> 00:11:10,880
in late could when I used an order.

198
00:11:10,880 --> 00:11:17,050
The map for this problem, for one of the just two cases I think I listed down here, it feels, and

199
00:11:17,090 --> 00:11:20,960
I don't know why the case on my machine works well.

200
00:11:20,960 --> 00:11:23,020
The case on their machine doesn't work well.

201
00:11:23,150 --> 00:11:24,080
So this is so weird.

202
00:11:24,380 --> 00:11:26,960
So I ended up switching it to map to work well.

203
00:11:27,200 --> 00:11:32,090
Somehow, the internet and validators, the internal literature are invalidated and make just that the

204
00:11:32,090 --> 00:11:32,470
could feel.

205
00:11:32,480 --> 00:11:37,610
I kept the bugging debugging, and I never did anything with lit code in this site.

206
00:11:37,910 --> 00:11:43,250
But in a way, it doesn't matter what I think the code itself is valid and that it should be OK when

207
00:11:43,260 --> 00:11:44,210
your personal machine.

208
00:11:44,630 --> 00:11:46,340
Maybe something wrong with the compiler.

209
00:11:46,340 --> 00:11:47,530
Unneeded code of sight.

210
00:11:48,650 --> 00:11:51,050
I hope you learned something from this problems.
