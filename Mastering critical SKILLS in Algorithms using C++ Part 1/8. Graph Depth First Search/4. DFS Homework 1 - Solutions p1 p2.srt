1
00:00:00,590 --> 00:00:07,370
Let's solve the first the homework with the first one about the kill process here and in this problem,

2
00:00:07,370 --> 00:00:12,680
if you noticed this is exactly the reachability problem, right?

3
00:00:12,710 --> 00:00:14,120
I'm asking you for the reachability.

4
00:00:14,120 --> 00:00:20,150
You have a three and all you need is just to list all of the reachable nodes.

5
00:00:20,600 --> 00:00:24,350
So this is mainly the request, if I asked for this newly written this note on all of this.

6
00:00:24,530 --> 00:00:26,750
So this is actually the reachability problem.

7
00:00:27,170 --> 00:00:28,490
There is only one issue here.

8
00:00:28,760 --> 00:00:30,380
The values are pretty big.

9
00:00:30,830 --> 00:00:34,430
So in the usual graph, we have something from zero in the minus one.

10
00:00:34,970 --> 00:00:40,160
But now this is pretty bigger than usual numbers because the Bruces ideas are very big and this could

11
00:00:40,160 --> 00:00:41,090
happen in reality.

12
00:00:41,480 --> 00:00:44,120
So you could have a small graph of only three nodes.

13
00:00:44,300 --> 00:00:49,120
But the first one has an idea of 10000, and this one has idea of maybe 50000 and so on.

14
00:00:49,130 --> 00:00:50,910
So many big ideas for only three nodes.

15
00:00:52,340 --> 00:00:53,420
How to handle that?

16
00:00:53,810 --> 00:00:59,690
We will just as simple as make some adjustment for the graph to depend on two things.

17
00:01:00,320 --> 00:01:04,130
The graph representation itself will start to use an order the map.

18
00:01:04,550 --> 00:01:11,990
So we will build the the edges such that there is a hash table from node, for example, one thousand

19
00:01:11,990 --> 00:01:14,570
two node, for example, 2000.

20
00:01:15,050 --> 00:01:19,280
So the edges here would be based middle and order map.

21
00:01:20,120 --> 00:01:22,550
So this will use it to represent that graph itself.

22
00:01:23,210 --> 00:01:25,850
The second thing we would like to mark the nodes as visited.

23
00:01:26,090 --> 00:01:33,260
So with an order, the said for that, this end up with a time complexity the same as the normal algorithm.

24
00:01:34,580 --> 00:01:39,860
This representation is very powerful for very specific graphs like imagine that there are a lot of isolated

25
00:01:39,860 --> 00:01:40,100
nodes.

26
00:01:40,220 --> 00:01:43,460
So this one could be, uh, be very flexible.

27
00:01:43,790 --> 00:01:45,170
So it is implementation.

28
00:01:46,040 --> 00:01:49,030
Uh, we have here an adjacent Celeste.

29
00:01:49,040 --> 00:01:54,870
But all what happened is we used an order the map from an integer to a vector integer here.

30
00:01:54,890 --> 00:01:55,220
OK.

31
00:01:55,430 --> 00:01:59,570
Someone may, might even would like to make this like a hash, said this, that it would be like an

32
00:01:59,570 --> 00:02:01,820
order the map of integer and has set.

33
00:02:02,090 --> 00:02:02,630
That's OK.

34
00:02:02,640 --> 00:02:06,350
But we don't care here now that much because we just need to iterate on the numbers.

35
00:02:06,920 --> 00:02:09,740
So we have here an order the map of integer.

36
00:02:09,950 --> 00:02:11,780
So now a key.

37
00:02:11,780 --> 00:02:18,860
For example, what hundred would have the list of maybe seven, maybe 2000, maybe five, which is my

38
00:02:18,860 --> 00:02:19,130
neighbor?

39
00:02:19,140 --> 00:02:21,470
Sort of what we gained in just this flexibility.

40
00:02:21,920 --> 00:02:24,890
And then we adjusted the ad directed edge to be in this way.

41
00:02:25,550 --> 00:02:27,850
Now they give us the idea and idea.

42
00:02:28,220 --> 00:02:31,780
We will iterate and add directed edges from the ID to be idea.

43
00:02:31,850 --> 00:02:38,030
So this is how we build the graph when it comes to iteration, the iteration here is as simple as you

44
00:02:38,390 --> 00:02:39,140
used it.

45
00:02:39,500 --> 00:02:43,700
But now, instead of vector of integer, we need something that allow bigger ideas.

46
00:02:43,700 --> 00:02:47,030
So we use the hash sat here and then we check it here.

47
00:02:47,640 --> 00:02:48,170
Let's hold.

48
00:02:48,560 --> 00:02:52,190
Anything else is just like a more or less implementation is counts.

49
00:02:54,470 --> 00:02:55,820
In the second problem.

50
00:02:57,140 --> 00:02:59,530
We would like to the Embley problem.

51
00:02:59,540 --> 00:03:04,840
So this is again another reachability problem, and it's 023.

52
00:03:04,850 --> 00:03:06,110
So what is new here?

53
00:03:06,710 --> 00:03:07,820
The new is two things.

54
00:03:08,060 --> 00:03:13,310
First of all, the value is the way it is with the road, not with the H.

55
00:03:13,790 --> 00:03:16,670
So this time, but obviously we have a three this way.

56
00:03:16,700 --> 00:03:19,040
Maybe this is exhibit this ID eight.

57
00:03:19,400 --> 00:03:23,300
Now we have a value burn with like five, three two.

58
00:03:24,170 --> 00:03:27,800
And I told you in the lecture before that even nudes can sometimes ever wait.

59
00:03:28,220 --> 00:03:31,970
The second thing is we already are given a good, a good graph.

60
00:03:32,150 --> 00:03:36,200
So maybe we can use it as it is without having to create our own graph.

61
00:03:36,440 --> 00:03:38,540
Remember the domain and the standard of that?

62
00:03:38,780 --> 00:03:43,400
I wanted you to try to iterate here based on the graph to make our life easy.

63
00:03:43,640 --> 00:03:44,990
And to make things efficient.

64
00:03:45,230 --> 00:03:49,280
We have a symbol stable that map for us an ID to its object.

65
00:03:49,670 --> 00:03:53,000
So first of all, we will trade on all of the objects and then MEB.

66
00:03:53,000 --> 00:03:58,010
The ID to the object, for example, would have an idea like 12 going to the object, which has zero

67
00:03:58,010 --> 00:03:59,420
x one one two blah blah blah.

68
00:04:00,020 --> 00:04:01,190
Then what does that do?

69
00:04:01,440 --> 00:04:03,140
Reachability from this idea?

70
00:04:04,070 --> 00:04:09,230
It will start by getting the ID then bleak or responding to this ID.

71
00:04:09,890 --> 00:04:16,880
Then, uh, this is my current result, and I will iterate on my all of my employees and adding.

72
00:04:18,320 --> 00:04:22,100
It's unresolved now, this is a race and recursive definition here.

73
00:04:22,370 --> 00:04:23,630
So let's think about it here.

74
00:04:24,200 --> 00:04:27,550
Let's think as a normal graph you have here too.

75
00:04:28,490 --> 00:04:29,520
Uh?

76
00:04:29,990 --> 00:04:30,590
OK, let's see.

77
00:04:30,590 --> 00:04:32,180
Represented as following.

78
00:04:33,540 --> 00:04:34,560
Will make a circle.

79
00:04:34,890 --> 00:04:38,490
The first one is the ideal, it's collegial and valued, it's set well.

80
00:04:39,120 --> 00:04:42,210
And then this one go to hear two and maybe three.

81
00:04:42,480 --> 00:04:43,830
And value, which is 15.

82
00:04:44,280 --> 00:04:46,870
And then another year, maybe two.

83
00:04:46,870 --> 00:04:50,400
No, the number two and value 20.

84
00:04:50,730 --> 00:04:52,470
And then this one go to here to rule.

85
00:04:52,470 --> 00:04:53,000
No.

86
00:04:53,250 --> 00:04:55,230
Maybe food and value.

87
00:04:55,250 --> 00:04:57,790
Um, 13.

88
00:04:58,290 --> 00:05:01,350
And this one go here to ironwood, which is five.

89
00:05:01,530 --> 00:05:02,850
And value 50.

90
00:05:03,180 --> 00:05:05,280
And maybe here six.

91
00:05:05,550 --> 00:05:09,690
And value, uh, maybe hundred and one.

92
00:05:11,090 --> 00:05:18,890
That it just happened, so now I would like when I recurs on this note here, I would like to to some

93
00:05:19,250 --> 00:05:21,050
15, some 30.

94
00:05:21,440 --> 00:05:28,010
If I requested on 12, I would like to return as the sum of 12, 15, 30, 50 to 100 and all of them.

95
00:05:28,640 --> 00:05:31,220
So this is a zero to three.

96
00:05:31,240 --> 00:05:39,200
Remember that so that the defense function is returning the submission of all of the values of this

97
00:05:39,200 --> 00:05:42,320
note and all of its children, the legibility of this one.

98
00:05:42,710 --> 00:05:45,890
So 320 the sum of all of the notes that are reachable from me.

99
00:05:45,980 --> 00:05:47,720
So this is now the recursive definition.

100
00:05:48,110 --> 00:05:53,840
So we start, for example, let's say the query is not zero zero zero, what occurs or not number three

101
00:05:54,560 --> 00:05:56,240
and will come back to researchers.

102
00:05:56,450 --> 00:05:58,700
Number two now think thinking recursive way.

103
00:05:59,060 --> 00:06:02,030
If this function will return and do the job, what would be the output?

104
00:06:02,330 --> 00:06:06,800
It would be 15 and 30 so added together, which is 45.

105
00:06:07,370 --> 00:06:12,800
And this function recursively what we return the return of the submission, which is 20 and 50 17:00

106
00:06:12,950 --> 00:06:14,120
170.

107
00:06:14,420 --> 00:06:20,360
So we have here an integer result, Bernard and it take my current importance and iterate on every child

108
00:06:20,360 --> 00:06:22,130
and and it's important for me.

109
00:06:22,400 --> 00:06:26,960
So this is the extra thing here for the recursive definition that we need to change it little bit.

110
00:06:27,320 --> 00:06:33,470
It is now just normal deficit, also like a normal defense that do some nice recursion result.

111
00:06:33,770 --> 00:06:36,320
I hope that this wasn't a hard thing for you.

112
00:06:36,770 --> 00:06:38,400
Overall, it's more of a resurgence.

113
00:06:38,400 --> 00:06:39,590
Scales some good things.

114
00:06:39,590 --> 00:06:39,950
Gets.

115
00:06:41,750 --> 00:06:45,320
And the third problem, uh, let's make a separate bid you.
