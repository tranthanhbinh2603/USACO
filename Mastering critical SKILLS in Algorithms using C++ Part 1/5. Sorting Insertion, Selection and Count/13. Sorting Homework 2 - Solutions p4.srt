0
1
00:00:01,290 --> 00:00:04,800
In this problem, we would like to do what they call the wiggle sort.
1

2
00:00:05,310 --> 00:00:07,290
So just any output is a good output.
2

3
00:00:07,290 --> 00:00:10,700
So let me discuss two different ways for this problem.
3

4
00:00:10,710 --> 00:00:11,100
.
4

5
00:00:11,280 --> 00:00:16,530
And this is important for you to remember that different perspectives can generate different solutions.
5

6
00:00:17,300 --> 00:00:20,460
Assume for a while that we sorted the numbers from one to eight.
6

7
00:00:20,490 --> 00:00:21,720
So these are our numbers.
7

8
00:00:21,730 --> 00:00:23,010
We don't care about the values.
8

9
00:00:23,010 --> 00:00:23,490
We just care
9

10
00:00:23,490 --> 00:00:24,170
they are ordered.
10

11
00:00:24,960 --> 00:00:30,540
Now we see that the first number here represent the smallest number in the array, which is
11

12
00:00:31,080 --> 00:00:35,850
good one because we need the first element to be less than or equal to the second element.
12

13
00:00:36,360 --> 00:00:38,970
So the smallest one definitely is satisfying this condition.
13

14
00:00:39,870 --> 00:00:41,610
Now, what is the next one?
14

15
00:00:42,330 --> 00:00:47,940
There is something I call boundary thinking, and you will notice several problems involve this
15

16
00:00:47,940 --> 00:00:53,610
kind of thinking, like when you think in terms of boundaries here, what is next after one, maybe
16

17
00:00:53,610 --> 00:00:58,020
the smallest one too, maybe the largest value too, maybe this one, maybe this one.
17

18
00:00:58,320 --> 00:00:59,490
So we can try them.
18

19
00:00:59,880 --> 00:01:01,050
Let me start with the eight.
19

20
00:01:02,650 --> 00:01:08,050
If I took the eight here, which is the largest available in all of the numbers, what is the remaining?
20

21
00:01:08,470 --> 00:01:09,970
Two, three, four, five, six, seven.
21

22
00:01:10,870 --> 00:01:13,960
Now the first number one is less than or equal
22

23
00:01:13,990 --> 00:01:20,560
eight. The eight was the largest in the whole array, so it must be greater than or equal to whatever comes
23

24
00:01:20,560 --> 00:01:22,120
here. Now,
24

25
00:01:22,720 --> 00:01:26,770
regardless of how you will solve this problem, this part must be correct.
25

26
00:01:27,550 --> 00:01:30,200
And this one here is what we call sub-problem.
26

27
00:01:30,220 --> 00:01:33,790
Remember what we mentioned in the previous video about the greedy.
27

28
00:01:34,120 --> 00:01:40,480
I took two values, and they are in the right position because one is the smallest, which is correct,
28

29
00:01:40,690 --> 00:01:45,520
and eight is the largest, so it must be greater than eight or equal it, and it's greater than all of these
29

30
00:01:45,520 --> 00:01:45,850
guys.
30

31
00:01:45,850 --> 00:01:46,750
So it must be correct.
31

32
00:01:46,960 --> 00:01:49,150
And this now is a sub-problem.
32

33
00:01:49,150 --> 00:01:52,690
This is a very clear example of what does it mean to be a sub-problem.
33

34
00:01:53,080 --> 00:01:54,900
And this means I can apply the same logic.
34

35
00:01:54,910 --> 00:01:58,300
Take the smallest, which is two, take the largest, which is seven.
35

36
00:01:59,200 --> 00:02:02,590
Now the eight must be greater than or equal two.
36

37
00:02:03,100 --> 00:02:09,040
And seven is anyway greater than the remaining, which are three, four, five, and six.
37

38
00:02:09,580 --> 00:02:14,930
Now we ended up with one way, which is pretty good. To implement this solution,
38

39
00:02:15,190 --> 00:02:18,100
you will need an extra O(n) memory to build the solution.
39

40
00:02:18,940 --> 00:02:21,510
So this is one way, and I'm happy to show you this.
40

41
00:02:21,550 --> 00:02:22,830
What do you mean by greedy?
41

42
00:02:23,080 --> 00:02:25,070
This is a problem from one to eight.
42

43
00:02:25,090 --> 00:02:27,100
This is a sub-problem of the remaining values.
43

44
00:02:27,730 --> 00:02:28,510
.
44

45
00:02:29,410 --> 00:02:34,120
Let's see another perspective to the solution.
45

46
00:02:36,240 --> 00:02:42,720
Let's go back to the one again, so we have the one, which is the smallest, which means any element
46

47
00:02:42,730 --> 00:02:45,060
in the array is OK. Let's try
47

48
00:02:45,060 --> 00:02:47,010
the two. Is two a good choice?
48

49
00:02:47,520 --> 00:02:51,480
The two is a bad choice because nothing after two is less
49

50
00:02:51,480 --> 00:02:54,180
than it, so nothing can work here.
50

51
00:02:54,360 --> 00:02:55,650
So two doesn't work.
51

52
00:02:56,190 --> 00:02:57,540
OK, what about the three?
52

53
00:02:58,590 --> 00:03:06,930
The three is a good choice because the three is greater than or equal the one, and there is a number less than
53

54
00:03:06,930 --> 00:03:09,630
or equal it, which is only one number which is here the two.
54

55
00:03:10,950 --> 00:03:15,390
Now the point here is given that one and three are done,
55

56
00:03:17,480 --> 00:03:23,360
and there is anyway a number that is less than the three which we get it here at two, then we
56

57
00:03:23,360 --> 00:03:24,830
are sure that we can build
57

58
00:03:24,980 --> 00:03:27,530
the solution too. Let me say this in a different way.
58

59
00:03:28,960 --> 00:03:31,900
I started by taking the one and three.
59

60
00:03:32,850 --> 00:03:35,460
Are they valid? Yes, because one is less than or equal three.
60

61
00:03:36,330 --> 00:03:39,940
The next one will be the next smallest value also, which is now two.
61

62
00:03:40,200 --> 00:03:44,250
And it's actually the only available value too. What is there after the two?
62

63
00:03:45,060 --> 00:03:49,500
We will not take the five because there is nothing less than five anymore.
63

64
00:03:49,540 --> 00:03:50,910
But we can take the seven.
64

65
00:03:51,210 --> 00:03:52,410
So take the seven here.
65

66
00:03:53,340 --> 00:03:54,510
Now the good about seven,
66

67
00:03:54,510 --> 00:03:56,850
It is greater than or equal two.
67

68
00:03:57,240 --> 00:04:00,300
Now, the seven has only, uh..
68

69
00:04:00,760 --> 00:04:02,620
We should take six not seven.
69

70
00:04:03,390 --> 00:04:08,160
The six has only one choice that is smaller than it, which is five, and so on.
70

71
00:04:08,370 --> 00:04:14,670
This is again problem and sub-problem, but it is less clear because it assumes you must take anyway
71

72
00:04:14,670 --> 00:04:15,630
the minimum from here.
72

73
00:04:16,080 --> 00:04:18,260
This is different from the previous solution.
73

74
00:04:18,270 --> 00:04:19,740
It's more flexible.
74

75
00:04:20,310 --> 00:04:25,830
Anyway, the good thing about that if I take the input [1, 2, 3, 4, 5, 6, 7,] the output
75

76
00:04:25,830 --> 00:04:31,710
is just 1, 3, 2, 5, 4, 7, 6, 8 which, as you see, is just you swap these
76

77
00:04:31,710 --> 00:04:33,480
two and these two and these two.
77

78
00:04:33,870 --> 00:04:37,290
So going to the solution here, we can notice that
78

79
00:04:38,890 --> 00:04:45,480
the second solution that we implemented is just starting from the one and keep iterating
79

80
00:04:45,730 --> 00:04:47,770
two values and two values.
80

81
00:04:48,340 --> 00:04:51,550
And this is the first idea that I mentioned.
81

82
00:04:51,670 --> 00:04:53,200
We need an extra memory here.
82

83
00:04:53,410 --> 00:04:54,190
We will iterate.
83

84
00:04:54,190 --> 00:04:56,470
I have an iterator in the beginning, iterator in the end.
84

85
00:04:56,770 --> 00:05:00,160
You start to take the first, you take the end.
85

86
00:05:00,160 --> 00:05:01,570
You need to carefully implement it.
86

87
00:05:01,780 --> 00:05:07,000
So it is not just an extra memory, more code, and you need to be more careful.
87

88
00:05:07,180 --> 00:05:13,240
This idea is shorter in the code, it is easier, not easier to understand,
88

89
00:05:13,630 --> 00:05:15,100
both of them are easy to understand.
89

90
00:05:15,700 --> 00:05:16,710
And what else?
90

91
00:05:16,720 --> 00:05:18,160
Yeah, and no memory.
91

92
00:05:18,220 --> 00:05:20,020
So it's a pretty good idea here.
92

93
00:05:21,490 --> 00:05:23,170
Uh, yeah.
