0
1
00:00:01,200 --> 00:00:06,300
In this problem, we would like to eliminate these monsters that are coming to the city.
1

2
00:00:06,630 --> 00:00:08,910
You would like to maximize the number of monsters.
2

3
00:00:09,330 --> 00:00:15,090
So the question that should come to your mind is which monster to kill first so that we maximize them.
3

4
00:00:16,020 --> 00:00:22,980
If you started to think about it, you will find that, logically, you would like to kill the monsters
4

5
00:00:22,980 --> 00:00:25,620
based on the order of arrival to the city.
5

6
00:00:26,100 --> 00:00:31,590
If a monster will arrive after two minutes, and another one after 10 minutes, it doesn't
6

7
00:00:31,590 --> 00:00:35,940
make sense to shoot first the one that will take 10 minutes, the one that takes two minutes
7

8
00:00:35,940 --> 00:00:37,230
will arrive faster.
8

9
00:00:37,920 --> 00:00:40,150
And this is a logical choice,
9

10
00:00:40,170 --> 00:00:41,370
a greedy choice.
10

11
00:00:42,390 --> 00:00:48,630
Now we would like to know which monster will arrive first to my city.
11

12
00:00:49,260 --> 00:00:51,600
We know this simple math equation.
12

13
00:00:51,870 --> 00:00:56,430
The time equals the distance over the speed.
13

14
00:00:56,460 --> 00:00:59,070
This is a simple rule that we learned in the physics.
14

15
00:00:59,430 --> 00:01:03,510
Please keep this equation in mind because we will use it in several problems during the course.
15

16
00:01:04,200 --> 00:01:10,260
So now this is an equation, I can simply now, for every monster, compute this value.
16

17
00:01:10,680 --> 00:01:18,550
And I will know the time, and in every single minute, I will start to kill them one by one
17

18
00:01:18,690 --> 00:01:20,760
until one of them arrives the city, that's it.
18

19
00:01:20,760 --> 00:01:22,770
So I believe this is an easy problem.
19

20
00:01:23,280 --> 00:01:26,700
Now there are different ways to implement this problem.
20

21
00:01:27,120 --> 00:01:32,880
The first one is to use double values, just divide the distance over the speed, and sort the data.
21

22
00:01:33,180 --> 00:01:34,650
Let's see an implementation for that.
22

23
00:01:36,400 --> 00:01:38,960
Uh, which one?
23

24
00:01:39,970 --> 00:01:41,530
I call it two or three.
24

25
00:01:42,190 --> 00:01:42,970
I call it two.
25

26
00:01:43,930 --> 00:01:48,360
So this one here. I have a double array.
26

27
00:01:48,750 --> 00:01:50,260
I iterate on the monsters.
27

28
00:01:50,560 --> 00:01:53,260
I divide the distance over the speed to get the time.
28

29
00:01:53,620 --> 00:01:55,290
I start to order that.
29

30
00:01:55,300 --> 00:01:57,610
So this is I'm calling here the arrival_time.
30

31
00:01:58,420 --> 00:02:04,720
Now keep iterating on the arrival time list.
31

32
00:02:05,290 --> 00:02:11,020
And as long as, the i is less than the arrival time, we can simply kill him.
32

33
00:02:11,470 --> 00:02:14,500
So keep kill them, one by one, unless one of them arrives.
33

34
00:02:15,160 --> 00:02:18,040
So, simply,
34

35
00:02:18,040 --> 00:02:23,710
let's say the arrival time of them is like maybe three, maybe five, maybe seven.
35

36
00:02:24,430 --> 00:02:31,480
So in minute number one, you will kill the three, in minute number two, you will kill the five, in minute
36

37
00:02:31,480 --> 00:02:36,130
number three, you will kill the seven. So you actually killed three of them in three minutes only.
37

38
00:02:36,610 --> 00:02:41,860
Let's say the actual input was like one, two, two, two.
38

39
00:02:42,760 --> 00:02:47,140
So in the minute zero, you will kill this one here.
39

40
00:02:47,440 --> 00:02:51,790
In minute one, you kill this one here, in minute two, a monster arrived.
40

41
00:02:51,970 --> 00:02:52,660
So you die.
41

42
00:02:52,960 --> 00:02:55,120
So you iterate on the arrival times,
42

43
00:02:55,450 --> 00:03:00,910
and just as long as the current time, you're simulating, you're killing them one by one, as long as
43

44
00:03:00,910 --> 00:03:02,930
the current time is less than his arrival time,
44

45
00:03:02,950 --> 00:03:04,990
you can just kill him.
45

46
00:03:05,560 --> 00:03:11,500
Now there is a minor problem in this problem, and it might be a problem, but I would like you to just
46

47
00:03:11,680 --> 00:03:12,490
keep it in mind.
47

48
00:03:15,040 --> 00:03:23,620
In C++, comparisons based on double values are wrong because the double values internally could
48

49
00:03:23,620 --> 00:03:31,090
be something like, the arrival could be something like that 2.9999,
49

50
00:03:31,090 --> 00:03:33,190
which is actually three.
50

51
00:03:33,760 --> 00:03:35,740
So this one, there might be a problem when
51

52
00:03:35,770 --> 00:03:40,810
it comes to sorting something like 3.12, blah blah blah, 3.12 blah blah blah,
52

53
00:03:40,810 --> 00:03:42,700
and they are different. In this problem,
53

54
00:03:43,030 --> 00:03:48,850
my impression is it will not be sensitive, but anyway in general, be careful whenever you are comparing
54

55
00:03:48,850 --> 00:03:50,470
doubles or sorting doubles.
55

56
00:03:51,100 --> 00:03:54,070
Another way which is just simpler idea.
56

57
00:03:54,430 --> 00:03:58,920
I'm going to compute an integer value for the arrival but in an integer way.
57

58
00:03:58,930 --> 00:04:00,940
Let's say the distance is eight,
58

59
00:04:01,240 --> 00:04:03,580
but the speed is two.
59

60
00:04:03,580 --> 00:04:05,330
8 % 2 is zero.
60

61
00:04:05,350 --> 00:04:06,990
So this means it's divisible.
61

62
00:04:07,000 --> 00:04:08,410
So eight over two is just four.
62

63
00:04:08,950 --> 00:04:09,490
What about eight
63

64
00:04:11,380 --> 00:04:12,910
modulus three? Not zero.
64

65
00:04:13,150 --> 00:04:19,510
So it means the answer will be two point something, but anyway we know that we kill them in integer minutes,
65

66
00:04:19,540 --> 00:04:20,920
as the problem said.
66

67
00:04:21,190 --> 00:04:23,530
So anyway, you can ceil it up from the beginning.
67

68
00:04:24,250 --> 00:04:28,510
So this is the second way here. So we can do that in a very trivial way here.
68

69
00:04:28,990 --> 00:04:30,130
We can do that here
69

70
00:04:30,580 --> 00:04:34,300
as in the equation, the arrival time now has integer values.
70

71
00:04:34,630 --> 00:04:42,310
If they are divisible, I can divide by the speed. If they aren't, I can add plus one, which is ceiling.
71

72
00:04:42,640 --> 00:04:47,230
By the way, there is a different equation to compute the ceiling, we will visit it in another problem
72

73
00:04:47,230 --> 00:04:54,010
later. I asked you for a challenge to try to implement this equation without anything that involves
73

74
00:04:54,010 --> 00:04:58,120
any kind of division or modulus. Why? Because they are slow operators.
74

75
00:04:58,240 --> 00:04:58,990
This is for fun.
75

76
00:04:58,990 --> 00:04:59,650
Nothing else.
76

77
00:05:00,610 --> 00:05:01,840
So here is what happened.
77

78
00:05:01,840 --> 00:05:08,710
First of all, I will create the arrival time to be a pair of integer and integer, which are
78

79
00:05:08,710 --> 00:05:11,850
the distance and speed. And now, we will sort the pairs.
79

80
00:05:12,760 --> 00:05:18,280
OK, so now once we sorted them, we can iterate on the arrival time, and do the computation.
80

81
00:05:18,670 --> 00:05:19,870
OK, easy so far.
81

82
00:05:20,290 --> 00:05:25,900
So let's see. Now, the arrival time needs to compare my arrival with this arrival.
82

83
00:05:26,530 --> 00:05:29,920
So this again involves computing the time.
83

84
00:05:29,920 --> 00:05:36,650
So let's say my time is a/b, and his time is c/d, like this is t1 and this is
84

85
00:05:36,670 --> 00:05:41,860
t2, and I would like to compare t1 / t2, which means I need to compute again the division.
85

86
00:05:42,250 --> 00:05:43,150
But here is the trick.
86

87
00:05:43,510 --> 00:05:48,460
Mathematically, this equation is as same as multiplying b, d in the two sides.
87

88
00:05:48,640 --> 00:05:50,580
So this one goes and this one goes.
88

89
00:05:50,590 --> 00:05:52,450
So this is d, and this is b.
89

90
00:05:52,840 --> 00:05:55,150
So now you need to compare only these ones here.
90

91
00:05:55,450 --> 00:06:01,780
So instead of making division to compare, we can actually use the math properties to switch it.
91

92
00:06:02,920 --> 00:06:06,580
And this is something that sometimes people in competitive programming need it, and something fun
92

93
00:06:06,580 --> 00:06:13,630
to know. The last thing again here we would like to do some here division
93

94
00:06:13,630 --> 00:06:15,970
to check if the current time is enough or not.
94

95
00:06:16,210 --> 00:06:20,320
Again, with some multiplication, we can just get it correctly.
95

96
00:06:20,920 --> 00:06:22,870
This is the third way, and it's just for fun,
96

97
00:06:22,870 --> 00:06:23,500
nothing else.
