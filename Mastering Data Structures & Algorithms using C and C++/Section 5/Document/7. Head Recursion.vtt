WEBVTT

00:00.360 --> 00:01.230
Now, let us see her.

00:02.280 --> 00:09.140
See, this is a structure for her recursion, if there is a function that is calling itself so, it's

00:09.150 --> 00:16.860
a recursive function that the false statement inside the function as a recursive call, it is calling

00:16.860 --> 00:17.920
itself here.

00:18.360 --> 00:18.960
Then what?

00:18.960 --> 00:24.490
All the processing it has to do with is doing it afterwards after the recursive call.

00:24.750 --> 00:29.130
So there is no statement, no operation before the function call.

00:29.400 --> 00:33.840
See if there is something here, then it is not a hard recursion.

00:34.620 --> 00:35.070
Right.

00:35.100 --> 00:38.720
If something is there before the function, call just it is a recursion.

00:38.730 --> 00:41.810
We don't have to give any special name for that one.

00:42.090 --> 00:44.490
So there is nothing before that one.

00:44.500 --> 00:48.470
Then we can see this is a header recursion.

00:48.660 --> 00:50.260
So what do you mean by Haddrick?

00:50.940 --> 00:57.060
It means the function doesn't have to process or perform any operation at the time of calling.

00:57.360 --> 01:01.440
It has to do everything only at the time of returning.

01:01.740 --> 01:04.920
So all the processing is done at returning time.

01:05.160 --> 01:09.050
Then such functions are had recursion.

01:09.360 --> 01:14.820
So the example of this type of recursion already we have seen in the previous video, this is what the

01:14.820 --> 01:15.860
simple example.

01:16.050 --> 01:21.160
So you can see that the function is first calling itself, then the second statement.

01:21.160 --> 01:21.960
It is printing.

01:22.200 --> 01:27.800
So the painting will be done at returning time so the function doesn't do anything at the calling time.

01:28.620 --> 01:30.960
So such recursion had recursion.

01:31.860 --> 01:36.210
Next, we will compare her recursion versus loop.

01:36.210 --> 01:38.150
Can we convert them into loop?

01:38.490 --> 01:39.750
Let us discuss this.

01:40.260 --> 01:49.500
I will try to write the same function using loop, so let me write here wide function file not instead

01:49.500 --> 01:50.910
of conditional statement.

01:50.910 --> 01:56.930
I have to write a loop that I will you have shown you so if any greater than zero.

01:57.480 --> 01:58.770
No here.

01:58.770 --> 02:02.330
First it has to make a recursive call, then it is printing.

02:02.610 --> 02:11.130
So if you remember the output of this one, the output of dysfunction was one, two, three as it is

02:11.130 --> 02:12.980
going to print at any time.

02:12.990 --> 02:17.880
So if you remember Don said in the previous video, what else you can check back the result of this

02:17.880 --> 02:24.990
type of function as one, two, three, because it is spending entertaining time now as it is, I have

02:24.990 --> 02:27.540
tried to write the function with the loop.

02:27.960 --> 02:31.950
Now I want the output to be one, two, three, four.

02:31.950 --> 02:46.050
If I use the printer here, print deaf person daily and then if I am passing function fun with the volume

02:46.050 --> 02:49.410
three, then foster value often will be three.

02:49.680 --> 02:50.880
So three is greater than zero.

02:50.890 --> 02:51.320
Yes.

02:51.330 --> 02:53.190
So it will print what three.

02:53.400 --> 02:57.420
It will not print one first value that will print it will be three.

02:57.420 --> 02:58.580
It is not one.

02:59.910 --> 03:06.540
Then if I have to repeat them just like this one in stock that if I write and the minus minus then that

03:06.540 --> 03:08.360
doesn't work same as that one.

03:09.120 --> 03:11.400
So you cannot easily convert that.

03:11.400 --> 03:14.730
So you have to write it in some other way to get the same output.

03:15.030 --> 03:19.610
But as it is looking at the function, if you try to convert, it's not easy.

03:20.400 --> 03:27.690
We can write some function which spends one, two, three using loop, but looking at this function

03:27.690 --> 03:29.370
we cannot directly created.

03:29.910 --> 03:32.330
So it means I have to write it in a different way.

03:32.520 --> 03:33.720
So let me write it.

03:33.840 --> 03:42.720
Suppose I have to take some variable, i.e. and that is value one then I should say I is less than equal

03:42.720 --> 03:51.810
to N then here I should say I plus plus and I should make this a plus plus after print F so let us try

03:51.810 --> 03:53.040
to run and see this one.

03:53.370 --> 03:56.730
If we pass the value as a three that is and is a three.

03:56.730 --> 03:59.130
So I use one, one is less than three.

03:59.130 --> 04:01.020
So it will print I that is one.

04:01.020 --> 04:04.350
So output is one then it becomes two.

04:04.350 --> 04:06.270
So two, two is less than three.

04:06.270 --> 04:07.410
So it will print two.

04:07.590 --> 04:11.550
So it is to the nine plus, plus I becomes a three.

04:11.550 --> 04:13.320
So three is less than equal to three.

04:13.530 --> 04:14.610
So I use three.

04:14.610 --> 04:18.090
So it will print the three then C++ I becomes four.

04:18.360 --> 04:24.120
Four is not less than equal to three, so it will not enter in and it will finish the loop and it will

04:24.120 --> 04:24.630
come out.

04:24.960 --> 04:27.360
So the output is one, two, three.

04:27.930 --> 04:33.150
So that set, you can see that that function cannot be as it is converted.

04:33.600 --> 04:41.910
So precautions or if a recursive function has to do something at return in time, it cannot be easily

04:41.910 --> 04:45.780
converted in the form of a loop, but it can be converted.

04:46.020 --> 04:47.970
It doesn't look as ities.

04:49.110 --> 04:51.120
So that's all about ID.

04:51.330 --> 04:54.960
And the next video, we will see three recursions.
