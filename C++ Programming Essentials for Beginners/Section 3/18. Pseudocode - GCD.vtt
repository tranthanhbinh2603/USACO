WEBVTT

00:01.070 --> 00:06.710
I assume now we will discuss to write the pseudocode for the D3D problem, so given the numbers like

00:06.710 --> 00:10.460
in me, we want to find out the D3D of the numbers, OK?

00:11.000 --> 00:14.970
So for example, then British 18:20, we discussed the distasteful.

00:15.620 --> 00:22.340
Another thing that we discussed in order to find that easily, we will iterate from one to the minimum

00:22.340 --> 00:28.490
of the two numbers and we because the DCD can never be greater than the smaller number.

00:28.520 --> 00:28.820
OK.

00:29.480 --> 00:34.610
What we want to do while iterating over this range, we want to find the largest number.

00:35.740 --> 00:37.690
That divides more than me.

00:38.170 --> 00:43.720
OK, so this we will implement using all the words, so first of all, we will read the numbers in B,

00:44.590 --> 00:50.140
and in order to iterate over this range, we will keep a bucket I that will store it on what value we

00:50.140 --> 00:50.890
currently are.

00:50.930 --> 00:54.370
So in the beginning, we get to this one and begin to give.

00:54.380 --> 01:02.290
While this eye is less than equal to minimum of a comma, B will do some work.

01:02.680 --> 01:02.950
OK.

01:03.430 --> 01:13.960
So what we will do will take that visibility, so we'll check if it is divisible by and B is also divisible

01:13.960 --> 01:14.820
by two.

01:14.830 --> 01:20.050
In both of these cases, after dividing with, the remainder should be zero.

01:21.190 --> 01:21.400
OK.

01:22.000 --> 01:30.040
So if if both of these conditions are true, then what we can do we can look at if two divides both

01:31.750 --> 01:38.320
20, then averages it is two, then we go to three, then we go to four and we do this thing for every

01:38.320 --> 01:38.770
location.

01:38.770 --> 01:41.380
To these Oakajee three equals two I.

01:42.160 --> 01:45.130
Otherwise, what we can do, otherwise we can see.

01:47.330 --> 01:53.140
If you, irrespective of this condition, is true or false, we will always try the next numbers will

01:53.150 --> 01:55.480
to equals two plus one.

01:55.850 --> 01:56.360
That's it.

01:56.750 --> 01:58.820
I will complete the loop.

01:59.270 --> 02:05.240
And now when we are out of the loop, we can print the value of DVD and begin to exit.

02:05.270 --> 02:05.510
OK.

02:06.440 --> 02:09.260
So this is how we'll compute digitally.

02:09.900 --> 02:14.390
And you may ask not what happens if that is.

02:15.510 --> 02:16.530
No, these you do, OK.

02:16.620 --> 02:22.940
So in the worst case, if there is no device, either one would be at least one is the one.

02:22.950 --> 02:27.360
One always divides two numbers and be OK if we ordinarily would be there to one.

02:27.370 --> 02:31.320
For example, if you have seven and eight, you want to find easily.

02:32.190 --> 02:36.410
So one divides a one two vote, seven and one divides B.

02:37.110 --> 02:38.140
This really would be one.

02:38.160 --> 02:42.120
And finally, if you print the DCT, the value of the city would be one.

02:42.960 --> 02:45.360
So I hope you have understood this algorithm.

02:45.360 --> 02:48.150
So we have exactly implemented what we discussed, OK?

02:49.130 --> 02:56.270
So given the numbers like 1822, what we are doing, we are going from equal to one two three four up

02:56.270 --> 03:02.630
to up to up to eight, and we are checking whether one divides.

03:02.630 --> 03:05.450
But yes, then one is the decision to divide us.

03:05.450 --> 03:07.040
But then do is that easily?

03:07.760 --> 03:13.490
Who does not divide it nor object to the three fold divide would then vote is the decision.

03:14.510 --> 03:17.360
And this continues on till the minimum value.

03:17.930 --> 03:22.070
So finally, this is the value of the city that you will get the largest one.

03:23.090 --> 03:26.300
So I hope you have understood this algorithm and that's all for this.

03:26.300 --> 03:26.690
We you.
