1
00:00:01,589 --> 00:00:05,190
Hi everyone, so let us look at DP based solution for this problem.

2
00:00:05,610 --> 00:00:06,580
What they need to do?

3
00:00:06,600 --> 00:00:09,840
We had two states one is set of cities and one is cities.

4
00:00:10,380 --> 00:00:13,320
Now this set of cities, we have four cities.

5
00:00:13,830 --> 00:00:17,250
There are two raise to the power N states that are possible for this one.

6
00:00:17,730 --> 00:00:18,060
OK.

7
00:00:18,360 --> 00:00:22,110
As we saw that for N equal four, we have from 

8
00:00:22,110 --> 00:00:24,420
Zero zero zero to  one one one one.

9
00:00:24,450 --> 00:00:24,750
OK.

10
00:00:25,110 --> 00:00:31,310
talking about these we have two raise to the power 4 that is 16 states starting from zero

11
00:00:31,350 --> 00:00:32,070
till 15.

12
00:00:32,910 --> 00:00:33,720
What we will need?

13
00:00:33,720 --> 00:00:40,280
We will need to create a DP array, which is of the type 2 raise to the power N into the city.

14
00:00:40,290 --> 00:00:41,280
So we have N cities.

15
00:00:42,000 --> 00:00:47,850
These are the possible states that we need to fill in the DP array and this would also form the time complexity

16
00:00:49,760 --> 00:00:51,980
For this particular problem. OK?

17
00:00:52,000 --> 00:00:59,240
So for each state, we are doing a loop of size N. maybe you can multiply it with one more N

18
00:01:00,300 --> 00:01:04,319
To get the overall time complexity, OK. this is still exponential?

19
00:01:04,800 --> 00:01:07,300
So let me... let me try to show you.

20
00:01:07,320 --> 00:01:08,540
So we will create a DP array.

21
00:01:09,060 --> 00:01:16,230
And one rai... the number of rows would be one left shift N that is 2 raise to the power N.

22
00:01:16,230 --> 00:01:25,560
each row will be initialized with a vector of integers which has N columns and each column is initialized

23
00:01:25,560 --> 00:01:26,790
with minus one in the beginning.

24
00:01:26,790 --> 00:01:33,510
Because we don't know what is the shortest distance. In Tsp we will send this DP matrix.

25
00:01:34,750 --> 00:01:38,830
and here we need to accept this DP matrix as well.

26
00:01:40,800 --> 00:01:43,920
And here we need to pass in this DP matrix as well.

27
00:01:44,460 --> 00:01:52,140
What we can do? we can check if DP of a particular set of cities and current city if this is not

28
00:01:52,140 --> 00:01:53,010
equal to minus one.

29
00:01:53,010 --> 00:01:59,490
That means the state is already computed so we can return DP of set of cities and city.

30
00:02:00,450 --> 00:02:02,250
And if it is already visited.

31
00:02:04,270 --> 00:02:09,789
oh, so if it is already visited then we return it, if it is not visited, then we will first compute

32
00:02:09,789 --> 00:02:11,290
the answer like we did.

33
00:02:12,460 --> 00:02:15,580
And we will memorize this answer in this particular DP array.

34
00:02:15,790 --> 00:02:16,840
and we will return the ans.

35
00:02:18,090 --> 00:02:20,130
So I think that's it.

36
00:02:20,490 --> 00:02:22,770
That's what all we need to do.

37
00:02:22,800 --> 00:02:29,990
So have applied top down dynamic programming here and let build our code and let us try to run

38
00:02:30,000 --> 00:02:30,210
it.

39
00:02:31,420 --> 00:02:33,100
We're still getting the answer 85.

40
00:02:33,130 --> 00:02:37,000
That means our DP based code is also working fine.

41
00:02:37,660 --> 00:02:38,220
That's all.

42
00:02:38,230 --> 00:02:40,450
I hope you understood this problem now.

43
00:02:40,660 --> 00:02:41,890
Thanks a lot for watching.

