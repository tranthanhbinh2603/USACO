1
00:00:01,130 --> 00:00:03,560
So we have already seen the algorithm to do addition

2
00:00:04,310 --> 00:00:09,110
and now what we are going to do? we are going to build that algorithm in the code.

3
00:00:09,650 --> 00:00:12,590
So let's see how we can go about the algorithm.

4
00:00:13,220 --> 00:00:20,240
So first of all, what we will do? we will take input two numbers and then we will write algorithm. OK?

5
00:00:20,510 --> 00:00:24,970
So since they are big integers, we cannot take them input as

6
00:00:24,980 --> 00:00:28,320
a integer, we can take input them as a string.

7
00:00:28,340 --> 00:00:28,640
OK.

8
00:00:29,060 --> 00:00:29,530
So i can say 

9
00:00:29,580 --> 00:00:36,980
I have a string S1 and strings S2. then I can read those strings cin S1 and S2.

10
00:00:37,160 --> 00:00:37,670
All right.

11
00:00:38,360 --> 00:00:42,040
And maybe I want to output my result inside a string array.

12
00:00:42,740 --> 00:00:44,870
Or I can say there is a method 

13
00:00:44,870 --> 00:00:46,910
Add numbers. S1 and S2.

14
00:00:47,000 --> 00:00:48,980
So this method is going to return a string.

15
00:00:49,760 --> 00:00:51,590
So let's create this method.

16
00:00:52,250 --> 00:00:55,190
So I need to create string add numbers.

17
00:00:55,370 --> 00:01:00,170
I get string N1 number one and string number two.

18
00:01:00,350 --> 00:01:02,000
That's what we have.

19
00:01:02,570 --> 00:01:10,280
And we can compare these two numbers to make sure that N2 is larger.  N2 has more number of digits.

20
00:01:10,300 --> 00:01:11,420
we will keep it at bottom.

21
00:01:11,420 --> 00:01:14,090
So if N1 dot length is

22
00:01:15,160 --> 00:01:18,460
greater than n2 dot length.

23
00:01:19,270 --> 00:01:24,790
We can say  ok. let us just swap these two objects N1 and N2. and that's what we do.

24
00:01:26,290 --> 00:01:28,300
And here we will form the result.

25
00:01:28,450 --> 00:01:34,090
So result is there is a empty string in the beginning and every time we are doing addition. for example,

26
00:01:34,090 --> 00:01:38,230
we have let's say, 56 and three zero four five.

27
00:01:38,800 --> 00:01:41,110
What we will do? we will say five plus three is eight.

28
00:01:41,620 --> 00:01:41,920
OK.

29
00:01:42,610 --> 00:01:46,210
And in this case, the digit is eight. we will put here.

30
00:01:47,140 --> 00:01:51,960
So we will what we will do? we will push this inside the result array. we will push this inside the result array.ok.

31
00:01:53,500 --> 00:01:56,210
And this number should be actually 65.

32
00:01:56,230 --> 00:01:56,530
OK.

33
00:01:57,090 --> 00:01:59,740
If the number is 65, we will first reverse it.

34
00:02:00,400 --> 00:02:00,730
OK.

35
00:02:01,090 --> 00:02:03,540
And the another number is four

36
00:02:03,550 --> 00:02:04,060
Five zero three.

37
00:02:05,040 --> 00:02:09,990
OK. these are the two numbers and after everything I've written in the left to right order.

38
00:02:09,990 --> 00:02:17,770
OK. so that I can do additions from the left. OK. we can do additions from left to right so that

39
00:02:17,790 --> 00:02:23,160
any carry that is generated can be easily appended on the right of the particular string.

40
00:02:23,220 --> 00:02:25,950
OK. so this is how we are going to build it.

41
00:02:26,970 --> 00:02:28,800
So what we can do is, we can

42
00:02:29,490 --> 00:02:31,710
Since we have assumed that

43
00:02:32,860 --> 00:02:34,610
our N1 is smaller.

44
00:02:34,640 --> 00:02:40,420
Okay, so first thing is we need to reverse the numbers as well. so I can say, I can use the inbuilt

45
00:02:40,420 --> 00:02:48,730
reverse function and N1 dot begin to N1 dot end. So this is going to reverse my entire number.

46
00:02:49,130 --> 00:02:49,430
OK.

47
00:02:50,640 --> 00:02:56,250
So it's a function that is available in the algorithm header file. N2 dot end.

48
00:02:57,590 --> 00:02:58,100
All right.

49
00:02:58,620 --> 00:03:08,060
And now what we can do is, we can add digits. OK. up to N1.length because N1 is a smaller

50
00:03:08,060 --> 00:03:10,460
number. OK. so that means we will iterate

51
00:03:11,770 --> 00:03:18,250
only till this particular part and we will say OK, what is the output after adding these two and

52
00:03:18,250 --> 00:03:23,310
whatever it is carry is generated, we will start adding it to another number that is N2.

53
00:03:23,500 --> 00:03:25,330
Ok. so this is N1. this is N2.

54
00:03:26,170 --> 00:03:34,660
So I can say int I equal to zero, I less then N1.lenght because it is the smaller number. I++. 

55
00:03:34,690 --> 00:03:34,950
.

56
00:03:35,680 --> 00:03:37,870
So we know what is the digit.

57
00:03:38,020 --> 00:03:41,380
So this digit, we need to extract.

58
00:03:41,460 --> 00:03:45,460
So it's a character. Ok. it's a character. so I an say int digit one.

59
00:03:45,670 --> 00:03:48,820
So maybe I can make a function character to digit.

60
00:03:49,060 --> 00:03:56,920
So I want to convert this character into digit and I given, I can give N1 of I. int digit2 I can say char to digit

61
00:03:56,920 --> 00:04:00,580
of N2 of I.

62
00:04:01,110 --> 00:04:04,150
I get the second digit from here.

63
00:04:05,110 --> 00:04:06,130
I want an integer.

64
00:04:06,130 --> 00:04:11,770
OK, so this char to digit we need to define, how do we convert char into digit.

65
00:04:11,780 --> 00:04:12,670
It's pretty easy.

66
00:04:13,600 --> 00:04:20,410
So let's make a method that accepts the character and it returns the integer value of that. OK?

67
00:04:20,769 --> 00:04:26,740
So for example, if you have a character like five. if you subtract zero as a character. OK. maybe

68
00:04:26,740 --> 00:04:28,390
it has ASCII below 45.

69
00:04:28,780 --> 00:04:30,310
It has ASCII 40.

70
00:04:30,610 --> 00:04:34,230
If you do the subtraction, it is going to give you five as a integer. OK?

71
00:04:34,750 --> 00:04:37,900
so I can say return ch minus zero.

72
00:04:39,010 --> 00:04:41,750
So you subtract something

73
00:04:44,800 --> 00:04:49,240
You subtract actually... actually zero to get the corresponding integer value. OK?

74
00:04:49,810 --> 00:04:56,950
Similarly, if you want to do the other thing, if you want to convert a digit to a char. for example,

75
00:04:56,950 --> 00:05:04,870
if you give int digit equal to five and if you add a zero as a character here and you you typecast this

76
00:05:06,130 --> 00:05:07,600
into a character then

77
00:05:08,840 --> 00:05:16,400
It is going to get converted into a character. so maybe you can say return digit plus zero.

78
00:05:18,470 --> 00:05:21,650
So let me let me tell you, if you're not clear how this works.

79
00:05:22,100 --> 00:05:26,250
Zero has certain ASCII value. OK. maybe let's say this ASCII value is 40.

80
00:05:26,270 --> 00:05:29,180
I don't remember the exact number but let us assume it is 40.

81
00:05:29,680 --> 00:05:33,680
So if you add a five to it, it becomes 40 plus five.

82
00:05:33,860 --> 00:05:34,940
That is 45.

83
00:05:35,540 --> 00:05:42,570
And since we are typecasting this into a character, it would be interpreted as this particular five.

84
00:05:42,590 --> 00:05:48,100
because all these characters, they have ASCII values in a particular series. OK?

85
00:05:49,190 --> 00:05:50,980
So if it is 40, then it is 41.

86
00:05:51,040 --> 00:05:51,950
It is 42.

87
00:05:52,160 --> 00:05:52,670
It is 43.

88
00:05:52,820 --> 00:05:53,360
It is 44.

89
00:05:53,840 --> 00:05:54,140
and so on. ok.

90
00:05:55,220 --> 00:05:56,600
So something like this.

91
00:05:58,130 --> 00:06:00,560
So I hope you are getting this conversion.

92
00:06:00,800 --> 00:06:04,350
OK. so now we have, we know what is the first digit from the first number.

93
00:06:04,370 --> 00:06:06,050
What is a digit from the second number.

94
00:06:06,080 --> 00:06:08,840
What we need is? we need to find out the sum.

95
00:06:09,410 --> 00:06:10,220
So for sum

96
00:06:10,400 --> 00:06:12,470
we should also know what is the carry.

97
00:06:12,500 --> 00:06:14,630
So in the beginning, the carry is zero.

98
00:06:15,020 --> 00:06:15,350
OK.

99
00:06:15,950 --> 00:06:22,280
So I can say the sum is nothing but D1 plus D2 plus carry.

100
00:06:22,610 --> 00:06:22,940
OK.

101
00:06:23,540 --> 00:06:25,040
And in the output

102
00:06:25,520 --> 00:06:31,910
OK, in the output, so output digit that we want to store is nothing but sum modules 10.

103
00:06:31,910 --> 00:06:36,800
and the carry would be nothing but sum divided by 10.

104
00:06:37,940 --> 00:06:39,830
sum divided by 10.

105
00:06:40,730 --> 00:06:44,400
And now we have to store the output inside the result string.

106
00:06:44,420 --> 00:06:50,870
So the result is a string. so we can use the push back method to push something in the result. OK.

107
00:06:50,930 --> 00:06:54,680
So to push a character inside our result. 

108
00:06:54,830 --> 00:06:59,910
For example, if it is let's say 56 and let's say three zero five.

109
00:07:00,680 --> 00:07:02,540
So five plus three is eight.

110
00:07:02,660 --> 00:07:05,870
So by default the carry is zero.

111
00:07:06,350 --> 00:07:06,650
OK.

112
00:07:07,520 --> 00:07:10,490
So we are converting this five and eight into integer.

113
00:07:10,970 --> 00:07:11,840
This is five.

114
00:07:11,870 --> 00:07:12,680
This is three.

115
00:07:13,130 --> 00:07:15,980
This carry is five plus three plus zero.

116
00:07:16,610 --> 00:07:17,360
This is eight.

117
00:07:18,090 --> 00:07:19,130
So your result...

118
00:07:20,240 --> 00:07:22,520
Your carry is going to be sum divided by 10.

119
00:07:22,520 --> 00:07:25,580
So carry is going to be zero and result dot push back.

120
00:07:25,610 --> 00:07:27,950
So what should come here, it should be 8. OK.

121
00:07:28,490 --> 00:07:30,470
So I can say I will use this method.

122
00:07:30,920 --> 00:07:34,310
I have a digit eight. I want to convert into character.

123
00:07:35,000 --> 00:07:38,060
And this is nothing but output digit.

124
00:07:38,090 --> 00:07:39,020
So output digit is 8.

125
00:07:39,020 --> 00:07:39,710
ok.

126
00:07:40,340 --> 00:07:42,290
In the next iteration, we will go here.

127
00:07:42,770 --> 00:07:43,760
The carry is zero.

128
00:07:43,760 --> 00:07:45,350
It becomes six plus zero.

129
00:07:46,130 --> 00:07:50,780
So we will push what? we will push six here and we are done. OK.

130
00:07:51,080 --> 00:07:56,840
So we'll stop at this particular point because we have reached the length of the smaller string.

131
00:07:56,850 --> 00:08:05,000
Now we have this left. OK. maybe some more digits which are left here. So whatever carry has been generated

132
00:08:05,000 --> 00:08:06,670
will be added to this number.

133
00:08:06,680 --> 00:08:06,950
OK?

134
00:08:07,570 --> 00:08:11,510
What I can say is, I'll put another loop.

135
00:08:11,690 --> 00:08:19,130
I'll put another loop for this part. for int I equal to starting from this particular point.

136
00:08:20,340 --> 00:08:21,540
N1 dot lenght.

137
00:08:21,810 --> 00:08:22,170
OK.

138
00:08:23,740 --> 00:08:26,410
I less than N2.lenght.

139
00:08:26,650 --> 00:08:27,010
OK.

140
00:08:28,700 --> 00:08:29,600
I + +.

141
00:08:29,750 --> 00:08:37,190
So what I will do? I say OK, my sum is nothing but I need the digit D2. OK so my digit

142
00:08:37,190 --> 00:08:42,440
D2 is nothing but char to digit of N2 of I.

143
00:08:44,200 --> 00:08:52,980
So The sum is nothing but D2 plus carry and similar thing will come here, so I can say output digit

144
00:08:53,010 --> 00:08:54,240
would be nothing but

145
00:08:55,940 --> 00:09:02,000
sum divided, sum modules 10 and my carry would be nothing but sum divided by 10.

146
00:09:02,240 --> 00:09:02,540
OK.

147
00:09:04,620 --> 00:09:08,010
And in my result, I can push back.

148
00:09:09,420 --> 00:09:15,540
What? I can push back Digit to char of output digit. OK.

149
00:09:16,470 --> 00:09:18,030
This is what we do.

150
00:09:18,490 --> 00:09:19,770
So we have done a similar thing.

151
00:09:19,770 --> 00:09:23,690
Instead of adding to numbers, we have just worked on the second number.

152
00:09:23,700 --> 00:09:28,980
And if there is a carry which is coming from behind, we have handled that as well.

153
00:09:29,230 --> 00:09:29,430
ok.

154
00:09:31,350 --> 00:09:35,620
So this will serve the purpose for the second part.

155
00:09:35,650 --> 00:09:38,250
OK, one last thing is left.

156
00:09:38,430 --> 00:09:44,010
OK, so finally, if a carry is generated. OK. Carry is generated.

157
00:09:44,370 --> 00:09:48,660
For example, if I give you this example of 938

158
00:09:49,900 --> 00:09:54,670
Or maybe 988 or let's say 938 plus 65.

159
00:09:54,790 --> 00:10:03,090
OK. how we are going to handle it. we are going to reverse it 839 followed by 65. 65 is like five

160
00:10:03,100 --> 00:10:03,460
six.

161
00:10:04,180 --> 00:10:10,600
We are going to add it. 8 and 5 is 13. one carry. six and three is nine and one 10. one carry.

162
00:10:10,990 --> 00:10:13,300
Now this is done using this loop.

163
00:10:13,570 --> 00:10:13,930
OK.

164
00:10:14,800 --> 00:10:15,820
Nine plus one.

165
00:10:15,940 --> 00:10:19,930
OK, we are iterating from N1.length. from here till here.

166
00:10:20,470 --> 00:10:25,330
Nine plus one is what? ten. So this is done using the second for loop.

167
00:10:25,330 --> 00:10:29,190
and now again, finally what we have? we will have carry

168
00:10:29,650 --> 00:10:30,910
OK. nine plus one is 10.

169
00:10:32,080 --> 00:10:41,080
And if there is a carry, we will append a one here. finally if the carry is left, I can say result

170
00:10:41,920 --> 00:10:42,700
dot push back.

171
00:10:43,270 --> 00:10:47,350
What? one. or one like a character.

172
00:10:48,810 --> 00:10:54,900
Now you may ask why, why we are hard coding one because the largest value of the carry can be only

173
00:10:54,900 --> 00:10:56,240
one in this particular case.

174
00:10:56,250 --> 00:11:03,540
OK. so the maximum digits that you might be adding is nine plus nine plus one that end up to 19.

175
00:11:03,960 --> 00:11:07,740
That means the carrier would be either zero or it would be one.

176
00:11:07,840 --> 00:11:09,990
so if it is not zero then it must be one.

177
00:11:10,640 --> 00:11:12,510
Or either you can write it like this.

178
00:11:12,750 --> 00:11:15,690
or you can say OK. digit to char.

179
00:11:16,650 --> 00:11:19,140
So this will work perfectly fine. OK?

180
00:11:20,010 --> 00:11:24,420
And finally, what we can do is, we can reverse the final result.

181
00:11:26,170 --> 00:11:32,920
so I can say reverse result.begin() to result.end().

182
00:11:34,640 --> 00:11:36,440
and I can return result.

183
00:11:37,980 --> 00:11:40,830
So now let us test our code.

184
00:11:41,640 --> 00:11:41,970
OK.

185
00:11:44,270 --> 00:11:44,890
And

186
00:11:46,730 --> 00:11:47,450
Let's go here

187
00:11:48,890 --> 00:11:51,740
and I can say dot slash big addition.

188
00:11:52,790 --> 00:11:55,070
Oh, OK. I need to build the code first.

189
00:11:55,880 --> 00:11:57,770
And I need to run it.

190
00:11:58,970 --> 00:12:03,040
So maybe I give one zero or maybe let us try with small numbers.

191
00:12:04,380 --> 00:12:07,290
938 and 65.

192
00:12:08,370 --> 00:12:12,120
ok. we get one zero zero three. which is fine if I get a lot of

193
00:12:13,980 --> 00:12:14,940
big number. ok.

194
00:12:18,830 --> 00:12:19,940
OK, it's working fine.

195
00:12:20,440 --> 00:12:23,540
so one thing we can do is, we can

196
00:12:25,350 --> 00:12:27,570
do with integers also and see the difference

197
00:12:27,990 --> 00:12:35,790
what happens if you add big number into a integer. OK. I'm going to give the same numbers as integer

198
00:12:35,790 --> 00:12:36,150
also.

199
00:12:37,840 --> 00:12:39,370
Let's say we have

200
00:12:40,710 --> 00:12:41,910
One one one one one.

201
00:12:43,200 --> 00:12:44,650
And may be two two two two two.

202
00:12:44,670 --> 00:12:45,000
OK.

203
00:12:47,120 --> 00:12:49,190
And maybe we can copy the same

204
00:12:53,900 --> 00:12:54,500
here as well.

205
00:12:55,340 --> 00:12:58,700
Now you can see this is the integer.

206
00:12:59,030 --> 00:12:59,630
This is

207
00:13:02,770 --> 00:13:06,130
handle using string and this is handle using integer. OK.

208
00:13:06,160 --> 00:13:09,010
You're storing them as integer and you're adding them.

209
00:13:09,010 --> 00:13:15,010
So what you're getting is, you're getting a very small number because this number was not able to fit

210
00:13:15,790 --> 00:13:22,250
inside a integer box and hence there was an overflow which made the number as negative.

211
00:13:22,330 --> 00:13:28,270
Ok. so that's why this will give you a wrong answer and this addition will give you the correct answer.

212
00:13:28,330 --> 00:13:28,660
OK.

213
00:13:29,080 --> 00:13:35,380
So I hope you really understood how to perform addition on big integers.

214
00:13:35,920 --> 00:13:42,750
And this is the algorithm that we have written and it's pretty much simple. although it's a bit 

215
00:13:42,760 --> 00:13:46,600
a lot of code but I hope you really understood the algorithm.

216
00:13:46,690 --> 00:13:49,110
OK, so that's all for this lecture.

