1
00:00:01,460 --> 00:00:09,240
Hi, everyone, in this section, we're going to talk about data structures, a quick recap and C++ STL,

2
00:00:09,840 --> 00:00:10,770
the C++.

3
00:00:10,800 --> 00:00:13,790
C++ STL stands for the standard template library.

4
00:00:13,800 --> 00:00:19,130
It is a library that provides us common algorithms like searching and sorting.

5
00:00:19,370 --> 00:00:24,260
So there are functions that are there in the algorithm header file.

6
00:00:24,590 --> 00:00:31,610
It provides us with data structures like the containers for stack, queue, array, vectors, unordered maps and so on.

7
00:00:31,610 --> 00:00:31,880
map.

8
00:00:31,890 --> 00:00:38,150
So on and all the containers I have built using templated classes.

9
00:00:38,150 --> 00:00:44,530
OK, so that means you can fit any datatype into that container.

10
00:00:44,720 --> 00:00:47,870
So that's more like a generic container, OK?

11
00:00:48,230 --> 00:00:51,230
You can create an object for any particular type as well.

12
00:00:51,890 --> 00:00:56,200
This framework is same as similar to the collection framework in Java.

13
00:00:56,210 --> 00:01:01,520
If you're coming from java background, you might have heard about the collections framework.

14
00:01:01,970 --> 00:01:08,120
The same similar kind of a thing in C++ is known as the standard template library or STL in short

15
00:01:08,630 --> 00:01:12,770
So we are going to give you a quick recap of what is a container.

16
00:01:13,640 --> 00:01:18,110
So a container is an object that stores a collection of other objects.

17
00:01:18,140 --> 00:01:25,530
OK, so these objects are also elements, these objects could be as simple as integers

18
00:01:25,530 --> 00:01:31,190
Lets say an array of integers, we can say that the integers are stored in an array containers

19
00:01:31,760 --> 00:01:34,040
Or maybe I might have a class that.

20
00:01:34,160 --> 00:01:35,960
I might have some kind object.

21
00:01:37,740 --> 00:01:42,060
And I'm storing lots of cat objects inside a container.

22
00:01:42,090 --> 00:01:51,420
OK, so I can say, an array of cats, that is also fine,  so the object can be as simple as the integer, 

23
00:01:51,420 --> 00:01:57,450
or it could be something complex like a cat, which may have certain attributes like color, height, size, ok, weight

24
00:01:57,870 --> 00:02:07,830
OK,maybe some method as well containers can store objects as well, so

25
00:02:07,830 --> 00:02:14,000
container manages the storage space for its elements and provides member functions to access them.

26
00:02:14,010 --> 00:02:15,030
So mostly through iterators.

27
00:02:15,590 --> 00:02:19,260
So iterators is again a very important concept.

28
00:02:19,950 --> 00:02:24,450
Now if you have this array you can simply iterate it, using a variable,

29
00:02:24,560 --> 00:02:25,380
lets say starting

30
00:02:25,830 --> 00:02:27,360
I is at zero, I is at 1

31
00:02:27,960 --> 00:02:31,470
But suppose if your container is complex, OK, maybe you.

32
00:02:31,560 --> 00:02:36,030
Your container is implemented using a tree like data structure.

33
00:02:36,480 --> 00:02:39,960
In that case, you cannot say I can Iterate simply using an index.

34
00:02:40,230 --> 00:02:47,700
So what you will need is you will need an iterator, ok, to iterate over the different nodes of this

35
00:02:47,700 --> 00:02:48,640
particular tree.

36
00:02:48,810 --> 00:02:54,870
If you have a hash map, if you have a container, which is implemented using a linked list.

37
00:02:56,190 --> 00:03:05,340
Then also, you will need a iterator to iterator over the different nodes in that particular linked list because

38
00:03:05,580 --> 00:03:08,190
iterators will allow you to.

39
00:03:08,730 --> 00:03:13,920
iterate over the different nodes that are there inside the container, OK?

40
00:03:14,280 --> 00:03:15,570
So they're also objects.

41
00:03:15,780 --> 00:03:19,800
They're also objects, which which became like pointers.

42
00:03:19,810 --> 00:03:23,420
OK, so they know how to move forward, OK?

43
00:03:23,460 --> 00:03:27,190
And they're defined for each of the containers that we have.

44
00:03:27,210 --> 00:03:31,380
OK, so an example of a container is a stack or a map or a vector & so on.

45
00:03:33,080 --> 00:03:38,780
So the containers in STL are divided into four broad categories.

46
00:03:39,530 --> 00:03:48,110
The first set of category is known as the sequence containers in which the data is stored linearly in

47
00:03:48,110 --> 00:03:55,780
a sequence like array is a sequence container you store all the elements linearly inside array

48
00:03:55,820 --> 00:03:58,900
vector is like a dynamic array that can grow in size.

49
00:03:58,970 --> 00:04:03,900
But again, the data is stored linearly inside vector as well.

50
00:04:04,010 --> 00:04:08,330
OK, so Array has fixed size, but the vector can grow.

51
00:04:08,600 --> 00:04:08,900
OK.

52
00:04:09,530 --> 00:04:12,950
That is something which is known as Deque, which is known as the doubly ended queue.

53
00:04:14,180 --> 00:04:15,860
It is also a linear container.

54
00:04:16,550 --> 00:04:24,440
And the thing with this container is it can expand both from the front and both from the back.

55
00:04:24,920 --> 00:04:29,270
And it can also contract both from the front and both from the back.

56
00:04:29,280 --> 00:04:31,340
So it is known as doubly ended queue.

57
00:04:31,580 --> 00:04:38,690
So you can see you can do the operations like insertion deletion at both ends of the queue.

58
00:04:39,020 --> 00:04:44,060
And what are the most common operations that you would be doing in all of the containers?

59
00:04:44,180 --> 00:04:51,980
So one is you are adding some data so that is known as insertion or adding, then you might be doing

60
00:04:51,980 --> 00:04:54,050
searching looking for data.

61
00:04:54,110 --> 00:04:55,510
Where does this data have stored?

62
00:04:55,520 --> 00:04:56,630
Is it present or not?

63
00:04:57,080 --> 00:05:01,120
And third is removing that is also known as deletion.

64
00:05:01,820 --> 00:05:08,750
All of these containers will provide these operations in different time complexities that you should

65
00:05:08,750 --> 00:05:09,170
be knowing.

66
00:05:09,260 --> 00:05:09,560
OK.

67
00:05:10,040 --> 00:05:15,380
and there is something which is known as forward list, so forward list is nothing but a singly linked list.

68
00:05:15,620 --> 00:05:15,950
OK.

69
00:05:16,370 --> 00:05:20,710
Again, the data is stored linearly, but the memory is not continuous.

70
00:05:20,720 --> 00:05:23,300
OK, and then there is something which is known as list.

71
00:05:23,450 --> 00:05:25,940
So list nothing but it is a doubling linked list.

72
00:05:26,630 --> 00:05:27,560
You can expand.

73
00:05:28,610 --> 00:05:33,020
Both at the front and both at the back. In forward list and list.

74
00:05:33,170 --> 00:05:39,980
The memory allocation is not continuous, but in array and vector, it is continuous and Deque has a slightly

75
00:05:39,980 --> 00:05:42,230
different implementation.

76
00:05:42,650 --> 00:05:49,370
It's a complex implementation, so it combines various linear chunks of memory and it can take them

77
00:05:49,370 --> 00:05:49,630
OK.

78
00:05:50,030 --> 00:05:52,640
So it has a little complex implementation.

79
00:05:53,740 --> 00:05:56,680
Then there is associative containers.

80
00:05:57,160 --> 00:05:59,140
This is the second type of containers.

81
00:05:59,560 --> 00:05:59,890
OK.

82
00:06:00,580 --> 00:06:07,090
So in the associative containers, what you have is you have something that is known as a set.

83
00:06:08,110 --> 00:06:08,860
So what is a set?

84
00:06:08,890 --> 00:06:09,970
Let us talk about set.

85
00:06:11,490 --> 00:06:17,130
So set, basically stores the collection of elements let;s say, you have one two three four five.

86
00:06:18,410 --> 00:06:25,940
And let's say you have multiple force, the set is going to store only the unique element that means it is

87
00:06:25,940 --> 00:06:27,920
not going to store the duplicates.

88
00:06:28,310 --> 00:06:28,640
OK.

89
00:06:29,540 --> 00:06:35,060
But if you stored if you store them using something known as multiset, it is going to store the duplicates

90
00:06:35,060 --> 00:06:35,430
as well.

91
00:06:35,450 --> 00:06:43,490
OK, so the multiset can have duplicate values secondly the set is going to store the values in ordered 

92
00:06:43,490 --> 00:06:43,860
fashion.

93
00:06:43,910 --> 00:06:44,150
OK.

94
00:06:44,420 --> 00:06:45,650
The values will be ordered.

95
00:06:46,370 --> 00:06:48,260
That means they will be sorted.

96
00:06:48,650 --> 00:06:48,950
OK.

97
00:06:49,450 --> 00:06:51,860
And how is this set made?

98
00:06:51,950 --> 00:06:58,490
So internally, it might be using a tree like structure, a balance tree like structure to implement as it?

99
00:07:01,020 --> 00:07:03,780
So next thing we want to talk about is a map.

100
00:07:03,930 --> 00:07:04,770
So what is a map?

101
00:07:05,370 --> 00:07:11,430
The map is a container that is used to store a collection of key value pairs looking, for example,

102
00:07:11,850 --> 00:07:13,680
you are in a restaurant and you.

103
00:07:13,710 --> 00:07:16,140
You have to order certain items lets say.

104
00:07:16,140 --> 00:07:19,890
You want to order a pizza that costs Rs 500.

105
00:07:19,960 --> 00:07:20,280
OK.

106
00:07:20,880 --> 00:07:24,980
And maybe you want to order a drink that costs Rs100

107
00:07:25,590 --> 00:07:30,720
Maybe you want to order something like noodles that costs rupees 200.

108
00:07:30,720 --> 00:07:30,990
OK?

109
00:07:31,600 --> 00:07:36,480
What we can see is we have something which is known as key, something which is known as a value.

110
00:07:36,990 --> 00:07:40,680
So basically that inserting these pairs inside the container.

111
00:07:41,490 --> 00:07:46,500
And what this map will do, this will keep data.

112
00:07:47,190 --> 00:07:51,240
Sorted by key, ok so the data will be sorted by keys.

113
00:07:51,660 --> 00:07:56,250
And again, it uses a balanced BST(Binary Search Tree) like data structure

114
00:07:57,300 --> 00:08:00,480
to store this data so that it might be stored like this.

115
00:08:00,510 --> 00:08:01,350
You might have.

116
00:08:06,100 --> 00:08:06,420
OK.

117
00:08:06,910 --> 00:08:10,990
And then you might have noodles, you might have pizza, something like that, OK?

118
00:08:11,710 --> 00:08:16,810
So it is going to use a tree like structure to store the items, OK?

119
00:08:17,290 --> 00:08:21,340
So and that will give us sorted, for example, a b and c.

120
00:08:22,120 --> 00:08:23,230
You can see this is a.

121
00:08:24,760 --> 00:08:29,840
Balanced BST, OK, because the items are sorted by there key.

122
00:08:30,420 --> 00:08:35,400
And if you do inorder reversal of the tree, you will get a list of all items.

123
00:08:36,210 --> 00:08:37,289
Sorted by the key.

124
00:08:37,770 --> 00:08:41,820
And you can even perform searching by going through this data structure.

125
00:08:42,270 --> 00:08:45,660
So multiset, we have already discussed it as kind of a set.

126
00:08:46,260 --> 00:08:52,590
It can contain duplicate keys and multimap is like a map which can contain duplicate keys OK.

127
00:08:52,950 --> 00:08:56,820
So one key can have multiple values.

128
00:08:56,820 --> 00:09:02,310
OK, mango can be mapped with 10 and Mango can also be mapped with 15.

129
00:09:02,730 --> 00:09:04,520
But this might.

130
00:09:04,530 --> 00:09:06,060
This is not possible with map.

131
00:09:06,150 --> 00:09:08,270
This is possible with multimap.

132
00:09:10,010 --> 00:09:18,590
So the thing to remember about associative containers is they use tree like structures to store the information

133
00:09:19,250 --> 00:09:21,000
and the data is ordered.

134
00:09:21,140 --> 00:09:22,680
The data is sorted.

135
00:09:23,630 --> 00:09:30,230
And if you don't want to store sorted data, you want to store data in any random fashion.

136
00:09:30,230 --> 00:09:35,400
OK, so we can use the unordered associative containers.

137
00:09:35,420 --> 00:09:37,280
OK, so we have an unordered  set.

138
00:09:37,910 --> 00:09:43,970
So maybe we want to store a set of numbers one three, four eight and may be 2.

139
00:09:45,240 --> 00:09:49,860
So they must be stored in a random order inside this data structure.

140
00:09:50,640 --> 00:09:54,450
And now you want to look up this number two is present or not.

141
00:09:54,670 --> 00:09:57,540
OK, then this unordered set is very fast.

142
00:09:57,540 --> 00:10:00,720
It will give you the results in almost order one time (O(1)), OK?

143
00:10:01,320 --> 00:10:03,980
Similarly, we have something which is known as unordered.

144
00:10:03,990 --> 00:10:04,200
Map.

145
00:10:04,620 --> 00:10:05,790
It is like the hash table.

146
00:10:06,270 --> 00:10:07,530
OK, it's like the hashtable.

147
00:10:09,130 --> 00:10:14,330
And in hashtable again, you can do insertion, you can do look up.

148
00:10:14,990 --> 00:10:16,470
OK, that is basically search.

149
00:10:16,950 --> 00:10:18,060
And you can do deletion.

150
00:10:19,110 --> 00:10:24,250
So all of these operations are done in order one time on average.

151
00:10:24,270 --> 00:10:24,540
OK.

152
00:10:24,690 --> 00:10:27,600
The Average Time Complexity, is  O(1), and that means it is very fast.

153
00:10:28,140 --> 00:10:31,950
But it is going to tell you what is my mapped with the given key?

154
00:10:32,130 --> 00:10:32,640
OK, so.

155
00:10:33,950 --> 00:10:39,740
Anytime when you see, OK, map or unordered map, the data stored in the form of key value pairs, for

156
00:10:39,740 --> 00:10:43,630
example, again, Pizza has a value 500.

157
00:10:44,180 --> 00:10:50,360
If you look, look for what is the price of pizza and a list of items that you have inserted inside

158
00:10:50,360 --> 00:10:50,720
this table.

159
00:10:50,720 --> 00:10:59,060
But it is going to tell you in almost order one time that these pizza costs 500 and almost

160
00:10:59,060 --> 00:10:59,500
overnight.

161
00:10:59,570 --> 00:10:59,860
OK?

162
00:11:00,200 --> 00:11:07,340
And maybe you want to insert noodles in the hash map, so it is going to take almost order one time,

163
00:11:07,340 --> 00:11:07,600
OK?

164
00:11:08,070 --> 00:11:10,790
Then there is unordered multiset, which again.

165
00:11:13,460 --> 00:11:21,620
It is like an unordered set, but it can contain multiple keys of the same type , so there can be repeating

166
00:11:21,620 --> 00:11:23,610
numbers in this state as well.

167
00:11:23,630 --> 00:11:23,960
OK.

168
00:11:24,440 --> 00:11:28,040
So it is going to store all of them and there is unoredered multimap.

169
00:11:28,190 --> 00:11:35,060
That means you can have duplicate keys and those will be stored in the multimap as well.

170
00:11:35,720 --> 00:11:38,420
So these are unordered associative containers.

171
00:11:39,140 --> 00:11:46,700
There is one fourth category which is known as container adapters, so they provide a different kind

172
00:11:46,700 --> 00:11:50,950
of interface to the further containers.

173
00:11:50,960 --> 00:11:52,910
ok so one of them is stack.

174
00:11:53,030 --> 00:11:57,860
OK, so the stack can be easily implemented using array or  vector or a linked list.

175
00:11:58,460 --> 00:12:04,070
But what stack provides is it provides different methods to access the data, OK?

176
00:12:04,370 --> 00:12:06,260
It also restricts the functionality.

177
00:12:06,260 --> 00:12:08,710
You cannot have a look at all the elements, OK?

178
00:12:09,200 --> 00:12:12,170
You can only look at that topmost element if you're using a stack.

179
00:12:12,230 --> 00:12:19,370
You cannot remove from the middle or you can only remove from the top or you can see what is at the top.

180
00:12:19,850 --> 00:12:28,190
Because that hides that stuff, the elements under the interface, OK?

181
00:12:29,060 --> 00:12:33,140
Then there is Queue, so you again can be implemented using an array or a vector.

182
00:12:33,740 --> 00:12:36,710
So but queue support the following operations.

183
00:12:37,250 --> 00:12:44,360
so why we are using these data structures because it is easier to think in terms of queue or a stack

184
00:12:44,360 --> 00:12:47,930
when we're solving a problem in which this kind of a data structure can be used.

185
00:12:48,320 --> 00:12:53,480
We don't need to worry about what happens with the middle element because we are only doing insertion

186
00:12:53,480 --> 00:12:57,370
at the back and we are going to remove elements from the front.

187
00:12:57,380 --> 00:12:57,650
OK?

188
00:12:58,280 --> 00:13:03,870
queue allows us to remove elements from the front and push elements from the back.

189
00:13:03,890 --> 00:13:05,780
OK, so pushing is known as enqueue.

190
00:13:06,230 --> 00:13:13,070
Removing elements from the front is known dequeue we are moving something push or inserting or

191
00:13:13,070 --> 00:13:14,340
whatever you want to call it as.

192
00:13:14,960 --> 00:13:17,710
then there is something we do, which we call it as priority queue.

193
00:13:18,830 --> 00:13:24,050
So again, although it seems it's like, queue but internally we know it's a heap data structure.

194
00:13:24,050 --> 00:13:24,770
That's OK.

195
00:13:25,460 --> 00:13:28,610
So heap allows us to get the maximum element.

196
00:13:29,960 --> 00:13:37,160
Or the minimum element out of a collection of elements, and we can remove the minimum or maximum element.

197
00:13:37,820 --> 00:13:38,180
OK.

198
00:13:38,870 --> 00:13:47,450
And we can insert any element so heap allow us these three operations insert new data get max and

199
00:13:47,450 --> 00:13:51,110
remove maximum or the minimum elements, OK?

200
00:13:51,440 --> 00:13:55,430
So again, these operations are supported in almost log(n) time.

201
00:13:56,180 --> 00:13:57,850
And this is what a priority queue is.

202
00:13:58,160 --> 00:13:58,470
OK.

203
00:14:00,530 --> 00:14:07,460
So I hope you got a quick overview of the different type of containers that we have in STL.

204
00:14:08,030 --> 00:14:09,800
And that's all for this video.

