1
00:00:01,470 --> 00:00:08,270
Hi in this lecture, I will tell you how you can use the inbuilt priority queue class in C++, as heap data structure

2
00:00:08,430 --> 00:00:14,370
OK, so firstly, you need to include the header file that is queue, and after that you need

3
00:00:14,370 --> 00:00:16,320
to make a class priority queue.

4
00:00:17,670 --> 00:00:23,280
So this class is already defined, so we will create an object and each node will contain an integer

5
00:00:23,280 --> 00:00:23,430
it.

6
00:00:24,000 --> 00:00:25,500
So let's call it as a heap.

7
00:00:26,520 --> 00:00:28,230
And now this is a variable, OK?

8
00:00:28,250 --> 00:00:31,320
This is and this is the data structure that we're using.

9
00:00:31,650 --> 00:00:37,170
What we can do, we can iterate over all the elements in array and let us try to insert all those

10
00:00:37,170 --> 00:00:39,840
elements in this particular priority queue so,

11
00:00:40,230 --> 00:00:44,660
As the name suggests, each element will come out of the queue with a certain priority.

12
00:00:44,670 --> 00:00:49,340
In this case, the priority is element with the higher value has a higher priority.

13
00:00:49,350 --> 00:00:49,620
OK?

14
00:00:49,890 --> 00:00:58,440
So let us see if I can say, heap dot Push X and let us build the code and it is working fine.

15
00:00:58,480 --> 00:01:03,510
Not all the elements are added inside the heap and internally it looks maybe something like this.

16
00:01:03,510 --> 00:01:04,410
You will have 90 at the root node.

17
00:01:04,739 --> 00:01:09,530
then it would have maybe 20 or maybe it would have 10 OK.

18
00:01:09,600 --> 00:01:10,080
So I don't know.

19
00:01:10,380 --> 00:01:13,320
Internally, the structure would look something like this.

20
00:01:14,130 --> 00:01:20,190
What we can do, we can keep on removing all the nodes one by one from this heap and see what is the

21
00:01:20,190 --> 00:01:20,890
output we get.

22
00:01:20,970 --> 00:01:23,910
So we can say while this heap is not empty.

23
00:01:24,950 --> 00:01:32,350
While not empty it, us try to remove one element that is at the top of the heap so I can to say cout,

24
00:01:33,020 --> 00:01:36,640
if dot, I think the function is called to stop it.

25
00:01:37,400 --> 00:01:40,640
And then I can call the heap dot pop function.

26
00:01:40,970 --> 00:01:47,270
The top function displays what is at the top and pop function removes that topmost element.

27
00:01:48,340 --> 00:01:53,090
OK, so and now we're we can run this code.

28
00:01:53,360 --> 00:01:56,030
We can see dot slash.

29
00:01:57,660 --> 00:02:03,960
The file name is sorting using a heap, if I now show you, you can see we are getting the elements

30
00:02:03,960 --> 00:02:04,840
in our descending order.

31
00:02:04,860 --> 00:02:07,860
That means you're able to do sorting using the heap.

32
00:02:08,190 --> 00:02:13,650
But now you may ask what if I want to sort these elements in reverse order, OK?

33
00:02:14,130 --> 00:02:16,910
So by default, it makes a max heap.

34
00:02:17,150 --> 00:02:22,360
You can see it as a max heap by default if you want the min  heap.

35
00:02:22,380 --> 00:02:24,030
Then what we can do, we can.

36
00:02:24,600 --> 00:02:27,150
We have to provide two more parameters.

37
00:02:27,160 --> 00:02:31,470
One is called vector and there is another comparator.

38
00:02:32,430 --> 00:02:36,360
So you're going to build comparator that will reverse the comparison, OK?

39
00:02:36,900 --> 00:02:39,400
This will convert this max heap into a min heap.

40
00:02:39,420 --> 00:02:44,760
And if I now run the code and you're can see we are getting these elements in a reverse order.

41
00:02:45,270 --> 00:02:48,600
So this is inbuilt comparator, OK?

42
00:02:49,440 --> 00:02:49,740
It does.

43
00:02:49,800 --> 00:02:55,950
It has reversed the comparison that he was using internally to compare two elements of greater element

44
00:02:55,950 --> 00:02:56,790
was going to the top.

45
00:02:56,880 --> 00:02:59,570
Now the smaller element is going to the top.

46
00:02:59,940 --> 00:03:07,290
If you don't want to use this kind of a comparator or maybe for a complex object, you can also write

47
00:03:07,290 --> 00:03:09,250
your own custom comparator.

48
00:03:09,270 --> 00:03:09,600
OK.

49
00:03:09,960 --> 00:03:15,480
Let me also show you how we can write those own custom comparator for this particular class.

50
00:03:15,930 --> 00:03:19,470
I will maybe make a copy of this code.

51
00:03:20,510 --> 00:03:23,200
And I call it as custom compare dot.

52
00:03:24,660 --> 00:03:27,900
And here we are going to define class compare.

53
00:03:28,830 --> 00:03:35,820
And inside this class, we have to define method so we can say bool operator.

54
00:03:37,450 --> 00:03:37,960
And.

55
00:03:39,110 --> 00:03:42,260
Now, if you look, we are doing operator overloading here.

56
00:03:42,290 --> 00:03:47,360
We have we are going to get to numbers int a and int b and we are going to compare them.

57
00:03:48,170 --> 00:03:50,900
This compare function we will not call directly.

58
00:03:51,200 --> 00:03:55,700
The heap class will call it internally whenever it is comparing two elements OK, so we say return

59
00:03:55,700 --> 00:03:58,280
let's say a greater than b.

60
00:04:00,070 --> 00:04:06,610
So this function is public because it would be called from outside the compare class, and then we have

61
00:04:06,610 --> 00:04:09,820
this operator, that means we are overloading the round brackets

62
00:04:10,450 --> 00:04:16,870
And then whenever we are doing a comparison, we get 2 numbers which are as argument and based upon

63
00:04:16,870 --> 00:04:20,950
the logic it will return true or false if it is greater than it will return.

64
00:04:20,950 --> 00:04:26,290
True if I instead of doing this, if I simply send the compare class.

65
00:04:28,430 --> 00:04:31,310
So if I do, starting using heaps, I get this output.

66
00:04:31,730 --> 00:04:37,400
But let's say if I change this comparison here and build my code and I get.

67
00:04:40,830 --> 00:04:46,560
I should get a ok this is the output, and if I do it like this, I will build the code.

68
00:04:47,480 --> 00:04:47,930
And.

69
00:04:54,950 --> 00:04:58,010
OK, so it is my mistake, I'm running the wrong file.

70
00:04:58,100 --> 00:05:01,880
It's not sorting using heap the file name is custom compared.

71
00:05:01,910 --> 00:05:04,190
So dot slash custom compare.

72
00:05:04,640 --> 00:05:07,180
And you can see we are getting the elements in a sorted order.

73
00:05:07,580 --> 00:05:14,090
But if I change this now to like this one, we get the reverse order, OK?

74
00:05:14,480 --> 00:05:20,450
So this is one thing you can do in some of the problems, and we will see more such application in coming

75
00:05:20,450 --> 00:05:21,020
lectures.

