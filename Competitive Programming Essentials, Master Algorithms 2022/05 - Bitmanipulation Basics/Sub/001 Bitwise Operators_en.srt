1
00:00:01,359 --> 00:00:08,170
Hi Everyone, in this section we will talk about bit manipulation techniques, and these are nothing

2
00:00:08,170 --> 00:00:09,190
but these are some..

3
00:00:09,220 --> 00:00:16,960
Maybe you can say algorithms using which you can modify the data are binary representation level and every

4
00:00:16,960 --> 00:00:25,000
programming language provides us some bitwise operators which allow us to operate on the binary representation

5
00:00:25,000 --> 00:00:26,020
of the data that we have.

6
00:00:26,050 --> 00:00:26,410
OK.

7
00:00:26,680 --> 00:00:31,750
So we will look how to use these bitwise operators, what are the different types of bitwise operators

8
00:00:31,750 --> 00:00:35,800
and how we can use them to solve some problems, OK?

9
00:00:36,100 --> 00:00:43,090
And the reason why we use Bitwise operators sometime is ? because they operate on the binary representation

10
00:00:43,090 --> 00:00:49,090
of the data and they're fast as compared to the use the non bitwise operators.

11
00:00:49,600 --> 00:00:53,740
And what are the different types of operators you can see on the screen?

12
00:00:54,190 --> 00:01:00,010
And we are going to talk about AND, OR, XOR, One's  complement,

13
00:01:01,350 --> 00:01:07,160
Binary left shift and binary right shift. Ok. so these are the Bitwise operators and if you're new to them,

14
00:01:07,170 --> 00:01:09,840
so let us explore each of them one by one.

15
00:01:10,830 --> 00:01:12,500
So the first one is a binary.

16
00:01:12,510 --> 00:01:18,660
And so basically, let's say AND has very simple rules. let's say you have two bits.

17
00:01:19,500 --> 00:01:22,140
One and let's say the other bit is zero.

18
00:01:22,230 --> 00:01:27,090
So if you do AND with a zero, then it is going to give you a result of zero.

19
00:01:27,450 --> 00:01:34,980
Similarly, zero AND one is going to give you a result of zero and only when both the bits are set.

20
00:01:35,460 --> 00:01:39,600
Only then you will get a result of one and zero AND zero

21
00:01:39,610 --> 00:01:41,310
is also going to be zero.

22
00:01:41,320 --> 00:01:45,540
So anything done an AND with zero is going to give you a zero bit.

23
00:01:45,810 --> 00:01:49,880
OK, so these are the simple rules of doing a simple AND.

24
00:01:50,260 --> 00:01:52,080
And now what?

25
00:01:52,440 --> 00:01:53,280
How do we use it?

26
00:01:53,310 --> 00:01:58,550
OK, let's say I have a number five and I do AND with seven then what I'm going to get.

27
00:01:58,560 --> 00:01:59,140
So let's see.

28
00:01:59,190 --> 00:02:06,000
So five five in binary is represented as zero zero zero followed by let say one zero one and it's let's say 

29
00:02:06,000 --> 00:02:12,510
32 or 64 bit number. seven and binary can be represented as lots of zeros followed by triple one.

30
00:02:13,050 --> 00:02:16,020
If you do AND so it will happen on

31
00:02:16,320 --> 00:02:17,360
bit by bit level.

32
00:02:17,370 --> 00:02:23,640
OK, so one and one is one, zero and one is zero, one and one is one and followed by lot's zeros.

33
00:02:23,880 --> 00:02:24,180
OK.

34
00:02:24,390 --> 00:02:29,540
So if you convert this number back into the decimal you will see this result is going to be 5.

35
00:02:30,060 --> 00:02:32,580
This is how binary AND works.

36
00:02:33,450 --> 00:02:34,620
So I hope this is clear.

37
00:02:35,100 --> 00:02:37,290
And now let's see what is binary OR.

38
00:02:37,980 --> 00:02:40,470
So the rules of the OR are very simple.

39
00:02:40,950 --> 00:02:45,870
If one of the bits is one then the result is going to be one. for example,

40
00:02:47,240 --> 00:02:48,440
one OR zero 

41
00:02:49,480 --> 00:02:50,950
Is going to give you

42
00:02:52,120 --> 00:02:57,190
Ok, this is denoted using this operated one OR zero is going to give you one.

43
00:02:57,520 --> 00:03:05,110
Similarly, zero OR one is going to give you one, zero OR zero is going to give you a zero and 

44
00:03:05,110 --> 00:03:06,880
one OR one is going to give you one.

45
00:03:07,200 --> 00:03:11,330
So if one of the bits is one then the resulting bit would be one.

46
00:03:11,350 --> 00:03:16,120
For example, if I do five OR with eight.

47
00:03:16,180 --> 00:03:17,620
OK, so what is five?

48
00:03:17,620 --> 00:03:18,940
Five is one zero one.

49
00:03:19,330 --> 00:03:20,020
What is 8?

50
00:03:20,320 --> 00:03:21,910
8 is one triple zero.

51
00:03:23,210 --> 00:03:23,610
Yes.

52
00:03:24,110 --> 00:03:30,160
And if you do OR here, what you're going to get ?  you're going to get one here, one here, zero here

53
00:03:30,170 --> 00:03:30,830
and one here.

54
00:03:31,400 --> 00:03:32,420
So what does this number?

55
00:03:32,570 --> 00:03:34,340
This is eight.

56
00:03:34,610 --> 00:03:35,450
This is four.

57
00:03:35,570 --> 00:03:37,710
This is two and this is one.

58
00:03:37,740 --> 00:03:39,770
So if you are eight plus four plus one.

59
00:03:40,130 --> 00:03:41,690
So this number is actually 13.

60
00:03:41,720 --> 00:03:42,020
OK.

61
00:03:42,400 --> 00:03:45,600
So these are actually powers of two. two raise to the power 0,

62
00:03:45,790 --> 00:03:49,360
two raise to the power 1,two raise to the power 2,two raise to the power 3,

63
00:03:49,370 --> 00:03:53,550
So you can see I'm doing eight plus four plus one, that is 13.

64
00:03:53,600 --> 00:03:55,930
OK, so this number is actually 13.

65
00:03:55,940 --> 00:04:01,760
So if you do this in your code, you will get an output of 13 in this particular case.

66
00:04:02,230 --> 00:04:04,490
So I hope binary OR is also clear.

67
00:04:05,520 --> 00:04:06,890
Now let us move on to XOR.

68
00:04:07,280 --> 00:04:10,370
So XOR is also known as exclusive OR.

69
00:04:10,380 --> 00:04:10,590
.

70
00:04:10,910 --> 00:04:11,210
OK.

71
00:04:12,510 --> 00:04:13,350
Exclusive OR.

72
00:04:14,280 --> 00:04:16,860
So what are the rules of XOR?

73
00:04:17,250 --> 00:04:23,470
So it basically means if both bits are same then there is going to be zero. for example,

74
00:04:23,550 --> 00:04:25,350
zero XOR zero is zero.

75
00:04:26,040 --> 00:04:31,590
And also one XOR zero is... sorry, ones XOR one is also zero.

76
00:04:32,340 --> 00:04:34,560
If both the bits are same the result is zero.

77
00:04:34,860 --> 00:04:39,270
Otherwise if both bits are different than the result is one.

78
00:04:39,810 --> 00:04:43,440
So if I show you maybe if I do five

79
00:04:44,190 --> 00:04:45,540
XOR seven.

80
00:04:45,990 --> 00:04:52,710
So five is what five is zero zero zero one zero one and seven is zero zero triple one.

81
00:04:53,190 --> 00:04:58,740
If I do XOR here then one XOR one is going to be zero, zero XOR one is going to be one.

82
00:04:59,100 --> 00:05:01,380
This is going to be zero and lots of zeros.

83
00:05:01,830 --> 00:05:03,450
This result is going to be two.

84
00:05:03,600 --> 00:05:10,560
OK, so if you do something like cout five XOR seven then it is going to print two in your code.

85
00:05:11,980 --> 00:05:12,280
OK.

86
00:05:12,580 --> 00:05:15,430
So I hope you understood this XOR operator as well.

87
00:05:16,360 --> 00:05:20,380
So the next  that we're going to discuss is NOT. OK.

88
00:05:20,380 --> 00:05:24,340
So the NOT is a very simple operator.

89
00:05:24,760 --> 00:05:31,810
So what what it does if I have a bit zero. Ok. let's say this is... this is not a integer zero.

90
00:05:31,810 --> 00:05:33,370
This is the bit zero.

91
00:05:33,370 --> 00:05:41,500
So if you do NOT of zero, you're going to get one and suppose you do NOT off some number.

92
00:05:41,530 --> 00:05:45,740
OK, let's say you have a number like zero zero zero one zero one.

93
00:05:46,000 --> 00:05:46,910
let's say This number is five.

94
00:05:46,930 --> 00:05:53,200
If you do the NOT five, then it is going to flip all the bits. OK, so NOT of one is zero.

95
00:05:53,460 --> 00:05:58,420
and NOT of this is going to be lots of one's followed by zero one zero one.

96
00:05:58,540 --> 00:05:58,810
OK.

97
00:05:59,350 --> 00:06:05,620
So this you will see it is going to flip all the bits including the most significant bit.

98
00:06:06,430 --> 00:06:07,240
That is the sign bit.

99
00:06:07,510 --> 00:06:09,280
OK, that is the sign bit.

100
00:06:09,310 --> 00:06:13,510
That means this number could be a negative number as well, OK?

101
00:06:14,410 --> 00:06:17,800
Now, if you have little idea here, I can give you one example.

102
00:06:18,110 --> 00:06:20,200
Let's say I take something like this.

103
00:06:20,200 --> 00:06:26,680
Let's say take int A. and i say int a is  zero and I simply do cout NOT of A.

104
00:06:27,310 --> 00:06:31,180
Then what you're going to expect. OK. what would be the  answer?

105
00:06:32,300 --> 00:06:36,620
The answer is going to be actually not one but it would be minus one.

106
00:06:36,650 --> 00:06:39,560
OK, now you may wonder why, why it is so.

107
00:06:39,830 --> 00:06:45,620
So if you look zero at the memory level to what a zero?zero is a 32 bit number in which

108
00:06:46,890 --> 00:06:52,470
Everything is... everything is zero. all the 32 bits are zero.

109
00:06:52,950 --> 00:06:56,070
If you do a NO of it you will get all 32  bits as ones.

110
00:06:57,060 --> 00:06:58,290
Ok?

111
00:07:00,120 --> 00:07:00,630
And

112
00:07:02,090 --> 00:07:07,190
All 32 bits are ones and the most significant bits represents the sign bits.

113
00:07:07,430 --> 00:07:13,940
OK, so if this sign bit is one that means it is a negative number, so that means it is a negative number

114
00:07:14,240 --> 00:07:18,350
and the remaining 31 bits they represent

115
00:07:19,320 --> 00:07:24,900
the magnitude. ok ? now for the negative numbers, if we want to find out the magnitude of that particular

116
00:07:24,900 --> 00:07:25,320
number.

117
00:07:25,770 --> 00:07:29,760
These numbers are stored in a form known as 2's complement form.

118
00:07:29,820 --> 00:07:33,440
OK, that's stored int a 2's complement form.

119
00:07:34,320 --> 00:07:41,090
So in order to find out what number is this what we need to do, we need to take the 2's compliment.

120
00:07:41,250 --> 00:07:44,780
That means invert all the bit's and add one to it.

121
00:07:44,790 --> 00:07:44,910
OK?

122
00:07:45,240 --> 00:07:51,300
The number is this this this. in order to find the magnitude, we have to first invert all the bits.

123
00:07:52,360 --> 00:07:54,790
If i invert all the bits, it becomes like this

124
00:07:55,450 --> 00:07:57,040
And then I will add one to it.

125
00:07:57,730 --> 00:08:00,720
This number is zero zero zero zero zero one.

126
00:08:01,390 --> 00:08:05,270
So basically, this is a negative number with the magnitude of one.

127
00:08:05,650 --> 00:08:08,380
And this number is actually minus one.

128
00:08:08,440 --> 00:08:08,740
OK.

129
00:08:09,010 --> 00:08:14,680
So if you do NOT of zero and where zero is an integer, you are going to get minus one as output, OK?

130
00:08:15,000 --> 00:08:16,780
And Not of  zero where zero is bit.

131
00:08:17,770 --> 00:08:18,520
It would be one.

132
00:08:18,550 --> 00:08:18,850
OK.

133
00:08:19,210 --> 00:08:23,770
So that is something that you should be very careful while working on.

134
00:08:23,800 --> 00:08:24,100
OK.

135
00:08:25,120 --> 00:08:27,910
So that's something you can try it on your own as well.

136
00:08:31,080 --> 00:08:36,690
OK, if you don't trust me I'm going to show you demo as well, so I have just code where I have

137
00:08:36,919 --> 00:08:39,360
x is zero and I'm doing cout NOT of x?

138
00:08:39,870 --> 00:08:48,030
So let us run this code and see what we get as a output. sorry... and this should be a dot slash bitwise.

139
00:08:48,420 --> 00:08:51,180
So you can see this output is actually minus one.

140
00:08:51,210 --> 00:08:53,390
That is because of the same reason I have discussed.

141
00:08:53,400 --> 00:09:00,420
OK, so doing a negation of all zeros gives us a number in which all numbers are ones and since it is stored as 

142
00:09:00,600 --> 00:09:03,900
2's complement form. the first but denotes the singed bits.

143
00:09:04,260 --> 00:09:06,150
The remaining bits denotes the the magnitude.

144
00:09:06,540 --> 00:09:10,830
And in order to find the exact magnitude we have to take 2's compliment.

145
00:09:10,860 --> 00:09:17,610
So this process is known as 2's complement where we invert all the bits and add one to it.

146
00:09:17,910 --> 00:09:21,780
And whatever you get this number, this is the magnitude of the number.

147
00:09:21,840 --> 00:09:22,160
OK.

148
00:09:22,200 --> 00:09:28,440
So if you convert this number into decimal this number is one and sign is minus one because

149
00:09:28,590 --> 00:09:31,170
the most significant bit is one.

150
00:09:31,200 --> 00:09:31,500
OK.

151
00:09:32,160 --> 00:09:33,860
So I hope this is clear.

152
00:09:34,280 --> 00:09:43,050
And Now you understand that doing the negation of bit  zero is one and doing the negation of integer zero

153
00:09:43,050 --> 00:09:44,410
is minus one.

154
00:09:44,430 --> 00:09:45,660
It's an important concept.

155
00:09:45,930 --> 00:09:47,100
So I have explained it to you.

156
00:09:48,120 --> 00:09:49,270
So binary NOT is clear.

157
00:09:49,800 --> 00:09:54,210
Now we will talk about two more operators left and right shift in the next lecture.

