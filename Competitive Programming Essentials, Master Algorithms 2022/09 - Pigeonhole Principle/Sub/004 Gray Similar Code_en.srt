1
00:00:00,330 --> 00:00:05,780
Hi everyone, in this lecture we're going to solve this problem. the problem name is Gray similar Code

2
00:00:06,270 --> 00:00:08,580
and it is again a question from codechef.

3
00:00:08,700 --> 00:00:16,920
So it has given, we are given N 64 bit integers such that two consecutive numbers differ

4
00:00:16,920 --> 00:00:17,940
exactly at one bit.

5
00:00:17,940 --> 00:00:18,180
Okay.

6
00:00:18,660 --> 00:00:27,300
So let's say if the first.... if the Ith numbers is let's say if there is like one one zero zero one,

7
00:00:27,780 --> 00:00:31,020
then A[i+1] will only have one

8
00:00:31,020 --> 00:00:31,710
bit different.

9
00:00:31,710 --> 00:00:35,500
ok. maybe this bit is different. ok. rest

10
00:00:35,550 --> 00:00:40,180
all the bits are the same. so we have to find four integers.

11
00:00:40,200 --> 00:00:40,530
OK.

12
00:00:40,680 --> 00:00:42,780
So this is a small mistake.

13
00:00:43,290 --> 00:00:44,760
We have to find four integers.

14
00:00:44,880 --> 00:00:49,980
Such that their XOR is equal to zero and we have to output yes or no.

15
00:00:50,130 --> 00:00:53,700
If such four integers are possible or not.

16
00:00:54,240 --> 00:00:56,390
Now again, this is a problem from codechef.

17
00:00:56,400 --> 00:00:59,190
So let us look at the exact constraints.

18
00:01:00,340 --> 00:01:00,670
OK.

19
00:01:01,120 --> 00:01:09,240
And the question is same like you're given N non-negative integer and Ai is of the range to 2 power 64

20
00:01:09,250 --> 00:01:11,770
that means the number can be stored in long long.

21
00:01:13,550 --> 00:01:21,170
And you need to check whether there are four numbers such that the following properties is satisfied.

22
00:01:21,170 --> 00:01:26,810
Ok. So it is saying the XOR of the numbers let's say  the four numbers is A,B,C,D.

23
00:01:27,410 --> 00:01:33,860
So So A^B^C^D. this is equal to zero, this is the property that needs to be

24
00:01:34,370 --> 00:01:36,950
satisfied for this particular problem.

25
00:01:38,790 --> 00:01:41,280
And in the output, we just need to print yes or no.

26
00:01:41,730 --> 00:01:43,830
So let us look at the value of N.

27
00:01:43,830 --> 00:01:48,600
So N you can see it is, it is a large number. N is of the order

28
00:01:49,380 --> 00:01:54,310
ten power five and  now what is a brute force approach? 

29
00:01:54,660 --> 00:01:58,230
So let's talk about the bruteforce approach of doing this.

30
00:01:58,650 --> 00:02:00,720
So we are also giving a sample input.

31
00:02:00,720 --> 00:02:05,010
So we have five integer and the answer for this is yes.

32
00:02:05,490 --> 00:02:12,120
So there exist four numbers from the set so that the Xor is equal to zero.

33
00:02:13,110 --> 00:02:15,690
Now let us look at one thing.

34
00:02:17,970 --> 00:02:22,680
So let us discuss what are the various approaches to solve this problem.

35
00:02:23,100 --> 00:02:29,730
So the first way is brute force approach in which what you're going to do? we are going to pick four

36
00:02:29,730 --> 00:02:30,280
numbers.

37
00:02:30,540 --> 00:02:30,870
OK.

38
00:02:31,920 --> 00:02:39,510
And how do you pick four numbers out of N numbers? simply by using four loops and you would have nC4

39
00:02:39,540 --> 00:02:40,200
options.

40
00:02:40,800 --> 00:02:49,200
And this would take that O(N^4) time and since N is of the order ten power five.

41
00:02:50,160 --> 00:02:54,330
This solution will give you the time limit Exceeded  error.  OK.

42
00:02:54,700 --> 00:02:56,670
The the brute force solution will not work.

43
00:02:56,670 --> 00:03:04,230
The brute force will work for smaller values of N. OK for smaller values of N, let's say four N

44
00:03:04,230 --> 00:03:05,490
less than equal 100.

45
00:03:05,640 --> 00:03:12,270
The brute force will work because doing N power four  would be of the order

46
00:03:12,270 --> 00:03:12,850
ten power eight.

47
00:03:12,900 --> 00:03:20,530
OK, so now let's see how what optimizations we can add to our solution.

48
00:03:20,550 --> 00:03:20,820
OK.

49
00:03:21,210 --> 00:03:23,970
How do we optimize our solution?

50
00:03:25,150 --> 00:03:29,610
SO the thing is, what we want is we are not exploiting the property.

51
00:03:29,610 --> 00:03:32,550
So there is one information given in the question that

52
00:03:34,520 --> 00:03:37,820
two consecutive numbers, two consecutive

53
00:03:39,270 --> 00:03:43,500
numbers differ only at one bit. differ

54
00:03:44,550 --> 00:03:52,620
only at one bit and another information given is the numbers are 64 bit numbers.

55
00:03:52,800 --> 00:03:56,130
This is also given. till now in the brute force solution

56
00:03:56,130 --> 00:03:58,080
we have not used this information.

57
00:03:58,590 --> 00:04:04,240
Now we need to see what is special thing about this information and how we can use it.

58
00:04:04,260 --> 00:04:07,560
OK, so two consecutive numbers differ at only one bit.

59
00:04:07,800 --> 00:04:16,260
So if I do a XOR of a number along with the next number, some Ith number. OK. since they differ at only one

60
00:04:16,269 --> 00:04:20,820
bit. let's say this is the number and let's say this is the next number.

61
00:04:21,450 --> 00:04:27,420
If I do a XOR of both what I will get? I'll get all zeros except

62
00:04:28,720 --> 00:04:34,570
one at one position. OK. so it will be all zeros but we will get one at

63
00:04:36,020 --> 00:04:41,690
one position. OK. at any any one position where the bits are different, I'll get the bit one.

64
00:04:42,740 --> 00:04:50,170
Now suppose I have a lot of numbers. OK. so I have numbers from A1 A2 upto upto , let's say

65
00:04:50,930 --> 00:04:56,450
A129, A130 up to up to An. OK.

66
00:04:57,110 --> 00:05:03,530
So what I'm saying is, if I have at least 130 numbers. OK, if I have at least

67
00:05:04,900 --> 00:05:10,720
130 numbers, If the value of n is greater than 130.

68
00:05:11,350 --> 00:05:14,470
I can say my answer would be always yes. I will tell you why.

69
00:05:14,740 --> 00:05:15,820
I will tell you why.

70
00:05:16,450 --> 00:05:23,620
But if N is less than or equal to 130, ok if N is greater than or equal to 130 than the answer is always going

71
00:05:23,620 --> 00:05:24,190
to be yes.

72
00:05:24,340 --> 00:05:25,420
Let me just tell you why.

73
00:05:26,710 --> 00:05:33,490
So if you have 130 numbers and if you do a paire wise XOR of all the numbers.

74
00:05:33,490 --> 00:05:40,360
Okay. so if you do as XOR of these, A XOR of next two, A XOR of next two , A XOR of next two. ok.

75
00:05:40,360 --> 00:05:41,350
SO what is going to happen?

76
00:05:41,480 --> 00:05:44,590
You're going to get 65 pairs. OK?

77
00:05:45,940 --> 00:05:51,100
You're going to get 65 pairs and in each pair you will have a number of the form

78
00:05:52,490 --> 00:05:54,920
One one of the positions will be one. OK?

79
00:05:55,490 --> 00:06:00,320
So only one bit would be set. only one bit

80
00:06:01,740 --> 00:06:10,110
would be set. OK. because of the property that we have just seen that if we do a XOR of two consecutive

81
00:06:10,110 --> 00:06:14,370
numbers, we get a number in which only one bit would be set.

82
00:06:14,910 --> 00:06:15,660
Now this one bit

83
00:06:15,750 --> 00:06:21,740
can occupy a position in the range zero to sixty three.

84
00:06:21,780 --> 00:06:22,110
OK.

85
00:06:22,680 --> 00:06:26,790
That can be indexed from zero to index

86
00:06:26,910 --> 00:06:27,600
Sixty three.

87
00:06:27,930 --> 00:06:30,190
OK,. but how many pairs we have?

88
00:06:30,240 --> 00:06:30,540
OK.

89
00:06:30,960 --> 00:06:34,590
So basically we only have 64 positions.

90
00:06:35,010 --> 00:06:38,280
OK, we only have 64 positions.

91
00:06:38,850 --> 00:06:39,180
OK.

92
00:06:40,350 --> 00:06:48,510
And but we have 65 answers. ok so we get 65 pairs and each pair is of this particular form in which

93
00:06:48,990 --> 00:06:51,890
one of the bits is in this range.

94
00:06:51,900 --> 00:07:00,360
OK. that means at least at least two pairs will have same value.

95
00:07:01,200 --> 00:07:04,890
At least two pairs will have same value.

96
00:07:05,310 --> 00:07:08,520
Let us assume the value is this much. that means

97
00:07:08,520 --> 00:07:17,710
one of the pair has a bit at let's say some Kth  position. there must be one more pair which has bit  

98
00:07:18,180 --> 00:07:19,230
at the same position.

99
00:07:19,230 --> 00:07:28,740
So at least two pairs will have the same value because all the pairs of the form in which all the

100
00:07:28,740 --> 00:07:32,970
positions contain zero except one position contains one.

101
00:07:33,270 --> 00:07:33,570
OK.

102
00:07:33,870 --> 00:07:40,950
And since there are only 64 positions for one but we have 65 such pair that means two pairs will

103
00:07:40,950 --> 00:07:42,630
have same value.

104
00:07:42,630 --> 00:07:51,780
That means the set bit at same position. the set bit at same position. to know what we can conclude

105
00:07:51,780 --> 00:08:00,600
from here as, we can see if we if we know. OK. there must be at least two pair which are having the

106
00:08:00,600 --> 00:08:01,200
same value.

107
00:08:01,530 --> 00:08:08,820
Let's say the numbers A  and B formed the pair P1. the numbers C and D formed the pair P2 and hence

108
00:08:09,120 --> 00:08:12,330
doing XOR of these two pairs. p1 and P2

109
00:08:12,930 --> 00:08:15,120
they will always produce the XOR zero.

110
00:08:15,380 --> 00:08:16,030
let's say pair is P1. this pair is P2.

111
00:08:16,050 --> 00:08:19,440
P1 xor P2 would be zero.

112
00:08:19,800 --> 00:08:22,170
So this would be always be yes.

113
00:08:22,170 --> 00:08:25,980
if we can get at least 65 pairs

114
00:08:26,490 --> 00:08:33,090
that means if the number of numbers is greater then equal to 130 in the array, the answer would be

115
00:08:33,090 --> 00:08:34,080
always yes.

116
00:08:34,559 --> 00:08:39,990
This solves for the case when N is greater than or equal to 130.

117
00:08:40,020 --> 00:08:49,830
OK, now let's come to the second case. what if N is less than if the value of N is less than 130?

118
00:08:49,830 --> 00:08:57,030
OK, so if an is less than 130 then what we can do? we can say our brute force solution will work for smaller

119
00:08:57,030 --> 00:08:57,360
values

120
00:08:57,360 --> 00:09:01,710
of N. we can still optimize the brute force solution little bit.

121
00:09:02,190 --> 00:09:03,330
Let's see how we can do it.

122
00:09:03,330 --> 00:09:03,600
OK?

123
00:09:03,840 --> 00:09:12,330
So let let me just summarize so if N is greater than equal to 130. we can say the answer is always

124
00:09:12,330 --> 00:09:19,530
yes, because we have proved by using the pigeonhole principle that if we get sixty five pairs and we have

125
00:09:19,530 --> 00:09:28,920
only 64 bit positions which can which are possible then two pairs will have the same value.

126
00:09:29,460 --> 00:09:33,060
And doing XOR of those pair would produce an output of

127
00:09:33,060 --> 00:09:33,270
zero.

128
00:09:33,280 --> 00:09:33,600
OK.

129
00:09:34,110 --> 00:09:34,500
two

130
00:09:34,500 --> 00:09:35,640
pairs will have

131
00:09:36,680 --> 00:09:38,540
same value.

132
00:09:39,050 --> 00:09:42,170
And we can say  that, P1^P2 would be zero.

133
00:09:42,620 --> 00:09:45,020
And let's say  this pair is made up of A and B.

134
00:09:45,050 --> 00:09:49,340
This pair is made up of C and D. and doing a XOR of these would give me an answer

135
00:09:49,820 --> 00:09:50,140
zero.

136
00:09:50,480 --> 00:09:55,100
But if N is less than 130. N is not greater than 130.

137
00:09:55,550 --> 00:09:59,000
then what we need is, we we can actually use a brute force approach.

138
00:09:59,180 --> 00:10:04,520
So we need to find out four numbers A xor B xor C xor D

139
00:10:04,700 --> 00:10:10,220
This is equal to zero or what we can do is, we need to find out a number B.

140
00:10:11,900 --> 00:10:21,230
So we can use three loops to iterate over the values of A, B and C and we can say  A xor B xor C must

141
00:10:21,230 --> 00:10:22,580
be equal to D. OK.

142
00:10:22,580 --> 00:10:27,730
If this xor is equal to zero then if we find out a

143
00:10:29,430 --> 00:10:35,040
If we just use three loops to iterate on all positions of ABC?

144
00:10:36,020 --> 00:10:37,260
We can look for D.

145
00:10:38,040 --> 00:10:41,520
We can look for D in the array.

146
00:10:42,090 --> 00:10:43,390
Now how we can look for D.

147
00:10:43,860 --> 00:10:45,030
So there are two options.

148
00:10:45,570 --> 00:10:50,610
One option is you do the sorting and then you do the binary search.

149
00:10:50,790 --> 00:10:56,570
OK, binary search for D. another option could be if you can do hashing as well.

150
00:10:56,670 --> 00:11:02,040
OK, if you hash, you can simply look for the value of D in just constant time.

151
00:11:02,700 --> 00:11:10,320
So that means this operation can be either reduced to log(n) operation or if you're do binary research

152
00:11:10,350 --> 00:11:13,710
or it can be reduced to order one operation.

153
00:11:14,160 --> 00:11:16,050
If you use a hashing.

154
00:11:16,230 --> 00:11:25,610
OK, so now the brute force solution can be solved in order of N^3  time or order of N^3log(n)

155
00:11:25,620 --> 00:11:25,980
time

156
00:11:26,010 --> 00:11:31,380
And since the value of N is only of the Order 100.

157
00:11:31,900 --> 00:11:37,980
And this would take ten power six operations and hence this will get accepted.

158
00:11:37,980 --> 00:11:43,080
OK, so you basically make if else, if N is greater than equal to 130, output

159
00:11:43,080 --> 00:11:43,440
Yes.

160
00:11:43,860 --> 00:11:51,570
If it is no, then use a brute force technique to check whether these four numbers are possible or

161
00:11:51,840 --> 00:11:52,300
not.

162
00:11:52,320 --> 00:11:52,650
OK.

163
00:11:53,280 --> 00:11:55,110
That's what you're going to do.

164
00:11:55,380 --> 00:11:57,540
So that's all for this lecture.

165
00:11:57,540 --> 00:11:59,550
I hope you understood the solution.

166
00:12:00,170 --> 00:12:00,730
And that's it.

