1
00:00:01,170 --> 00:00:06,570
One of the important topics to know about this is a type conversion, once you start to know that there

2
00:00:06,570 --> 00:00:12,510
is the intent, there is a fluid and there is a double long double signed and signed worth about the

3
00:00:12,510 --> 00:00:13,450
type conversions.

4
00:00:14,070 --> 00:00:19,770
So there are two type conversions, what we call implicit and explicit implicit is happening behind

5
00:00:19,770 --> 00:00:20,300
the scene.

6
00:00:20,310 --> 00:00:21,540
And it's very risky.

7
00:00:21,540 --> 00:00:27,510
If you don't understand it, if you if you are defining a boolean status here and assigning it some

8
00:00:27,510 --> 00:00:27,950
value.

9
00:00:28,200 --> 00:00:33,150
So where you're assigning any to your value, but this is boolean, then an implicit conversion has

10
00:00:33,150 --> 00:00:35,870
to happen from an integer to a bullet.

11
00:00:36,180 --> 00:00:39,810
If you put the value like a positive or negative, it would be eventually true.

12
00:00:40,110 --> 00:00:44,400
The only case for a conversion in Boolean to be false is to assign the value zero.

13
00:00:44,520 --> 00:00:45,820
Otherwise it would be true.

14
00:00:46,200 --> 00:00:49,260
Some guys might have the impression that the negative value would give false.

15
00:00:49,270 --> 00:00:50,040
But this is wrong.

16
00:00:51,060 --> 00:00:54,450
Let's say you have something like a double salary here with one hundred point six.

17
00:00:54,900 --> 00:00:57,920
If you try to put it in integer, you are going to lose the point.

18
00:00:58,230 --> 00:00:59,160
This is what we know.

19
00:01:00,710 --> 00:01:09,020
What if we try to put something else like what if we try to put something like an integer inside a shortage

20
00:01:09,030 --> 00:01:13,540
that you should expect most of the time to get and overflow?

21
00:01:13,730 --> 00:01:16,790
And in our case here, it will not happen because just a hundred something.

22
00:01:17,000 --> 00:01:21,230
But let's say that the Senate is 100000, then this is going to make an overflow.

23
00:01:21,290 --> 00:01:23,060
So you you have to be careful about that.

24
00:01:23,930 --> 00:01:26,510
There's an interesting thing that you would not be able to understand.

25
00:01:26,510 --> 00:01:28,070
It's Internet at the moment.

26
00:01:28,340 --> 00:01:35,090
If you if you declared insane character blood to read the value of minus one, this will be its actual

27
00:01:35,090 --> 00:01:36,860
value would be two hundred fifty five.

28
00:01:37,040 --> 00:01:42,020
So this is a bit special, relevant to the very deep representation of the bits.

29
00:01:42,620 --> 00:01:43,680
So let's just give it the one.

30
00:01:43,680 --> 00:01:45,440
But I wanted you to know about this information.

31
00:01:48,150 --> 00:01:54,020
If you if you try to cast something to something, I probably will face the corruption in the value.

32
00:01:54,230 --> 00:01:59,770
For example, if you have seen it to get X negative 100 and it was assigned to unsign the variable,

33
00:01:59,930 --> 00:02:00,680
this is negative.

34
00:02:00,860 --> 00:02:02,040
So this is underflow.

35
00:02:02,180 --> 00:02:03,380
So it will cause a problem.

36
00:02:06,020 --> 00:02:12,840
In C++, what we call promotion, if it happened that you have an exhibition that have mix of data types,

37
00:02:13,140 --> 00:02:18,080
so C++ have some rules to handle that they have what we call a promotion.

38
00:02:18,090 --> 00:02:19,020
We have this list.

39
00:02:19,200 --> 00:02:21,540
And and this order is very important.

40
00:02:22,000 --> 00:02:31,770
If we have a mix of data types that C++ is going to find the end, then I have to say that the one that

41
00:02:31,770 --> 00:02:38,070
is coming from the lower that exists of them, for example, does the expression, let's say the exhibition

42
00:02:38,070 --> 00:02:40,050
has integer and unsigned, long and double.

43
00:02:40,410 --> 00:02:42,630
C++ is going to start from the eleven.

44
00:02:42,760 --> 00:02:47,210
Does it have longer does it have bubblicious convert everything to double?

45
00:02:48,000 --> 00:02:53,010
So let's say here integer, unsigned, long, long and so to integrating int it started for me.

46
00:02:53,020 --> 00:02:54,720
Do we have a long double double.

47
00:02:54,720 --> 00:02:55,860
No fluid.

48
00:02:55,860 --> 00:02:57,870
No unsigned longlong.

49
00:02:57,870 --> 00:02:58,260
Yes.

50
00:02:58,440 --> 00:03:01,740
Convert everything in this equation to unsigned longlong.

51
00:03:01,950 --> 00:03:09,120
So the way that C++ is handling an exhibition that involve a different data types is converting all

52
00:03:09,120 --> 00:03:14,010
of them to one in this list starting from the end the to the beginning.

53
00:03:15,300 --> 00:03:20,950
But, but notes that there might be a lot of corruption in the data that might happen from here.

54
00:03:21,270 --> 00:03:27,330
So every time you have an expression that have mixed set of data types, think twice and you have to

55
00:03:27,330 --> 00:03:30,780
remember this list and you have to remember what's going to happen behind the scene.

56
00:03:31,380 --> 00:03:33,300
You might wonder why you have this list.

57
00:03:33,300 --> 00:03:36,750
If you have interest to read about the logic, you might check this link.

58
00:03:36,990 --> 00:03:38,100
It might be useful to have that.

59
00:03:40,280 --> 00:03:43,110
Let's do some good if we bring 20, minus 30.

60
00:03:43,130 --> 00:03:44,200
This is very normal.

61
00:03:44,240 --> 00:03:48,110
There is no implicit conversion into your mind fear.

62
00:03:48,740 --> 00:03:55,280
But if you try to have an insight into your MBA was 20 and 30 as of them, this will not work.

63
00:03:55,970 --> 00:03:56,990
There's no conversion here.

64
00:03:56,990 --> 00:03:58,430
But I'm warning you from that.

65
00:03:58,910 --> 00:04:00,970
Let's say we have the financial or the excuse.

66
00:04:00,990 --> 00:04:08,310
Then if you say X plus 90, remember, the type of 90 is going to be searched among end and long and

67
00:04:08,360 --> 00:04:08,890
long, long.

68
00:04:09,080 --> 00:04:10,560
So 90 would be long.

69
00:04:10,880 --> 00:04:12,460
So it would be no shorter plus.

70
00:04:12,500 --> 00:04:14,290
Long story, short end.

71
00:04:14,750 --> 00:04:17,920
So this is going to be the X is going to be converted to a..

72
00:04:18,770 --> 00:04:25,460
If I have something like X plus 85 plus five point one, all of the all of the expression here would

73
00:04:25,460 --> 00:04:26,400
be handled as a double.

74
00:04:26,570 --> 00:04:31,900
So this one would be handled as double and this one would be handled as double if you tried to bring

75
00:04:31,910 --> 00:04:33,430
the two million plus two million.

76
00:04:33,710 --> 00:04:35,230
This is going to overflow.

77
00:04:35,810 --> 00:04:42,200
But if you added here Longlong, for example, in this part, then this out of these two sides is going

78
00:04:42,200 --> 00:04:44,210
to or this is longlong so agreed.

79
00:04:44,210 --> 00:04:48,550
This one, too, also to look at them, but into familiar as longlong.

80
00:04:48,980 --> 00:04:56,330
So be careful if you have such equidistance, it's Aliette like prefers to put suffix literals here

81
00:04:56,510 --> 00:04:59,000
to facilitate the printing in a similar way.

82
00:04:59,000 --> 00:05:02,740
You can take this submission to Z if you would like to have it in a variable.

83
00:05:03,770 --> 00:05:04,690
It is one more thing.

84
00:05:04,970 --> 00:05:10,100
Let's define longlong d as some longlong maximum even minus something.

85
00:05:10,310 --> 00:05:11,230
So far so good.

86
00:05:11,840 --> 00:05:17,540
If we try to do one minus zero point zero, this one is going to be converted to double and the one

87
00:05:17,540 --> 00:05:19,540
minus hundred is going to be converted to double.

88
00:05:19,850 --> 00:05:23,540
Surprisingly, when you try to break the both of them, they might be equal.

89
00:05:23,780 --> 00:05:27,980
And the reason behind that is the double has a precision on average of 15.

90
00:05:28,190 --> 00:05:31,180
So it might fail to handle something like Longlong.

91
00:05:31,430 --> 00:05:32,420
So be careful from that.

92
00:05:33,050 --> 00:05:34,420
It is one more interesting thing.

93
00:05:34,910 --> 00:05:39,020
Let's say we have character C character Max, which is now one hundred twenty seven.

94
00:05:39,560 --> 00:05:44,720
Remember the character Max is moving from minus one hundred twenty eight to one hundred twenty seven.

95
00:05:45,290 --> 00:05:48,400
If you add see it should be No.

96
00:05:48,410 --> 00:05:52,240
Two fifty four which is beyond the character limit.

97
00:05:52,820 --> 00:05:54,170
So it's going to be overflow.

98
00:05:54,290 --> 00:06:02,510
Surprisingly it will not y because C++ do a direct promotion for short values and character values to

99
00:06:04,100 --> 00:06:06,280
to integer or translate into other divisions.

100
00:06:06,440 --> 00:06:09,260
So if it's character or short it will be upgraded to integer.

101
00:06:09,560 --> 00:06:16,850
And if it is unsigned, the short or the character or circular, it will be upgraded to unsigned character

102
00:06:16,850 --> 00:06:17,530
and unsigned short.

103
00:06:18,050 --> 00:06:24,370
So the moral of that is there will be an upgrading for this value even before the competition.

104
00:06:24,740 --> 00:06:26,610
So this is kind of an exception to the rule.

105
00:06:26,780 --> 00:06:28,700
So this will not overflow, as you expect.

106
00:06:30,480 --> 00:06:36,450
A few tips, remember that unsigned integer can be very problematic, so be very careful, something

107
00:06:36,450 --> 00:06:41,640
like X minus Y, if the result is negative, the results will be corrupted in the convergence, like

108
00:06:41,640 --> 00:06:45,780
some integer would be converted to unsigned the entire there would be corruption.

109
00:06:45,960 --> 00:06:49,500
So you sign the integers unless there is a good reason for that.

110
00:06:51,160 --> 00:06:56,890
There's also what we call an explicit conversion here you are converting by yourself and C++ provide

111
00:06:56,890 --> 00:07:01,190
you with several ways to cast, including the old sea styles.

112
00:07:01,450 --> 00:07:06,120
So in the old cystine, if you have something like Xixi to integrate this way or cost it to integrate

113
00:07:06,130 --> 00:07:10,630
this way, I would be using this site all the time to avoid using this style.

114
00:07:10,630 --> 00:07:17,830
But although it is OK in in the normal custom here, so the proper way that people like more is what

115
00:07:17,830 --> 00:07:26,530
we call the static custom C++ like a static cost of index that the static cost is going to as you see

116
00:07:26,530 --> 00:07:29,170
when you read it here, it give clearly the intention.

117
00:07:29,180 --> 00:07:29,940
What do you want to do?

118
00:07:30,340 --> 00:07:35,260
Clearly you are saying, I would like to also associate a good forecasting.

119
00:07:35,260 --> 00:07:37,260
It would be easier than searching for the code here.

120
00:07:37,510 --> 00:07:38,830
I think Zober in both of them.

121
00:07:38,830 --> 00:07:41,060
But searching the code for this one is easier.

122
00:07:41,590 --> 00:07:46,930
The advantage in the static cost, if you are trying to do something wrong, encaustic like with pointers,

123
00:07:47,290 --> 00:07:50,400
the static cost will dictate in the completion error.

124
00:07:50,620 --> 00:07:54,640
For example, let's say you have character see here and you have a pointer here.

125
00:07:55,180 --> 00:07:59,730
If you try to come to the character, see to integrate pointer, it would work well.

126
00:08:00,280 --> 00:08:02,080
But if you try to offset the cost, it will.

127
00:08:02,080 --> 00:08:03,310
Koblin Why?

128
00:08:03,640 --> 00:08:06,820
Because character is just one byte and integrities for byte.

129
00:08:06,820 --> 00:08:09,340
You cannot make such a conversion in the memory.

130
00:08:09,850 --> 00:08:14,830
So the good about the static cost, especially when it comes to Beutler's, it can help you with this

131
00:08:14,830 --> 00:08:15,280
competition.

132
00:08:15,700 --> 00:08:20,980
So please try to push more yourself to use a static cost, at least if you are trying to use pointers.

133
00:08:21,640 --> 00:08:22,990
There is also other modifiers.

134
00:08:22,990 --> 00:08:28,980
In C++, for example, the code is the cost because the cost can remove the code to modify it.

135
00:08:29,410 --> 00:08:30,400
Please don't do that.

136
00:08:30,400 --> 00:08:33,790
Like this is something that we use in a very, very exceptional cases.

137
00:08:33,790 --> 00:08:34,360
Don't do that.

138
00:08:34,870 --> 00:08:40,870
There is also the reinterpret cost which can cost whatever integer point or whatever waterpipe to another

139
00:08:40,870 --> 00:08:41,110
time.

140
00:08:41,590 --> 00:08:42,690
Again, we do not do that.

141
00:08:42,970 --> 00:08:45,070
So what we use is typically static cost.

142
00:08:45,460 --> 00:08:46,390
That is something good.

143
00:08:47,200 --> 00:08:48,580
Something as psychodynamics.

144
00:08:48,580 --> 00:08:50,500
We will see, we'll see in the Olby.

145
00:08:50,710 --> 00:08:54,100
But for now this is explicit costing the sties.

146
00:08:55,680 --> 00:08:56,250
Your turn.

147
00:08:56,280 --> 00:08:59,210
I would like you to read this program and guess the output of it.

148
00:09:01,510 --> 00:09:06,910
OK, so the first thing in the orbit of this program is is going to bring to this very big number.

149
00:09:07,150 --> 00:09:10,150
This is very surprisingly, the victor is empty.

150
00:09:10,360 --> 00:09:12,980
So the size is zero zero minus one is zero.

151
00:09:13,030 --> 00:09:13,690
What happened?

152
00:09:13,700 --> 00:09:15,310
That's why you have such a big number.

153
00:09:16,210 --> 00:09:23,080
The reason is the function size is returning what we call our size and our security, which eventually

154
00:09:23,080 --> 00:09:26,800
is just unsign the number either outside of India or inside the globe.

155
00:09:27,310 --> 00:09:33,060
The problem here is if we have zero minus one, then zero zero is unsigned.

156
00:09:33,310 --> 00:09:35,480
So this expression would be converted to inside.

157
00:09:35,860 --> 00:09:42,270
And as it is negative, one is going to be underflow to such a very big value as a result.

158
00:09:42,700 --> 00:09:48,940
This for Lub here is going to work for infinity because this is very big value.

159
00:09:49,270 --> 00:09:55,540
The right way to be more severe is to Casta the vector, the size or any size coming from Israel to

160
00:09:55,540 --> 00:09:56,980
integrate here is more.

161
00:09:57,940 --> 00:10:04,960
Practically speaking, the size says the security was used because it might be the vector is very huge,

162
00:10:04,960 --> 00:10:06,710
but this is actually very, very, very rare.

163
00:10:06,970 --> 00:10:10,370
So it is more severe to discuss it, to integrate here and just walk over it.

164
00:10:10,900 --> 00:10:13,600
So anyway, be careful from such a such a minus one.

165
00:10:16,870 --> 00:10:17,290
Yeah.

166
00:10:17,710 --> 00:10:18,400
As a trick.

167
00:10:18,400 --> 00:10:22,710
If you would like to avoid the custom, you can take this minus one and plus one here.

168
00:10:22,720 --> 00:10:25,660
So it's no wonder Zadvydas says it would not make a problem.

169
00:10:25,660 --> 00:10:28,360
Even if it did, it cost the city.
