0
1
00:00:01,230 --> 00:00:06,930
The next function is about replacing substring, you would like to take this input string and this pattern,
1

2
00:00:06,930 --> 00:00:09,030
every time you see the pattern, you replace it.
2

3
00:00:09,330 --> 00:00:14,010
But this example here is giving us an important message we see here three 'aaa'.
3

4
00:00:14,040 --> 00:00:20,700
One might ask, should I replace this 'aa' and this 'aa' from the example? No.  This 'aa' would be completely
4

5
00:00:20,700 --> 00:00:22,140
replaced by four A's.
5

6
00:00:22,620 --> 00:00:26,430
Then the remaining 'a' would be just added here because there is no match.
6

7
00:00:27,510 --> 00:00:33,420
And sometimes when we would like to develop a function, we can notice that we can develop other functions
7

8
00:00:33,420 --> 00:00:34,740
that make our life easier.
8

9
00:00:35,040 --> 00:00:41,310
An example here 'starts_with'  function which just checks if the string input at this position
9

10
00:00:41,310 --> 00:00:42,480
has this pattern or not.
10

11
00:00:42,780 --> 00:00:45,570
So let's see first how to make use of this function, how to write it.
11

12
00:00:46,650 --> 00:00:48,090
The 'starts_with' takes 
12

13
00:00:48,090 --> 00:00:53,610
the input pattern and position. There is an early condition here that says if the position plus pattern size is 
13

14
00:00:53,610 --> 00:00:55,910
greater than input, then no way to find it.
14

15
00:00:55,920 --> 00:00:56,520
Why?
15

16
00:00:56,820 --> 00:00:57,930
Here's a simple example.
16

17
00:00:58,320 --> 00:01:00,840
Let's say we have this string of five letters.
17

18
00:01:01,350 --> 00:01:03,570
If I give you position like three.
18

19
00:01:04,600 --> 00:01:10,090
Now, three plus the pattern, which is 2 is 5. Is 5 greater than five? false.
19

20
00:01:10,450 --> 00:01:14,470
Which means we can match this string here, maybe.
20

21
00:01:15,010 --> 00:01:17,950
Now, what if the position is 4? When you look to it
21

22
00:01:18,490 --> 00:01:20,980
the remaining is only a single letter, and this is two letters.
22

23
00:01:21,190 --> 00:01:24,100
So there is no way that this one would match it.
23

24
00:01:24,460 --> 00:01:25,660
This is what the condition is
24

25
00:01:25,660 --> 00:01:33,490
meaning. If the pattern needs to go beyond the current string, then there is no way there is a match.
25

26
00:01:33,880 --> 00:01:35,080
Now, what if there is a match?
26

27
00:01:36,310 --> 00:01:41,930
We start to compare the input string from this position comparing to the
27

28
00:01:41,950 --> 00:01:45,970
first character of the pattern, for example, let's say the position is three.
28

29
00:01:46,510 --> 00:01:53,500
Now we compare pattern of zero, which is 'a' with this input of three
29

30
00:01:53,500 --> 00:01:55,690
which is this 'a', correct?
30

31
00:01:55,720 --> 00:01:56,150
Yes.
31

32
00:01:56,200 --> 00:01:57,250
Move to the next letter.
32

33
00:01:57,490 --> 00:02:02,230
Compare the pattern of one with the position of four, which is 'a', correct?
33

34
00:02:02,260 --> 00:02:02,680
Yes.
34

35
00:02:03,070 --> 00:02:10,630
If the loop ended here, it simply means we had a match for a complete pattern from the begin with
35

36
00:02:10,630 --> 00:02:13,420
the given string, that simple.
36

37
00:02:13,960 --> 00:02:16,390
So now we have a start function that can help us.
37

38
00:02:16,960 --> 00:02:19,000
The function here now is very simple.
38

39
00:02:19,330 --> 00:02:23,350
It says as following: iterate on the input string step by step.
39

40
00:02:24,590 --> 00:02:27,950
In the early of every string, we would make a check.
40

41
00:02:28,340 --> 00:02:32,960
Does the current string start with the pattern here?
41

42
00:02:33,170 --> 00:02:35,870
If yes, we replace it with the 2 patterns.
42

43
00:02:36,410 --> 00:02:37,800
Otherwise, we keep going.
43

44
00:02:38,240 --> 00:02:41,090
If yes, we add to the result, the whole pattern.
44

45
00:02:41,630 --> 00:02:44,780
And then we jump after the pattern size.
45

46
00:02:46,010 --> 00:02:47,670
Otherwise, we add the current result.
46

47
00:02:48,020 --> 00:02:49,040
Let's see an example.
47

48
00:02:50,450 --> 00:02:53,540
Let's say the pattern is 'xxxx'.
48

49
00:02:54,500 --> 00:03:02,690
Now we go at the first character and say, does this string start with 'aa' from position zero?
49

50
00:03:02,690 --> 00:03:04,730
'aa' from position zero?
50

51
00:03:05,750 --> 00:03:08,840
Let's pretend that there is an 'f' or 'd' here.
51

52
00:03:09,470 --> 00:03:11,090
Does it start with 'aa'?
52

53
00:03:11,120 --> 00:03:11,960
The answer is no.
53

54
00:03:12,230 --> 00:03:14,440
So we append here in the result the character 'd'.
54

55
00:03:16,610 --> 00:03:18,890
Now, after that, we go to position equal one.
55

56
00:03:18,890 --> 00:03:21,740
When does it start with 'aa'?
56

57
00:03:22,010 --> 00:03:22,640
Yes.
57

58
00:03:23,450 --> 00:03:32,720
So first we append there is 'xxx' here to the number, and then we move the position with the
58

59
00:03:32,720 --> 00:03:34,130
size of the pattern minus one.
59

60
00:03:34,520 --> 00:03:38,210
The size of the pattern is two,  two minus one is one.
60

61
00:03:38,390 --> 00:03:40,160
So we jump it to
61

62
00:03:40,520 --> 00:03:41,480
we were at position
62

63
00:03:41,480 --> 00:03:42,260
One was one.
63

64
00:03:42,590 --> 00:03:47,120
We jumped here at....,  let me double check.
64

65
00:03:47,390 --> 00:03:48,680
We have here one.
65

66
00:03:49,040 --> 00:03:51,860
And then plus one is two.
66

67
00:03:52,100 --> 00:03:54,260
So we are this 'a'.
67

68
00:03:57,940 --> 00:04:01,790
I have an impression that this minus one shouldn't be put, let me 
68

69
00:04:04,600 --> 00:04:09,560
double-check, position equals zero; we add it and move now....,
69

70
00:04:10,390 --> 00:04:12,220
Oh, there is an extra plus here.
70

71
00:04:12,850 --> 00:04:16,990
OK, so this minus one is actually corresponding to this plus plus here.
71

72
00:04:17,260 --> 00:04:20,410
So here is the logic we would like to.
72

73
00:04:20,470 --> 00:04:26,470
The logic is if we replaced the current pattern, let's say the pattern is five characters.
73

74
00:04:27,370 --> 00:04:34,030
Now, if we replace the five characters, for example, we would like to jump after the five characters.
74

75
00:04:34,300 --> 00:04:36,580
So we should actually say position plus equal five.
75

76
00:04:37,060 --> 00:04:37,570
But I'm here 
76

77
00:04:37,570 --> 00:04:41,260
saying position plus equal four because there is an extra plus plus here.
77

78
00:04:41,350 --> 00:04:41,740
OK.
78

79
00:04:42,460 --> 00:04:43,780
Which made the code for a while
79

80
00:04:43,780 --> 00:04:44,950
not that understandable.
80

81
00:04:45,160 --> 00:04:52,420
But if I would rewrite this code to be better nicer, I would remove this minus one here
81

82
00:04:52,660 --> 00:04:55,270
and add a position plus plus here.
82

83
00:04:56,470 --> 00:04:57,580
Anyway, let's go back.
83

84
00:04:57,790 --> 00:05:00,820
We were at letter index one.
84

85
00:05:01,210 --> 00:05:01,960
Does it match 'aa' ?
85

86
00:05:02,500 --> 00:05:03,280
Yes, it match.
86

87
00:05:03,520 --> 00:05:05,110
Then we added four X's.
87

88
00:05:05,380 --> 00:05:07,810
Then we jumped two steps.
88

89
00:05:08,020 --> 00:05:09,700
So we jump at letter 'b'.
89

90
00:05:10,300 --> 00:05:13,360
Now, does 'ba' match 'aa'?
90

91
00:05:13,870 --> 00:05:14,800
The answer is no.
91

92
00:05:15,010 --> 00:05:16,450
So we add 'b' to the result.
92

93
00:05:17,230 --> 00:05:19,760
Then we say does 'aa' match 'aa'?
93

94
00:05:20,170 --> 00:05:23,200
Yes, we add another 'xxxx'.
94

95
00:05:23,530 --> 00:05:28,390
Then we jump after it two steps and then the string is ended.
95

96
00:05:28,720 --> 00:05:34,060
So this way, the overall result is computed.
96

97
00:05:35,650 --> 00:05:43,240
The major lesson here that I would like you to get it that sometimes with having such utilities
97

98
00:05:43,300 --> 00:05:44,560
your life is much easier.
98

99
00:05:44,890 --> 00:05:48,400
Sometimes you need to decompose your program to different parts
99

100
00:05:48,460 --> 00:05:51,790
that would make the processing overall is easy and adorable. 
100

101
00:05:52,180 --> 00:05:52,660
That's all.
