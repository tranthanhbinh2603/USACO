0
1
00:00:00,930 --> 00:00:08,940
In this video, we will learn more about some variations in the functions, the first thing is
1

2
00:00:09,420 --> 00:00:11,630
looking to this function
2

3
00:00:11,640 --> 00:00:11,850
"lucky_number".
3

4
00:00:11,880 --> 00:00:14,080
This function has no parameters,
4

5
00:00:14,100 --> 00:00:15,620
We already saw this before.
5

6
00:00:15,990 --> 00:00:20,220
So the lucky number is a function that has a return but doesn't have a parameter.
6

7
00:00:20,760 --> 00:00:26,700
We can also have here, you see function main2(), but this isn't what the compiler is going to call, the
7

8
00:00:26,700 --> 00:00:28,500
compiler will call the function main().
8

9
00:00:29,040 --> 00:00:32,050
There is a third case that is very interesting,
9

10
00:00:32,340 --> 00:00:35,800
This function has two parameters "a" and "b", and it is going to print them.
10

11
00:00:36,300 --> 00:00:41,580
But what if you don't want to return something from a function that just doing something like printing?
11

12
00:00:41,820 --> 00:00:44,150
In this case we use the word "void",
12

13
00:00:44,180 --> 00:00:50,370
"void" means empty, we use the word void and we return nothing from here, so we can have a function
13

14
00:00:50,370 --> 00:00:51,320
without parameters,
14

15
00:00:51,570 --> 00:00:54,500
We can have a function that doesn't return something.
15

16
00:00:55,560 --> 00:00:56,280
What else?
16

17
00:00:56,520 --> 00:01:00,930
There is something very interesting in C++ called the default values.
17

18
00:01:01,230 --> 00:01:07,500
The default values is when you provide some default values for the parameters.
18

19
00:01:07,500 --> 00:01:12,390
If you use the parameter, it is using your current value otherwise it is using the default value.
19

20
00:01:12,870 --> 00:01:18,840
For now, let's first see the "our_pow" function, let's say, it is integer n, Integer b and just braces, forget
20

21
00:01:18,840 --> 00:01:19,890
about = 3 here.
21

22
00:01:20,500 --> 00:01:22,310
Then this is our normal function,
22

23
00:01:22,530 --> 00:01:30,090
We take result with 1, we go p steps and we multiply with *n and the result is done we return
23

24
00:01:30,170 --> 00:01:30,630
the result.
24

25
00:01:31,170 --> 00:01:33,210
Now I'm giving here something, say
25

26
00:01:33,300 --> 00:01:34,960
Int p = 3.
26

27
00:01:35,580 --> 00:01:38,620
Now look at the main here we are calling the function once
27

28
00:01:38,620 --> 00:01:39,240
with 2,
28

29
00:01:39,570 --> 00:01:42,580
If we are calling with 2, then this 2 goes to the n.
29

30
00:01:43,080 --> 00:01:47,270
What about the p? the p takes the default value which is here 3.
30

31
00:01:47,670 --> 00:01:50,280
Otherwise I'm calling with 2 and 3, and 2 and 4,
31

32
00:01:50,520 --> 00:01:54,850
So the p here will be 3 and the p in this case will be 4.
32

33
00:01:55,080 --> 00:01:57,250
This is what we call default value.
33

34
00:01:57,420 --> 00:02:02,250
So if you didn't set p, is going to be set as a default value.
34

35
00:02:03,230 --> 00:02:05,640
Please notice the following,
35

36
00:02:05,930 --> 00:02:13,460
The first is if you decided to use a variable with default value, the variables after it or parameters
36

37
00:02:13,760 --> 00:02:15,350
must have also default values.
37

38
00:02:15,570 --> 00:02:21,200
For example, you cannot have a function like the following, "int a", "int b = 2",
38

39
00:02:21,200 --> 00:02:26,460
"int c", once you defined a default value, all the values after it must be default values.
39

40
00:02:26,750 --> 00:02:27,500
Think about it.
40

41
00:02:27,650 --> 00:02:32,250
The compiler will not be able to know what to assign, which is b, which is c,
41

42
00:02:32,790 --> 00:02:34,390
OK. so how to do it,
42

43
00:02:34,410 --> 00:02:38,510
It can be "int c = 3" or you define default value for b and c,
43

44
00:02:39,020 --> 00:02:44,690
OK. and definitely we can have several default values, like "int a, int b = 2",
44

45
00:02:44,700 --> 00:02:46,330
"int c = 3"
45

46
00:02:46,700 --> 00:02:48,140
So be careful about that.
46

47
00:02:48,320 --> 00:02:49,160
It isn't a mistake,
47

48
00:02:49,160 --> 00:02:50,990
It's like more of a compiler error.
48

49
00:02:50,990 --> 00:02:53,090
The compiler will not allow you to do that.
49

50
00:02:55,390 --> 00:03:01,780
Casting, casting is interesting here in functions, so be careful about it. this function "add" has
50

51
00:03:01,780 --> 00:03:06,430
an "int a" and an "int b", we called it with integer a, integer b, so far so good.
51

52
00:03:06,700 --> 00:03:13,150
But what if we called with 2 and 3.5, a casting will happen, so 3.5 will
52

53
00:03:13,150 --> 00:03:16,020
be converted to an integer, so it would be 3 also.
53

54
00:03:16,240 --> 00:03:21,110
So be careful with function that allows casting this way.
54

55
00:03:22,540 --> 00:03:29,050
The last thing here to mention is the "overloading", overloading is a very critical concept in C++.
55

56
00:03:29,380 --> 00:03:34,160
Overloading happens when we have several functions who have the same name.
56

57
00:03:34,630 --> 00:03:36,280
For example, you are calling here
57

58
00:03:36,490 --> 00:03:38,710
"add" and "add", we have here 3 functions
58

59
00:03:38,710 --> 00:03:45,670
Each one of them is called "add", now how the compiler will differentiate what you are calling,
59

60
00:03:45,940 --> 00:03:47,020
by the parameters.
60

61
00:03:47,020 --> 00:03:52,350
Are you using different parameters or not, either as a data type, or even as a number of parameters.
61

62
00:03:52,570 --> 00:03:54,310
So here we say "int add",
62

63
00:03:54,310 --> 00:03:56,680
that takes int, int.
63

64
00:03:57,010 --> 00:03:58,350
Is this different from this one?
64

65
00:03:58,360 --> 00:04:00,040
Yes, because it has double and double.
65

66
00:04:00,380 --> 00:04:01,570
Is this different from this one?
66

67
00:04:01,580 --> 00:04:04,570
Yes, because it has three integers, but you only have two integers.
67

68
00:04:04,870 --> 00:04:12,040
So function overloading is when you have several functions with same name, but they have different
68

69
00:04:12,040 --> 00:04:12,670
parameters,
69

70
00:04:12,700 --> 00:04:19,240
OK. notice here, the return isn't considered, like you cannot say "add(int a, int b)" returning integer, and
70

71
00:04:19,480 --> 00:04:23,620
"add(int a, int b)" returning double, the return isn't considered.
71

72
00:04:23,860 --> 00:04:26,890
What is considered is only the parameters.
72

73
00:04:27,130 --> 00:04:29,350
OK, how the compiler differentiate?
73

74
00:04:29,350 --> 00:04:35,490
If you called here 2 and 3, it's going to find which one is the most suitable for your function call
74

75
00:04:35,500 --> 00:04:40,870
which is here 2 and 3, if you call 2.0 and 3.5 is going to call this one because
75

76
00:04:40,870 --> 00:04:42,250
it's most useful.
76

77
00:04:42,370 --> 00:04:45,850
If you called "add(1, 2, 3)" is going to name this one.
77

78
00:04:45,970 --> 00:04:51,880
So this is how you can think logically, how the compiler can differentiate which one to give a call.
78

79
00:04:52,390 --> 00:04:52,940
That's it.
