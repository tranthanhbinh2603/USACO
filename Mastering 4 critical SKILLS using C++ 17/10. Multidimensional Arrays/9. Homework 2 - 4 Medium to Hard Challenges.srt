0
1
00:00:01,020 --> 00:00:07,860
The second homework set, in problem number one, we will read a matrix N times M and Q for
1

2
00:00:07,930 --> 00:00:08,520
Q queries.
2

3
00:00:08,850 --> 00:00:16,020
Each query is four values two indices I and G zero-based and number of rows and number of columns.
3

4
00:00:16,260 --> 00:00:23,910
These four values actually representing a sub-matrix with (i.j) are the top left of it and  then (r ,c) are the numbers of rows
4

5
00:00:23,910 --> 00:00:30,600
and columns starting from this (i, g) for each query we would like to print how many prime numbers in the
5

6
00:00:30,600 --> 00:00:33,690
requested grid or in the requested sub-matrix,
6

7
00:00:34,170 --> 00:00:40,200
each query should be answered using only nested loops and maximum not more so don't make more than
7

8
00:00:40,200 --> 00:00:41,100
two nested loops
8

9
00:00:41,100 --> 00:00:41,820
per a query.
9

10
00:00:42,740 --> 00:00:48,500
per a query. In the future, with some smart competition, you will learn how to do that even without
10

11
00:00:48,500 --> 00:00:55,200
any nested loops in the queering part itself, in computer vision filed we call that image integral.
11

12
00:00:55,220 --> 00:00:56,820
But this is just feature information for you.
12

13
00:00:57,410 --> 00:00:59,290
Let's see an example, here
13

14
00:00:59,300 --> 00:01:02,720
we read The Matrix three times four, three row, four columns,
14

15
00:01:03,050 --> 00:01:08,190
then in the first query, we add starting position, row number one, column number zero,
15

16
00:01:08,480 --> 00:01:13,520
so this is row number one, column number zero, and two-two matrix, which is now covering this matrix
16

17
00:01:13,520 --> 00:01:14,660
three, two, seven, eight.
17

18
00:01:15,140 --> 00:01:18,950
The number of primes here are three, which are the three and two and seven,
18

19
00:01:18,950 --> 00:01:21,770
eight is a prime number in a very similar way,
19

20
00:01:21,990 --> 00:01:23,000
zero one, two, three,
20

21
00:01:23,030 --> 00:01:28,160
there are three primes, the two and the five and two, even the duplication are considered.
21

22
00:01:28,460 --> 00:01:31,220
So this is mainly what you need to do, in every query
22

23
00:01:31,250 --> 00:01:34,730
you should only make two nested loops maximum to answer the query.
23

24
00:01:36,270 --> 00:01:42,960
If this is a hard constraint for you, skip it for now. In the second problem would like to find mountains
24

25
00:01:43,530 --> 00:01:44,270
in a matrix.
25

26
00:01:44,280 --> 00:01:47,880
You will read a Matrix and you print all the positions that are mountain.
26

27
00:01:48,300 --> 00:01:54,990
A mountain is a position that its value is greater than the eight neighbor values.
27

28
00:01:55,140 --> 00:02:01,920
Code that in a smart way as we learned, for example, here you will notice that position (zero, zero)
28

29
00:02:01,920 --> 00:02:08,410
is eight, eight is greater than six and two and three, which are the three valid neighbors for it,
29

30
00:02:08,430 --> 00:02:10,830
so this is a mountain, position (1,2),
30

31
00:02:11,010 --> 00:02:11,940
position (1,2),
31

32
00:02:11,940 --> 00:02:12,690
is nine,
32

33
00:02:12,870 --> 00:02:17,040
Nine is greater than one and six and two and six and four.
33

34
00:02:18,450 --> 00:02:24,060
in the third problem, you have an active robot, we have a grid of N times M, and there is
34

35
00:02:24,060 --> 00:02:26,010
a robot starting at position (0, 0),
35

36
00:02:26,010 --> 00:02:28,770
you will read K commands,
36

37
00:02:29,130 --> 00:02:31,020
Every command has two values.
37

38
00:02:31,260 --> 00:02:36,780
The first one is a direction from one to four corresponding to up, right, down, and left.
38

39
00:02:37,650 --> 00:02:42,030
And then you read a number of steps, which would be the number of steps the robot will take in
39

40
00:02:42,030 --> 00:02:42,990
this direction.
40

41
00:02:43,140 --> 00:02:44,970
The steps can be huge.
41

42
00:02:45,420 --> 00:02:50,780
If the robot hits the wall, it just circulate in the Matrix. for every
42

43
00:02:50,790 --> 00:02:52,650
command print where is the robot now.
43

44
00:02:52,770 --> 00:02:58,440
So it is the input, we have a matrix of three, four dimensions and we have four commands,
44

45
00:02:58,680 --> 00:03:00,450
the first command is two and one,
45

46
00:03:00,630 --> 00:03:03,690
two means move to the right,
46

47
00:03:03,690 --> 00:03:05,040
You see here, one is up.
47

48
00:03:05,100 --> 00:03:05,880
Two is right.
48

49
00:03:06,060 --> 00:03:07,650
Three is down, four is left.
49

50
00:03:07,920 --> 00:03:09,960
So two is is right.
50

51
00:03:10,110 --> 00:03:10,740
One step.
51

52
00:03:11,820 --> 00:03:12,120
Three.
52

53
00:03:12,120 --> 00:03:12,840
Two means what
53

54
00:03:12,840 --> 00:03:17,110
three is down  two steps and so on.
54

55
00:03:17,130 --> 00:03:18,860
And this is a position that you are printing.
55

56
00:03:18,870 --> 00:03:21,210
Let's say you did this to make it easier for you,
56

57
00:03:21,930 --> 00:03:26,460
the robot has a grid of three times before we start at position (zero, zero)
57

58
00:03:26,820 --> 00:03:28,980
the command is to move right one step,
58

59
00:03:29,160 --> 00:03:34,860
so the robot take right one step, then the robot take a command to move that down two steps,
59

60
00:03:35,010 --> 00:03:37,410
so the robot from here will move one step, two step,
60

61
00:03:37,410 --> 00:03:38,190
now we are here.
61

62
00:03:39,060 --> 00:03:42,420
The robot now have a command of moving left two steps,
62

63
00:03:42,780 --> 00:03:44,640
so this is one step left,
63

64
00:03:44,640 --> 00:03:50,070
but there is a wall here so we circle it back and go to the beginning of the room,
64

65
00:03:50,100 --> 00:03:56,120
so we end up here, then move up three steps, one step up, second step up,
65

66
00:03:56,130 --> 00:03:57,240
we hit the wall again,
66

67
00:03:57,360 --> 00:04:00,870
so circlet back in the column and come back here to this one.
67

68
00:04:00,870 --> 00:04:03,360
I hope the visualization now make it easier for you.
68

69
00:04:04,890 --> 00:04:12,000
You are to print the position where the robot ends with every command. In this problem
69

70
00:04:12,000 --> 00:04:17,280
we will expand the flattening 2D array to 3D array, because I would like you to learn how to
70

71
00:04:17,280 --> 00:04:19,770
think in something like 3D array in flattening
71

72
00:04:19,890 --> 00:04:26,610
if you have to, you will read three numbers for the depth rows and columns, the dimensions of 3D array.
72

73
00:04:27,030 --> 00:04:28,200
then read one integer,
73

74
00:04:28,200 --> 00:04:29,520
it will be one of two cases,
74

75
00:04:29,820 --> 00:04:33,690
if the integer value is one, it means we will convert 3D to 1D,
75

76
00:04:33,930 --> 00:04:37,110
If the value is two, it means you will convert 1D to 3D.
76

77
00:04:37,890 --> 00:04:44,420
If the input was one, you would be provided with three integers, the depth and R&C to convert them to 1D
77

78
00:04:44,430 --> 00:04:44,910
position.
78

79
00:04:45,420 --> 00:04:49,440
If it was two, you will read one integer position, convert it to three D 
79

80
00:04:49,440 --> 00:04:52,050
position. To make it easy for you,
80

81
00:04:52,200 --> 00:04:58,020
here are the three for loops, depth, rows and columns for a grid three times four times five and printing
81

82
00:04:58,020 --> 00:05:01,140
for you the index and the corresponding depth and row and column.
82

83
00:05:01,470 --> 00:05:02,650
And here are a bunch of testcases,
83

84
00:05:02,670 --> 00:05:09,450
for example, three, four, five with a conversion from 3D to 1D, you take three
84

85
00:05:09,450 --> 00:05:15,010
inputs, the output should be twenty if you took twenty, the output should be one (0, 0) and so on.
85

86
00:05:15,390 --> 00:05:20,460
Think about how to generalize the 2D  flattening array. That's all.
