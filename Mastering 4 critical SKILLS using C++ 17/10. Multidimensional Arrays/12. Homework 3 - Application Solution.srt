0
1
00:00:00,950 --> 00:00:06,450
See how to solve the Tic-Tac-Toe problem compared to other courses and materials
1

2
00:00:06,480 --> 00:00:09,570
there are two challenges here. From one side,
2

3
00:00:09,570 --> 00:00:11,700
I don't want you just to make it three times a three.
3

4
00:00:12,210 --> 00:00:17,520
And also I don't want you to, like, just go with the very ugly and a lot of coding to verify the rows,
4

5
00:00:17,520 --> 00:00:18,510
columns and diagonals.
5

6
00:00:18,840 --> 00:00:21,060
These two things might make it a bit challenging for you.
6

7
00:00:21,540 --> 00:00:23,480
So anyway, let's see how to code it.
7

8
00:00:24,120 --> 00:00:27,930
The general flow of the program is as following;
8

9
00:00:28,680 --> 00:00:32,100
we have here a grid that is initially initialized to zeros.
9

10
00:00:32,520 --> 00:00:34,050
Zero means there is nothing here.
10

11
00:00:34,050 --> 00:00:38,370
One means "x" and two means "o" we start with reading the input from the user.
11

12
00:00:38,730 --> 00:00:39,840
Let's skip this for now.
12

13
00:00:40,380 --> 00:00:44,670
Initially, we have the turn was zero for 'x' and then it could be one for 'o'.
13

14
00:00:45,360 --> 00:00:47,630
And let's go.
14

15
00:00:48,150 --> 00:00:49,820
We start with number of steps.
15

16
00:00:49,950 --> 00:00:52,830
Let's say that we have a grid of 'n' equal three.
16

17
00:00:53,400 --> 00:00:59,910
If the user did nine steps, which are three times three, we are sure that the grid is completely
17

18
00:01:00,360 --> 00:01:00,770
filled.
18

19
00:01:01,110 --> 00:01:03,110
And this mean actually we are in a  tie step.
19

20
00:01:03,510 --> 00:01:05,160
So this is my first condition here.
20

21
00:01:05,160 --> 00:01:05,880
Keep going.
21

22
00:01:06,180 --> 00:01:13,440
But if the total number of steps is n*n then the grid is done. And then I decide the symbol
22

23
00:01:13,440 --> 00:01:19,210
of the turn, it could be like initially 'x' and if the turn is 1,  we can switch it to 'o'.
23

24
00:01:19,220 --> 00:01:21,600
OK, there is a more elegant way to do it.
24

25
00:01:21,600 --> 00:01:26,570
You can create a string with letter 'x' and 'o' and based on the turn, you just get it from the string.
25

26
00:01:26,580 --> 00:01:33,510
But I thought to make it simpler here and then we start to ask the user to enter a row and column
26

27
00:01:33,900 --> 00:01:36,150
the user is entering something in one base.
27

28
00:01:36,330 --> 00:01:39,180
Always be careful, so convert first to zero based.
28

29
00:01:39,900 --> 00:01:42,000
After that, we need to verify two things.
29

30
00:01:42,270 --> 00:01:50,400
We need to verify if it is valid location or not, and we need to verify if the cell is empty or not.
30

31
00:01:51,000 --> 00:01:56,700
To verify that the position isn't outside the grid, we need to make sure it is less than the row or
31

32
00:01:56,700 --> 00:01:59,960
equal to the rule, less than the column or equal to the column.
32

33
00:02:00,810 --> 00:02:04,590
Well, and finally, we check if the grid cell, not zero.
33

34
00:02:04,590 --> 00:02:08,080
If it is zero, this is OK, otherwise, it's already reserved.
34

35
00:02:08,580 --> 00:02:13,530
Observe that this if condition is very popular in industry.
35

36
00:02:13,710 --> 00:02:17,700
This is a shortcut circuit evaluation; like this
36

37
00:02:17,730 --> 00:02:25,470
grid access will never be evaluated if any of these guys are invalid, because if any of
37

38
00:02:25,470 --> 00:02:29,820
these guys are invalid, this grid of r and c will access outside the array.
38

39
00:02:30,960 --> 00:02:33,180
So you cannot put this if condition here in the beginning.
39

40
00:02:33,180 --> 00:02:36,950
It has to be in the end after verifying all of these four guys.
40

41
00:02:37,740 --> 00:02:40,140
So now we are done and we have a valid location.
41

42
00:02:40,140 --> 00:02:42,230
We bought it here in the cell.
42

43
00:02:42,240 --> 00:02:46,770
Remember that the grid has 0, 1 & 2 for the turn.
43

44
00:02:46,770 --> 00:02:48,210
So I'm adding here plus one.
44

45
00:02:48,870 --> 00:02:51,240
And here is just a printing for the grid.
45

46
00:02:51,660 --> 00:02:52,710
So far, so good.
46

47
00:02:52,710 --> 00:02:57,780
We would like now to verify the winning of the grid.
47

48
00:02:58,260 --> 00:03:04,890
One very direct way it just to go with very dense code we need to verify the N rows, then verify the N
48

49
00:03:04,890 --> 00:03:07,440
columns, then verify 2 diagonals.
49

50
00:03:07,650 --> 00:03:11,430
So overall we have to 2 N plus 2 verification.
50

51
00:03:11,760 --> 00:03:12,570
We can do that.
51

52
00:03:12,570 --> 00:03:14,460
But this is very, very lengthy code.
52

53
00:03:14,880 --> 00:03:19,380
Let's see how the dir. array can help us to make the code very elegant.
53

54
00:03:19,830 --> 00:03:26,880
Observer the following: the behavior of all of this verification is the same, how? The all of them need
54

55
00:03:26,880 --> 00:03:32,760
some starting point, for example, zero & zero and then all of them keep going in a specific direction,
55

56
00:03:32,940 --> 00:03:40,020
either the row direction, the column direction, left diagonal direction, right diagonal  direction and all of them go N
56

57
00:03:40,020 --> 00:03:40,500
steps.
57

58
00:03:40,950 --> 00:03:44,010
And this should trigger for you the dir. array.
58

59
00:03:44,400 --> 00:03:53,190
So the idea is as following, we will create a single array that mainly or a few arrays here that mainly
59

60
00:03:53,190 --> 00:03:56,190
maintaining the information of the two N plus one verification. 
60

61
00:03:56,610 --> 00:03:58,980
Specifically, we need four values.
61

62
00:03:59,250 --> 00:04:04,590
I need the starting point, which is r & c , and I need the direction for everyone.
62

63
00:04:04,770 --> 00:04:10,350
Let's give an example, for example, from zero & zero, I need to verify its row.
63

64
00:04:10,350 --> 00:04:11,910
So the direction is one and zero.
64

65
00:04:11,910 --> 00:04:14,520
We keep going in the direction of the row till it ends.
65

66
00:04:15,120 --> 00:04:16,920
And also we need to verify its column.
66

67
00:04:16,920 --> 00:04:22,890
So we need to go zero one, which means don't increment to the rpw, but increment the column.
67

68
00:04:22,890 --> 00:04:24,330
So we verify all the columns.
68

69
00:04:24,960 --> 00:04:29,310
If you would like to verify the left diagonal, which is also starting from zero & zero,
69

70
00:04:29,490 --> 00:04:35,160
we could move in from one & one, so it's (0,0) now (1,1), (2,2) and (3,3), and so on.
70

71
00:04:36,680 --> 00:04:41,080
If you would like to verify the right diagonal, where is the starting point of the right diagonal?
71

72
00:04:41,720 --> 00:04:47,300
It could be, for example, 0 and n-1, which is the first row and the last element  and what
72

73
00:04:47,300 --> 00:04:48,380
is the moving pattern?
73

74
00:04:48,650 --> 00:04:49,430
It should be
74

75
00:04:49,470 --> 00:04:53,390
go one extra row, but go one less column and so on.
75

76
00:04:54,480 --> 00:05:01,390
Based on that, we can maintain the n rows, n columns, 2 diagonals in just these 4 arrays. 
76

77
00:05:01,390 --> 00:05:09,780
The 4 arrays represent the four values that we need here, the r & c values and the 2 diagonal values.
77

78
00:05:11,380 --> 00:05:13,830
Let's make it here more accurate.
78

79
00:05:17,790 --> 00:05:19,610
Now, let's see how to build that.
79

80
00:05:19,650 --> 00:05:25,980
If I would like to add the n rows verification that I would like, observe that all what you
80

81
00:05:25,980 --> 00:05:34,200
need is that to try the starting point r and 0. So r and zero are the starting point for a row here
81

82
00:05:34,590 --> 00:05:36,890
and the direction would be fixed to zero and one.
82

83
00:05:37,170 --> 00:05:41,850
So for example, let's say n is three, then we will add zero and zero.
83

84
00:05:42,210 --> 00:05:43,230
One and zero.
84

85
00:05:43,560 --> 00:05:44,400
Two and zero.
85

86
00:05:45,320 --> 00:05:51,230
Now, all of them will be moving with no increment for the row, but there is an increment
86

87
00:05:52,220 --> 00:05:58,850
for the column, this is how we verify all the rows, all the row elements in a very symmetric way.
87

88
00:05:59,090 --> 00:06:06,350
To add the n columns, you need to try 0 & c as a starting point with a moving direction one
88

89
00:06:06,350 --> 00:06:06,890
and zero.
89

90
00:06:07,280 --> 00:06:14,240
So we add here for n is three, 0&0, 0&1,  0&2  and from here we start to
90

91
00:06:14,240 --> 00:06:16,960
move one and zero, which means move the column
91

92
00:06:17,210 --> 00:06:19,340
but fix the row.  Don't don't change the row.
92

93
00:06:20,180 --> 00:06:25,040
Finally, we need to add 2 diagonals: the left and right, the left one start at zero and
93

94
00:06:25,040 --> 00:06:32,390
zero and is incremented with one & one, and the right diagonal is 0 and n -1 as we mentioned
94

95
00:06:32,390 --> 00:06:32,720
here.
95

96
00:06:32,990 --> 00:06:34,740
And the direction is one & -1.
96

97
00:06:35,120 --> 00:06:43,430
This way we added 2N+2 verification for our grid.
97

98
00:06:43,430 --> 00:06:47,290
If you check this value, it should be 2N+2 verification.
98

99
00:06:47,780 --> 00:06:53,740
Now, we would like to apply them so we iterate over every verification of them.
99

100
00:06:54,140 --> 00:06:58,730
We take the starting point r & c and we take the direction row and the direction column, 
100

101
00:06:59,180 --> 00:07:07,280
and then all what we need is to iterate for n steps to check if all of them are the current first
101

102
00:07:07,280 --> 00:07:07,680
element.
102

103
00:07:07,700 --> 00:07:08,840
So first is
103

104
00:07:10,240 --> 00:07:16,990
the current element at the grid of r & c. OK, if the first equal equal zero, it means it's empty, so we
104

105
00:07:16,990 --> 00:07:17,710
ignore it.
105

106
00:07:18,580 --> 00:07:23,640
Otherwise, we can even make one more if condition here to verify that the winner is the turn.
106

107
00:07:23,690 --> 00:07:29,740
But anyway, let's say the first here is 'x', we iterate on the current row or column or diagonal 
107

108
00:07:29,740 --> 00:07:34,950
depends on the check and make sure that all of them are the current winner.
108

109
00:07:35,570 --> 00:07:40,780
If this is a case of the count equal n, which means that a complete row
109

110
00:07:40,780 --> 00:07:42,640
or a complete column or a complete diagonal.
110

111
00:07:42,670 --> 00:07:47,680
If this is the case, then we say that this is a specific winner and we return zero.
111

112
00:07:49,330 --> 00:07:54,490
Otherwise, we switch to the turn from zero to one or one to zero and increment the steps.
112

113
00:07:55,360 --> 00:07:56,830
That's all. I know
113

114
00:07:56,830 --> 00:08:03,610
that might be a bit overwhelming for you, but use n equal three,  verify these guys and will verify
114

115
00:08:03,610 --> 00:08:04,180
these guys.
115

116
00:08:04,180 --> 00:08:07,170
And I hope overall it should be OK for you.
116

117
00:08:07,210 --> 00:08:10,150
This is the tie test case you might write, that's all.
