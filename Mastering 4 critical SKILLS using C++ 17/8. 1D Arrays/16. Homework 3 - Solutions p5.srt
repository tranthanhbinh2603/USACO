0
1
00:00:01,260 --> 00:00:09,270
Let's see how to solve the last problem here, which is a bit easy for a three loops, medium for two
1

2
00:00:09,270 --> 00:00:12,580
loops, but hard to do it with only a single loop.
2

3
00:00:13,170 --> 00:00:16,300
So let's see how to code it. In the first version,
3

4
00:00:16,320 --> 00:00:20,810
you would like to just go brute force, just try everything.
4

5
00:00:21,090 --> 00:00:22,590
Let's just try every start.
5

6
00:00:22,830 --> 00:00:27,120
And then from this start, we will try all of the possible ends for every start.
6

7
00:00:27,120 --> 00:00:30,540
And we can iterate in between counting the number of zeros and ones.
7

8
00:00:30,840 --> 00:00:34,530
If the number of zeros and ones are equal, then we got it.
8

9
00:00:34,530 --> 00:00:35,810
We have a valid array.
9

10
00:00:35,820 --> 00:00:37,670
Keep maximizing among all of them.
10

11
00:00:38,160 --> 00:00:38,900
So far, so good.
11

12
00:00:38,910 --> 00:00:44,550
But you probably observe that, there is a lot of duplications here in a very similar to what we did
12

13
00:00:44,550 --> 00:00:45,990
before in one of the assignments.
13

14
00:00:46,270 --> 00:00:56,870
So let's see what can we do here. In this one, we noticed that if we tried every start and every end,
14

15
00:00:57,390 --> 00:01:05,610
what about keeping incrementing the array and expanding it; the expanding idea like keep expanding
15

16
00:01:05,610 --> 00:01:11,560
and while expanding, maintain the number of zeros and ones. We don't need to keep every time from start
16

17
00:01:11,560 --> 00:01:13,790
to end and keep iterating between all of them.
17

18
00:01:14,190 --> 00:01:15,240
We have a start here.
18

19
00:01:15,390 --> 00:01:18,240
We have an end that is expanding. With every expansion,
19

20
00:01:18,240 --> 00:01:24,590
we update the zeroes and ones and then if they are equal, we got one more case now.
20

21
00:01:24,600 --> 00:01:25,440
So far, so good.
21

22
00:01:25,710 --> 00:01:27,240
The third case is a bit hard
22

23
00:01:27,240 --> 00:01:34,890
one. I wrote a clarification example here to show you the idea of it.
23

24
00:01:35,250 --> 00:01:38,070
Let's say that this is the input, I took it from the slides.
24

25
00:01:38,430 --> 00:01:41,520
I would like to maintain four types of information.
25

26
00:01:41,850 --> 00:01:44,990
Let's maintain the total number of zeros that we have so far.
26

27
00:01:45,660 --> 00:01:48,700
For example, here so far, we have five zeros from here.
27

28
00:01:49,500 --> 00:01:53,550
Here we have seven zero so far and so on in a similar way.
28

29
00:01:53,550 --> 00:01:54,180
We maintain here
29

30
00:01:54,180 --> 00:01:55,620
the number of ones so far.
30

31
00:01:55,620 --> 00:02:02,790
For example, here we have four ones; two from here, three, four, and then maintain the zeros minus
31

32
00:02:02,790 --> 00:02:04,560
the ones or the ones minus the zeroes. 
32

33
00:02:04,560 --> 00:02:08,460
So let's compute the total number of zeros minus total number of ones.
33

34
00:02:10,020 --> 00:02:16,610
For example, at this position we have five zeros and 1 one only,  five minus one is four.
34

35
00:02:16,950 --> 00:02:18,680
Here we have six zeroes.
35

36
00:02:18,900 --> 00:02:19,920
We have two ones.
36

37
00:02:19,920 --> 00:02:21,840
Six minus two is four.
37

38
00:02:22,730 --> 00:02:29,260
The last item here is first time. I'm recording the first time such a difference appeared, for example,
38

39
00:02:29,420 --> 00:02:34,550
this is the first time, the five difference appear, but they are three differences appeared before
39

40
00:02:34,550 --> 00:02:34,870
here.
40

41
00:02:35,270 --> 00:02:36,750
So we maintain it here.
41

42
00:02:37,130 --> 00:02:40,300
I also added here a difference 0.
42

43
00:02:41,060 --> 00:02:46,760
This is before the processing of the array, because before we start, we have a zero difference between
43

44
00:02:46,760 --> 00:02:48,080
the zeros and ones.
44

45
00:02:48,090 --> 00:02:53,510
So this is something like a precondition and also the first time to have such a condition.
45

46
00:02:54,320 --> 00:03:01,060
It is very clear if let's say we are here and the difference between zeros and ones is zero.
46

47
00:03:01,250 --> 00:03:03,590
It means actually all of that will be zeros.
47

48
00:03:03,590 --> 00:03:03,800
Right.
48

49
00:03:04,460 --> 00:03:06,170
Let's pretend that this is actually zero.
49

50
00:03:06,390 --> 00:03:06,770
Sorry.
50

51
00:03:06,790 --> 00:03:07,100
Yeah.
51

52
00:03:07,430 --> 00:03:09,200
Let's pretend that the difference is zero.
52

53
00:03:09,530 --> 00:03:11,230
It means actually a very direct way.
53

54
00:03:11,240 --> 00:03:14,140
The total here number of zeros and ones is equal.
54

55
00:03:14,930 --> 00:03:19,340
But what does it mean to have here five as a difference?
55

56
00:03:20,670 --> 00:03:21,720
Let's forget about five.
56

57
00:03:22,010 --> 00:03:26,450
What does it mean to have four here as a difference and four here as a difference?
57

58
00:03:27,610 --> 00:03:31,120
This range. what does it mean to have the same difference
58

59
00:03:31,270 --> 00:03:36,140
Several times? I would like you to stop the video for five minutes and think about it.
59

60
00:03:36,340 --> 00:03:38,860
What does it mean to have here 4 and 4?
60

61
00:03:39,160 --> 00:03:45,520
What does it mean to have here two and again, another two here and try from that to get an idea to
61

62
00:03:45,520 --> 00:03:46,270
solve the problem?
62

63
00:03:46,300 --> 00:03:47,800
We're almost done with it.
63

64
00:03:49,390 --> 00:03:55,690
The idea is similar to what we did in the accumulation sum. If this position is 4, and this position
64

65
00:03:55,690 --> 00:03:56,250
is 4,
65

66
00:03:56,530 --> 00:04:05,830
it means that the number of items in between after this 4 and up to this 4 must be an equal number
66

67
00:04:05,830 --> 00:04:06,910
of zeros and ones.
67

68
00:04:07,120 --> 00:04:15,630
So we have here zero, zero, zero, one, two, three, four zeros and one, two, three, four ones.
68

69
00:04:15,940 --> 00:04:23,050
It means if we subtracted this guy, it means that this window must have a total number of zeros equal
69

70
00:04:23,050 --> 00:04:24,550
to the total number of ones.
70

71
00:04:24,670 --> 00:04:31,900
OK, because this extra gap between number of zeros and ones can be discarded by subtracting that window
71

72
00:04:31,900 --> 00:04:32,440
before it.
72

73
00:04:32,710 --> 00:04:33,430
So remember the accumulation.
73

74
00:04:33,760 --> 00:04:36,430
sum we used to have this window to get the window
74

75
00:04:36,430 --> 00:04:43,960
we need to; we used to subtract all of that from that is exactly the same idea having here a two and
75

76
00:04:43,960 --> 00:04:44,710
another two.
76

77
00:04:44,860 --> 00:04:49,690
It means that this window corresponding to this range must have equal number of zeros and ones.
77

78
00:04:49,900 --> 00:04:52,400
So we have here one, one, one, one.
78

79
00:04:52,560 --> 00:04:55,450
We have four ones and we have four zeros.
79

80
00:04:55,660 --> 00:04:57,400
This is the moral of the idea.
80

81
00:04:57,610 --> 00:05:03,010
So to implement that, all what you need is to keep maintaining the total number of zeros and ones as you go,
81

82
00:05:03,130 --> 00:05:05,890
specifically keep maintaining the difference between them.
82

83
00:05:06,310 --> 00:05:13,660
And whenever you have a repeated difference, then this window must be total number of zeros equal
83

84
00:05:13,660 --> 00:05:16,520
to the number of ones. As we would like to maximize,
84

85
00:05:16,690 --> 00:05:19,540
we would like to know the first time a difference appear.
85

86
00:05:19,840 --> 00:05:22,120
So for example, here is the first time 4 appears.
86

87
00:05:22,420 --> 00:05:28,980
Now, the last 4 with the first 4 will help us to get the best window for this case.
87

88
00:05:29,290 --> 00:05:31,130
Again, the first two is marked.
88

89
00:05:31,420 --> 00:05:32,620
Now we are facing two.
89

90
00:05:32,620 --> 00:05:33,520
We are facing two.
90

91
00:05:33,700 --> 00:05:36,700
Then this window is again a bigger one.
91

92
00:05:36,970 --> 00:05:41,320
If you understood the idea, try to stop the video and implement it by yourself.
92

93
00:05:41,530 --> 00:05:43,270
If not, let's go into details.
93

94
00:05:43,690 --> 00:05:47,140
As you notice, the difference here can be positive or negative.
94

95
00:05:47,500 --> 00:05:49,270
Let's say the array length is one thousand.
95

96
00:05:49,270 --> 00:05:53,880
I know on the slides, I mentioned this is less than 1000, but let's pretend that they are actually one thousand maximum.
96

97
00:05:54,580 --> 00:05:57,970
Then in the worst case, we can have all of them as ones.
97

98
00:05:58,210 --> 00:06:01,670
So the result can be 1000 or all of them can be zeroes.
98

99
00:06:02,020 --> 00:06:04,970
So the result would be...,  the difference would be minus one thousand.
99

100
00:06:05,260 --> 00:06:07,300
So overall we are ranging from one thousand..., 
100

101
00:06:07,300 --> 00:06:08,180
-1000 to 
101

102
00:06:08,200 --> 00:06:08,850
1000. 
102

103
00:06:09,220 --> 00:06:12,910
We have overall two thousand and one values.
103

104
00:06:13,030 --> 00:06:17,650
We can use the shift idea to implement a difference array that maintains the differences for us.
104

105
00:06:18,860 --> 00:06:25,000
So that's why I am having here I am maintaining big differences here, this big value just to maintain
105

106
00:06:25,000 --> 00:06:26,710
that this never appeared before.
106

107
00:06:27,190 --> 00:06:36,220
And then we read the array and we start reading and first marking the zero. I'm adding here +1000, 
107

108
00:06:36,220 --> 00:06:38,890
it would be like shifting the negative to be positive.
108

109
00:06:39,160 --> 00:06:43,960
So we would like to mark zero first, as appeared before the start of the array, and then let's go
109

110
00:06:43,960 --> 00:06:45,990
over the array. If the value zero,
110

111
00:06:46,000 --> 00:06:46,570
we add one.
111

112
00:06:46,570 --> 00:06:51,370
If the value is..., sorry. That the value is one, we add one. If the value is zero, we add negative one.
112

113
00:06:51,730 --> 00:06:57,600
Now "added" represented the total number, the difference between ones and zeros here, ones and zeros,
113

114
00:06:57,670 --> 00:07:02,260
zeros and ones, ones and zeros starting from the big int  array up to the index.
114

115
00:07:02,260 --> 00:07:04,290
I again make a shift here.
115

116
00:07:04,690 --> 00:07:05,860
Now there are two cases.
116

117
00:07:06,040 --> 00:07:09,220
Either this difference never appeared before or appeared before.
117

118
00:07:09,670 --> 00:07:19,230
If the difference appeared before, we just the mark it with the first
118

119
00:07:19,270 --> 00:07:21,020
position that the "i" appeared in it.
119

120
00:07:21,550 --> 00:07:27,690
Otherwise, we now know that we have one more location with the same difference.
120

121
00:07:28,030 --> 00:07:35,680
So the "subarrayLength" that we would like should be from my current position to the first position that
121

122
00:07:35,680 --> 00:07:38,280
appeared and then maximize over it.
122

123
00:07:38,560 --> 00:07:40,450
That's all I hope you got it.
123

124
00:07:40,600 --> 00:07:43,300
We are trying to maintain the difference between ones and zeros.
124

125
00:07:43,480 --> 00:07:46,930
We are marking the first time the difference appeared.
125

126
00:07:47,140 --> 00:07:54,550
We are maximizing on the array length that we have so far and that's it, the whole trick was this difference
126

127
00:07:54,550 --> 00:07:55,630
between zeros and ones.
127

128
00:07:55,840 --> 00:08:02,500
And to a large extent, it was like inspired by the motivation, by the accumulation idea.
