0
1
00:00:01,080 --> 00:00:07,610
So far, we learned about the (if conditions) and looping which are, what we call the program flow, it helps us
1

2
00:00:07,620 --> 00:00:08,920
to control the flow.
2

3
00:00:09,360 --> 00:00:14,820
Today, we are going to one of the fundamental concepts in programming, which is called "Arrays".
3

4
00:00:14,820 --> 00:00:19,290
Arrays could be something like 1D or 2D or 3D, the multidimensional case.
4

5
00:00:19,530 --> 00:00:24,060
So today, our focus will be on the array. Let's motivate the use of arrays.
5

6
00:00:24,420 --> 00:00:30,420
If I told you that, I would like to read 1000 integer numbers and print them it reversed.
6

7
00:00:30,420 --> 00:00:37,700
For example, read 1000 integers and find pairs of numbers with some one, two, three, four, five.
7

8
00:00:38,610 --> 00:00:43,140
We can definitely define 1000 variables, but this is going to be very crazy.
8

9
00:00:43,500 --> 00:00:48,060
C++ and any programming language provide us with the array of array.
9

10
00:00:48,390 --> 00:00:50,600
The Array has some size (bits of K).
10

11
00:00:50,850 --> 00:00:55,370
For example, you define K variables in the memory consecutively.
11

12
00:00:55,380 --> 00:00:58,530
So we have now 1000 variable in the memory.
12

13
00:00:58,890 --> 00:01:02,010
They are typically all of the same type, at least here in C++.
13

14
00:01:02,430 --> 00:01:07,970
And once we have the one array, we can just iterate on it and do all what we want.
14

15
00:01:07,980 --> 00:01:10,080
Well, let's see an example of that.
15

16
00:01:10,440 --> 00:01:12,930
Here is how we define an array.
16

17
00:01:13,410 --> 00:01:17,790
Let's say we we are targeting an array of five numbers.
17

18
00:01:18,030 --> 00:01:19,290
This is the syntax of it.
18

19
00:01:19,560 --> 00:01:25,740
We say integer numbers and then you open brackets '[ ]' and you put some number here.
19

20
00:01:26,130 --> 00:01:31,770
And these are basically some values like {10, 2, 7, 5, 3}.
20

21
00:01:32,370 --> 00:01:33,790
Now, what does this mean?
21

22
00:01:34,080 --> 00:01:38,970
It means, Create five numbers in the memory for us.
22

23
00:01:38,990 --> 00:01:42,580
Noted that, we cannot change this five later, it's just now 5 and so on.
23

24
00:01:43,180 --> 00:01:52,050
Now, the purpose of this syntax is instead of I'm going to create five variables by myself, I have
24

25
00:01:52,050 --> 00:01:54,610
created five variables in a single command.
25

26
00:01:54,810 --> 00:01:59,000
So this is the main difference between defining a variable and defining an array.
26

27
00:01:59,280 --> 00:02:03,360
The array helps us to define a lot of variables using a single command.
27

28
00:02:03,780 --> 00:02:10,620
Now, the question is, if I have five variables, I can access them by myself, get the values of the
28

29
00:02:10,620 --> 00:02:11,610
value from the memory.
29

30
00:02:11,850 --> 00:02:13,270
So now what about an array?
30

31
00:02:13,560 --> 00:02:14,790
It goes as following.
31

32
00:02:15,060 --> 00:02:21,720
The first rule is if you would like to access a specific value variable out of them, you start to use
32

33
00:02:21,720 --> 00:02:24,270
brackets '[ ]' again and give an index.
33

34
00:02:24,630 --> 00:02:27,750
An index is something that is a number.
34

35
00:02:27,780 --> 00:02:34,380
So let's say we have five numbers, then they are... Suppose from one to five. in C++ and in programming
35

36
00:02:34,380 --> 00:02:37,160
we see something called, "Zero Indexing".
36

37
00:02:37,440 --> 00:02:42,660
This means, that the first number would be in the memory in position [0] and the last number in the
37

38
00:02:42,660 --> 00:02:44,060
position is [size-1].
38

39
00:02:44,400 --> 00:02:50,730
For example, if you define the five variables, then the first variable in the memory would be of position [0]
39

40
00:02:50,730 --> 00:02:56,490
and the last one number is position [4]. Thinking about your number zero,
40

41
00:02:56,490 --> 00:02:57,060
Number two,
41

42
00:02:57,090 --> 00:03:01,620
Number four, you will notice that we are dealing with it as if it is normal variable.
42

43
00:03:01,620 --> 00:03:03,540
It's actually all what happened
43

44
00:03:03,540 --> 00:03:06,510
we defined five variables consecutively in the memory.
44

45
00:03:06,750 --> 00:03:12,600
We just now have more convenient way to access them so I can access and set a value.
45

46
00:03:12,750 --> 00:03:16,830
We can multiply the value, we can increment the value, we can print the value,
46

47
00:03:17,190 --> 00:03:17,740
That's it.
47

48
00:03:18,090 --> 00:03:23,160
Please make sure that you are comfortable with defining and initializing an array.
48

49
00:03:24,880 --> 00:03:31,200
Thinking about the memory, here is what goes in the array that we defined. Initially, I say create
49

50
00:03:31,210 --> 00:03:36,230
three or five numbers and also initialize them to {10, 2, 7, 5, 3}.
50

51
00:03:36,550 --> 00:03:38,260
So this is what happens in the memory.
51

52
00:03:38,590 --> 00:03:41,760
Five numbers are reserved for you,
52

53
00:03:42,100 --> 00:03:44,530
they can be the index from zero to four.
53

54
00:03:45,220 --> 00:03:53,080
Now, in line 11, we say (number[0] = 9), so it goes in the memory here and switches to 9.
54

55
00:03:53,560 --> 00:03:55,960
In line 12, we multiply the second.
55

56
00:03:56,860 --> 00:04:02,020
OK, when we say position [2], remember that this is the third number, so we are multiplying the
56

57
00:04:02,020 --> 00:04:03,550
third number by three,
57

58
00:04:03,850 --> 00:04:06,220
and we are incrementing the fifth number.
58

59
00:04:06,250 --> 00:04:11,650
OK, so here, if you notice the third number is going to multiply by three,
59

60
00:04:11,660 --> 00:04:17,850
So (7 * 3 = 21), and the fifth number is going to be incremented with one step.
60

61
00:04:18,250 --> 00:04:21,730
It's very important to be comfortable with zero-based indexing.
61

62
00:04:21,970 --> 00:04:25,500
So it's all the time to be from zero to four, not from one to five.
62

63
00:04:26,650 --> 00:04:27,890
I would like from now on to 
63

64
00:04:27,910 --> 00:04:33,250
just to start to think of it as just a bunch of variables in memory for you.
64

65
00:04:33,550 --> 00:04:38,770
Let's say that you would like, for example, to print the whole array content.
65

66
00:04:39,070 --> 00:04:45,610
Then we know that using a single loop like (for loop) like that, you can just iterate on the array one by one.
66

67
00:04:45,610 --> 00:04:46,090
one by one.
67

68
00:04:46,330 --> 00:04:52,600
So here we say 'cout << numbers[i]', so it's going to print the one, two, three, four, five for you.
68

69
00:04:52,600 --> 00:04:54,490
On the other side,
69

70
00:04:54,490 --> 00:05:01,180
If you would like to iterate from the backward, we can definitely say start from [size-1], (i >= -1).
70

71
00:05:01,240 --> 00:05:04,050
(i >= -1), (--i).
71

72
00:05:04,150 --> 00:05:08,400
But just for for sake of math, I'm just showing you a different way here.
72

73
00:05:08,650 --> 00:05:15,220
So I'm saying here, [size -i-1], which is a starting from (4, 3, 2 ,1, 0)
73

74
00:05:15,220 --> 00:05:17,110
and tracing backward.
74

75
00:05:19,020 --> 00:05:24,840
OK, let's do one simple application, let's say I would like to give you an array, I would like to
75

76
00:05:24,840 --> 00:05:29,650
read it and then I would like to find the minimum out of what I'm going to read.
76

77
00:05:30,060 --> 00:05:33,180
So here, I declared an array of five positions.
77

78
00:05:33,180 --> 00:05:36,090
But notice here, I didn't initialize it with anything.
78

79
00:05:36,120 --> 00:05:37,050
This isn't healthy,
79

80
00:05:37,050 --> 00:05:42,790
But anyway, now I'm looping five times to read the five numbers.
80

81
00:05:43,350 --> 00:05:50,370
Now the five numbers in the memory are read. We are going to iterate on the whole array and start to
81

82
00:05:50,370 --> 00:05:51,540
get the minimum out of them.
82

83
00:05:51,960 --> 00:05:57,960
I took the first number of the array as the minimum for now, and then it started form the next position of one
83

84
00:05:57,960 --> 00:06:01,350
going to the maximum, which is 4.
84

85
00:06:01,950 --> 00:06:05,120
OK, so remember, the 'i' is less than five, It's just going to 4.
85

86
00:06:05,430 --> 00:06:09,890
And then I'm saying if minimum is greater than 'i', then this is minimum.
86

87
00:06:10,170 --> 00:06:13,480
Take this number as the minimum for now and keep going.
87

88
00:06:13,830 --> 00:06:18,570
So as you see, we are just dealing with the array as bunch of variables for us in memory,
88

89
00:06:18,570 --> 00:06:23,320
we can read, we can write, we can process, It just makes our life easier.
89

90
00:06:23,550 --> 00:06:25,920
So now we are defining five numbers.
90

91
00:06:26,070 --> 00:06:29,160
We now can define one million number and just go ahead and read them.
91

92
00:06:29,370 --> 00:06:34,530
You cannot define one million variable by yourself, but using a single command, you created a big
92

93
00:06:34,530 --> 00:06:35,880
array in the memory.
93

94
00:06:37,440 --> 00:06:39,270
Some comments about initialization,
94

95
00:06:40,430 --> 00:06:46,170
If you want to define a single variable, you could say 'int val1 = 100', or ' int val2 {100}'.
95

96
00:06:47,550 --> 00:06:49,110
or ' int val2 {100}'.
96

97
00:06:49,620 --> 00:06:56,370
OK, so comparing this syntax, you see here the braces directly for 'val2', so someone might mix it
97

98
00:06:56,400 --> 00:06:57,600
mix it with the brackets.
98

99
00:06:57,750 --> 00:07:01,740
So these braces '{ }' are for initialization, this one '[ ]' is for the definition.
99

100
00:07:02,100 --> 00:07:04,980
We can use the equal and then put an array.
100

101
00:07:05,010 --> 00:07:08,930
This is more of a C-style, but the C++ has more of the initialization style.
101

102
00:07:08,940 --> 00:07:14,230
I'm getting used to this style, but in your programming style you better get used to that.
102

103
00:07:14,880 --> 00:07:18,210
The final thing is what happens if I wrote this way?
103

104
00:07:18,360 --> 00:07:21,210
If I defined an array without a number here,
104

105
00:07:21,390 --> 00:07:23,160
But I give an initialization list.
105

106
00:07:23,460 --> 00:07:26,030
It actually automatically will know that this is three.
106

107
00:07:26,430 --> 00:07:31,050
But if you didn't put the numbers here, it will not be able to figure out the array size.
107

108
00:07:31,410 --> 00:07:35,450
The array has to be reserved for once in the memory and it is fixed it size.
108

109
00:07:35,670 --> 00:07:38,910
So now we know it's going to be hundred numbers in the memory.
109

110
00:07:39,150 --> 00:07:41,790
Here we know, it's three numbers in the memory and so on.
110

111
00:07:43,770 --> 00:07:49,980
In addition, we are focusing on integer variables, but you can also define an array of "doubles", array
111

112
00:07:49,980 --> 00:07:53,060
of "characters", array of "strings" and so on.
112

113
00:07:53,070 --> 00:07:54,120
So no limitation.
113

114
00:07:55,910 --> 00:08:00,050
The last thing to mention is what we call the index of the boundary error.
114

115
00:08:00,300 --> 00:08:04,670
Remember, the runtime error is a problem that happened during the running of the program.
115

116
00:08:05,010 --> 00:08:07,710
So there are two common mistakes that people do.
116

117
00:08:08,040 --> 00:08:10,700
The first is to access with a negative index.
117

118
00:08:10,980 --> 00:08:14,280
The second is to access with an index beyond the limitation.
118

119
00:08:14,280 --> 00:08:19,980
For example, if you have an integer array of hundred, then this hundred can access from zero to ninety-nine. 
119

120
00:08:19,980 --> 00:08:20,280
to ninety-nine. 
120

121
00:08:20,610 --> 00:08:25,560
A very common mistake is to access it with one hundred exactly, due to one indexing.
121

122
00:08:25,560 --> 00:08:26,220
But this is wrong.
122

123
00:08:26,220 --> 00:08:29,050
It should be only indexed from zero to ninety nine.
123

124
00:08:29,340 --> 00:08:33,450
The second mistake is that you might access it with negative 10, which is a negative number.
124

125
00:08:33,480 --> 00:08:34,300
This is again wrong.
125

126
00:08:34,710 --> 00:08:36,630
That's why we call it "Index out of boundary".
126

127
00:08:36,930 --> 00:08:42,180
Your boundary is from zero to ninety nine only, so no one is doubling check the boundaries for you.
127

128
00:08:42,420 --> 00:08:43,790
You have to do it by yourself.
128

129
00:08:44,970 --> 00:08:45,450
That's it! :)
