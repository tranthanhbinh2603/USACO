0
1
00:00:01,380 --> 00:00:08,520
In this version of the problem, now the list is unordered, so we lost the advantage of having it an
1

2
00:00:08,520 --> 00:00:09,330
ordered list.
2

3
00:00:09,780 --> 00:00:14,430
Now it seems like the idea of having two nested loops is very, very straightforward.
3

4
00:00:14,760 --> 00:00:20,100
But still, we can avoid nested loops using the frequency trick, especially that all the values are
4

5
00:00:20,100 --> 00:00:23,080
just trapped between zero and five hundred.
5

6
00:00:23,550 --> 00:00:24,750
Let's see how to code that.
6

7
00:00:25,590 --> 00:00:31,500
We are going to create an array, again with plus one, to make sure the array is correct, and after that,
7

8
00:00:31,520 --> 00:00:36,480
we will iterate over the numbers, assert is just a function in cassert here that makes sure this is an
8

9
00:00:36,480 --> 00:00:36,780
input
9

10
00:00:36,780 --> 00:00:42,750
valid. I do that a lot in my code to make sure I'm not messing with my code, but in practice in
10

11
00:00:42,750 --> 00:00:48,120
industrial code, you shouldn't have an assert code because if something is wrong, the whole application
11

12
00:00:48,120 --> 00:00:50,220
will fail in C++. Anyway,
12

13
00:00:50,310 --> 00:00:50,870
skip it.
13

14
00:00:51,250 --> 00:00:53,060
Here
14

15
00:00:53,060 --> 00:00:58,290
I'm marking if I have visited this value before or not.
15

16
00:00:58,410 --> 00:01:02,460
If I didn't visit it before, then this is a unique number, we just print it.
16

17
00:01:02,760 --> 00:01:07,020
Otherwise, we mark it here as a value that
17

18
00:01:07,860 --> 00:01:10,670
we need to mark it visited.
18

19
00:01:10,890 --> 00:01:15,900
So this way with the visited trick, which is similar to the frequency idea, we are done with
19

20
00:01:15,900 --> 00:01:17,070
the problem that we're facing.
20

21
00:01:18,350 --> 00:01:20,820
In the last problem, we would like to sort the numbers.
21

22
00:01:20,840 --> 00:01:24,560
I know that this was probably a big challenge for you, how to sort numbers.
22

23
00:01:24,740 --> 00:01:30,470
You don't have to go to very complicated algorithms like selection sort, and blah, blah, blah.
23

24
00:01:30,680 --> 00:01:34,840
The hint was the array has a maximum value of five hundred.
24

25
00:01:35,060 --> 00:01:36,810
How can we make use of this idea?
25

26
00:01:37,100 --> 00:01:38,390
The idea is very simple.
26

27
00:01:38,630 --> 00:01:41,780
Let's compute the frequency matrix of the given input.
27

28
00:01:42,260 --> 00:01:45,050
Now, what is the frequency of one? One.
28

29
00:01:45,290 --> 00:01:46,250
So let's print it here.
29

30
00:01:46,280 --> 00:01:47,990
What is the frequency of two?
30

31
00:01:48,110 --> 00:01:51,110
One, two, three, then print three twos.
31

32
00:01:51,470 --> 00:01:54,650
What is the frequency of three? Three, print three threes.
32

33
00:01:54,980 --> 00:01:56,330
What is the frequency of four?
33

34
00:01:56,480 --> 00:01:57,700
Nothing, don't print it.
34

35
00:01:58,010 --> 00:02:00,890
What is the frequency of five? Four, print four fives.
35

36
00:02:01,190 --> 00:02:04,040
What is the frequency of seven? Two, print two sevens.
36

37
00:02:04,670 --> 00:02:06,140
What is the frequency of six?
37

38
00:02:06,140 --> 00:02:10,800
Nothing, don't print.  Frequency of eight, nine, ten, eleven, and so on.
38

39
00:02:11,060 --> 00:02:16,940
So the idea is if we know that all of the numbers are from zero to five hundred only, why not to count
39

40
00:02:16,940 --> 00:02:22,610
the frequency of every one of them, then iterate on all of the numbers from zero to five hundred, and
40

41
00:02:22,610 --> 00:02:24,550
print the number if it has a frequency.
41

42
00:02:25,010 --> 00:02:30,260
That's all. I know that this isn't an easy idea, so feel free to not solve it.
42

43
00:02:30,360 --> 00:02:31,520
Here is the frequency array.
43

44
00:02:31,640 --> 00:02:38,160
We iterate, and we keep accumulating here, and then we iterate on all of our range if the number appeared
44

45
00:02:38,330 --> 00:02:39,530
before, let's say, five times,
45

46
00:02:39,530 --> 00:02:42,140
so we print it five times, four times, we print it four times.
46

47
00:02:42,620 --> 00:02:44,720
This is actually a very popular algorithm.
47

48
00:02:44,720 --> 00:02:50,300
It's called Count Sort Algorithm, and it depends on the idea of counting the frequency of the number
48

49
00:02:50,510 --> 00:02:51,280
and printing it.
49

50
00:02:51,620 --> 00:02:54,860
And this is the most efficient algorithm for sorting numbers,
50

51
00:02:55,160 --> 00:03:02,030
if they are of small values. If they are big values, in algorithms course, you should learn about
51

52
00:03:02,030 --> 00:03:08,090
what we call quicksort and merge sort, and some inefficient solutions like insertion sort and selection
52

53
00:03:08,090 --> 00:03:08,480
sort.
53

54
00:03:08,990 --> 00:03:12,140
But it was good to know about that at this moment. That's all.
