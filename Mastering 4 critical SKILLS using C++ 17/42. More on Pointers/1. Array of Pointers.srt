1
00:00:01,350 --> 00:00:07,980
One of the interesting topics is the creation of a ray over a set of pointers, let's say that you have

2
00:00:07,980 --> 00:00:13,740
here three variables, A and B and C. So now here the E with its address, B with its address.

3
00:00:13,740 --> 00:00:19,320
And see with this address, one can create something like Integer Pastrick Array or three.

4
00:00:19,530 --> 00:00:22,290
This is creating an array of lenzer three.

5
00:00:22,620 --> 00:00:24,570
Each type of it is an integral pointer.

6
00:00:24,870 --> 00:00:29,250
Now this is an integral pointer and this goes into your pointer and this goes into the router so we

7
00:00:29,250 --> 00:00:32,510
can put here reference and just use it.

8
00:00:32,700 --> 00:00:38,760
So if you started to put references here, you will then have this first element looking to this guy,

9
00:00:38,880 --> 00:00:42,190
second element of this guy, third element looking to this guy.

10
00:00:42,660 --> 00:00:48,540
So if you try to print out the addresses of ABC and try to iterate on the on the array alignments and

11
00:00:48,540 --> 00:00:54,440
bring to them, you will notice that we have the address of every EBC here.

12
00:00:54,660 --> 00:00:59,820
And also we have the address of the items in the array position itself.

13
00:00:59,820 --> 00:01:01,770
Like this is a pointer.

14
00:01:01,770 --> 00:01:05,580
It has an address here and it also looking to an address.

15
00:01:08,390 --> 00:01:14,690
Let's take it modest steps forward, let's create a two array of characters, if you're trying to create

16
00:01:14,690 --> 00:01:20,750
it, then probably you would have to state the number of rules or you can leave it, but you must provide

17
00:01:20,750 --> 00:01:22,020
definitely the number of columns.

18
00:01:22,250 --> 00:01:27,410
So let's say in our application, we expect that the maximum of the string would be, let's say 15.

19
00:01:27,410 --> 00:01:27,740
Correct.

20
00:01:28,130 --> 00:01:30,110
So you find something like five times 50.

21
00:01:30,740 --> 00:01:39,110
Now, an interesting thing here is, first of all, this, five times 15 characters are all of them,

22
00:01:39,110 --> 00:01:43,940
one consecutive block in the memory, typically Rouverol in a row order hardware's.

23
00:01:45,170 --> 00:01:51,560
The second observation is you noticed all of this Noll's they are a waste of time like waste of memory

24
00:01:51,560 --> 00:01:55,580
because like there are a lot of things that aren't using anything.

25
00:01:55,880 --> 00:02:01,290
So one question is how to get rid of these guys before proceeding.

26
00:02:01,310 --> 00:02:07,030
I would like you to remember that in C++, this goal, everything here is a contest, a character pointer.

27
00:02:07,310 --> 00:02:10,130
So if you try to do something like sort of zero equal this guy.

28
00:02:11,710 --> 00:02:13,250
This will be a compilation error.

29
00:02:13,840 --> 00:02:18,800
The way to do that is to make a copy from here to here, and we have to guarantee that this guy of less

30
00:02:19,000 --> 00:02:20,060
than 50.

31
00:02:20,900 --> 00:02:24,630
Now, let's see what can happen if we have an array of pointers.

32
00:02:25,180 --> 00:02:32,380
But before that, I would like to warn you in C++ and you can write something like Characteristic Is

33
00:02:32,860 --> 00:02:35,070
and write something and it's going to compile.

34
00:02:35,080 --> 00:02:40,390
And the reason is it is historical for backward compatibility and C language, things like that.

35
00:02:40,660 --> 00:02:44,440
But the right way is to write the character pointer because this is going to say and you shouldn't try

36
00:02:44,440 --> 00:02:44,660
it.

37
00:02:45,010 --> 00:02:47,740
So now let's create an array of pointers.

38
00:02:47,950 --> 00:02:53,710
Every pointer is looking to a string bytes so we can do something like the character pointer and then

39
00:02:53,710 --> 00:02:55,840
we have here a bunch of strings.

40
00:02:56,260 --> 00:02:58,280
Now the difference in the memory is as follows.

41
00:02:58,690 --> 00:03:03,360
First of all, we have six different consecutive blocks in the memory.

42
00:03:03,670 --> 00:03:07,590
This guy, as in one array, not just here, this is now one the.

43
00:03:08,500 --> 00:03:15,700
So this is when the array is in the memory and every string of them is a separate consecutive variant.

44
00:03:15,850 --> 00:03:20,030
But it could happen that all of them are consecutive, but there is no guarantee for that.

45
00:03:20,320 --> 00:03:24,590
So practically speaking, we have won the array here and we have five one zero zero.

46
00:03:24,590 --> 00:03:33,460
So in total we have six different when the arrays here, the size of this array is as follows.

47
00:03:33,490 --> 00:03:36,190
We have five alignments, each element of the character.

48
00:03:36,340 --> 00:03:40,570
So the character is like eight bite one, one bite.

49
00:03:40,570 --> 00:03:41,240
So it fits.

50
00:03:41,440 --> 00:03:46,410
So this is an overall like a 40 in size.

51
00:03:48,510 --> 00:03:57,340
You notice here also that we can, uh, we can change the value here.

52
00:03:58,150 --> 00:04:04,510
OK, so we can change the the value here of the sports, for example.

53
00:04:07,390 --> 00:04:11,610
Now let's see another similar thing, if you would like to create here.

54
00:04:11,710 --> 00:04:17,170
This is a normal to the array of of three times the five of of integers here.

55
00:04:18,150 --> 00:04:25,470
Now, if I tried to create something to integrate with the array of three, this is a three pointer

56
00:04:25,530 --> 00:04:26,200
at the moment.

57
00:04:26,880 --> 00:04:31,790
Now you can iterate here and every one of these guys and create something like new enter by yourself

58
00:04:32,310 --> 00:04:33,490
now in the memory.

59
00:04:33,660 --> 00:04:39,810
This guy also represents some three times the five items you can now deal with, agree to exactly as

60
00:04:39,810 --> 00:04:40,950
dealing with the to the array.

61
00:04:40,950 --> 00:04:42,650
Normally nothing, nothing here.

62
00:04:43,080 --> 00:04:44,350
But notice the difference.

63
00:04:44,520 --> 00:04:50,460
This guy is one consecutive block of 15 integers, but this guy represents four different consecutive

64
00:04:50,820 --> 00:04:51,320
blocks.

65
00:04:51,690 --> 00:04:57,570
And if you would like to delete it, you have to delete every single element here because you created

66
00:04:57,570 --> 00:04:59,430
three vectors, you remove three factors.

67
00:04:59,730 --> 00:05:01,740
And this is a stack array.

68
00:05:01,770 --> 00:05:05,010
So you don't have to remove that set.
