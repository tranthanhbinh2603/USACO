0
1
00:00:00,810 --> 00:00:08,160
Another usable data structure is that the deque, so we know that the queue you can allow us to add usually in the
1

2
00:00:08,160 --> 00:00:15,810
in the back and it's more of like first-in, first-served, the deque allows us to add in the front and to add to the
2

3
00:00:15,810 --> 00:00:20,110
back and to remove from the front and to remove from the back.
3

4
00:00:20,340 --> 00:00:25,560
This is actually very similar to the queue that we wanted to implement to the hospital to implement to the
4

5
00:00:25,560 --> 00:00:26,820
emergency case.
5

6
00:00:26,950 --> 00:00:28,680
So it support a full of functionality:
6

7
00:00:28,920 --> 00:00:35,970
push_front, push_back for adding and the front and the back to get the item, pop_front, pop_back to remove
7

8
00:00:36,030 --> 00:00:43,080
to remove the item, size for how many elements, empty to check if there are any more elements or
8

9
00:00:43,080 --> 00:00:43,300
not.
9

10
00:00:43,960 --> 00:00:46,360
so yeah,
10

11
00:00:46,380 --> 00:00:50,370
as you see, we can now if would like to do some printing,
11

12
00:00:50,520 --> 00:00:54,360
you have to ask yourself, do I need to print from the back to end or end to back?
12

13
00:00:54,570 --> 00:00:56,350
this is very fixable data structure.
13

14
00:00:56,790 --> 00:01:01,830
So here is the code we are defining here a deque of integer,
14

15
00:01:02,220 --> 00:01:09,660
and then I started to push back in the front as it is empty it will be "20", push back in the "30" so it push
15

16
00:01:09,660 --> 00:01:14,000
back and push in the end "30", push back "40" is pushing back "40".
16

17
00:01:14,310 --> 00:01:16,110
Now we are pushing in the front "10",
17

18
00:01:16,110 --> 00:01:20,100
So it's going to the front and put "10", then push back "50",
18

19
00:01:20,100 --> 00:01:25,070
It's going in the end and push "50", push front zero is going to put in the front "0".
19

20
00:01:25,800 --> 00:01:34,200
If you used an assignment operator this way, you can make a copy of your queue, this is a deep copy,
20

21
00:01:34,470 --> 00:01:37,680
so this object is now very different from this object,
21

22
00:01:37,920 --> 00:01:41,420
if you changed the deque, the copy will not be changed.
22

23
00:01:41,850 --> 00:01:43,650
Now, let's say we would like to print them.
23

24
00:01:44,040 --> 00:01:49,170
The first function is "print back" for the q, so (print_back) is going to print from the back to
24

25
00:01:49,170 --> 00:01:49,650
the top,
25

26
00:01:49,650 --> 00:01:52,730
so here is the back so going to print 50, 40, 30 and so on.
26

27
00:01:53,160 --> 00:01:57,450
So here is a printed back function, it is taking a deque and in a very similar way
27

28
00:01:57,780 --> 00:02:02,600
while not q is empty, q.back, q.pop_back.
28

29
00:02:02,850 --> 00:02:07,230
So the observation here we are printing the back first, then we're removing it.
29

30
00:02:07,920 --> 00:02:12,930
The (print_front) is very similar but it is printing the front first, then removing it.
30

31
00:02:13,380 --> 00:02:16,800
here's an observation, the print_back(q)
31

32
00:02:16,890 --> 00:02:18,930
is not using reference
32

33
00:02:19,230 --> 00:02:20,670
this means that this
33

34
00:02:20,670 --> 00:02:22,920
queue will be a copy of this
34

35
00:02:22,920 --> 00:02:28,860
queue so now in memory we have two queues this one in the main and this one in the print_back function, by
35

36
00:02:28,860 --> 00:02:30,300
the end of the print_back function,
36

37
00:02:30,480 --> 00:02:36,780
this queue here in the function is empty, but this one in the memory is as it is, now calling print 
37

38
00:02:36,780 --> 00:02:37,260
front,
38

39
00:02:37,260 --> 00:02:40,550
I'm using the reference, the reference means it would be changed,
39

40
00:02:40,800 --> 00:02:44,520
so now this guy and this guy would be exactly the same in the memory.
40

41
00:02:44,820 --> 00:02:47,310
by the end of the print front, the queue would be empty,
41

42
00:02:47,610 --> 00:02:50,490
so if you try to print the front again, it will print nothing.
42

43
00:02:51,750 --> 00:02:54,390
So let's go back to the queue, to the copy,
43

44
00:02:54,570 --> 00:03:01,680
If you printed the size it is 6, there's another two interesting functionality in the deque, the first is you
44

45
00:03:01,680 --> 00:03:05,820
can deal with it as an array so you can say copy of [1],
45

46
00:03:05,970 --> 00:03:12,120
so think of this as an array copy of one is at position "10", you can also use the function copy.at
46

47
00:03:12,240 --> 00:03:12,990
one
47

48
00:03:13,350 --> 00:03:21,270
So what is the difference between them? the function .at is doing verification if you are accessing
48

49
00:03:21,310 --> 00:03:22,560
elements that exist or not,
49

50
00:03:22,890 --> 00:03:28,890
for example, if I try to say that .at(1000) it will throw an exception for you that
50

51
00:03:28,890 --> 00:03:31,290
you try to access an index that doesn't exist,
51

52
00:03:31,500 --> 00:03:33,750
but this function will crash a program directly.
52

53
00:03:35,820 --> 00:03:36,420
What else?
53

54
00:03:36,420 --> 00:03:39,810
You can clear the copy and then just check the size
54

55
00:03:39,810 --> 00:03:40,400
it would be zero.
55

56
00:03:40,620 --> 00:03:43,170
This is what the deque, so I would like to make
56

57
00:03:43,170 --> 00:03:48,900
with you like one funny practice with the deque, let's say that we have an "is_palindrome" function using
57

58
00:03:48,900 --> 00:03:49,440
a string,
58

59
00:03:50,070 --> 00:03:55,160
before that we used to stop at the first and the end and walk to the middle, then verify.
59

60
00:03:55,290 --> 00:03:57,600
so we check is with A with A and B with B.
60

61
00:03:57,750 --> 00:04:03,510
I would like to see how the deque implementation would make it like a more easier to code.
61

62
00:04:03,960 --> 00:04:09,540
First of all, we would iterate on the string put its character by character in the deque, so by the end
62

63
00:04:09,540 --> 00:04:12,910
of this operation that would have A, B, B, A,
63

64
00:04:13,470 --> 00:04:15,920
now, the idea would be as following.
64

65
00:04:16,050 --> 00:04:20,700
we will iterate on the whole palindrome, take character from the front, and take character from the end,
65

66
00:04:20,970 --> 00:04:25,620
so here we take the character from the front and we remove it, character from the back and we remove
66

67
00:04:25,620 --> 00:04:25,740
it,
67

68
00:04:25,980 --> 00:04:28,350
if they are an equal, we just return false.
68

69
00:04:28,590 --> 00:04:31,590
So it first takes A&A, then takes B&B.
69

70
00:04:31,890 --> 00:04:35,430
So this is how the front and back would be very helpful in something like this
70

71
00:04:35,430 --> 00:04:40,020
palindrome and there are some cases here, there is an interesting serie here,
71

72
00:04:40,040 --> 00:04:46,080
You see, I say "cout boolalpha", this is an internal flag in C++,
72

73
00:04:46,320 --> 00:04:52,930
If you did that instead of printing in zeros and ones, is going to print true and false.
73

74
00:04:52,950 --> 00:04:53,190
That's it.
