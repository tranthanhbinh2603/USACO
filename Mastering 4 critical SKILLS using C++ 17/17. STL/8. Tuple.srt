0
1
00:00:01,140 --> 00:00:08,210
Similar to the pair, There is also a tuple in C++, Tuple is more of a generalization of a pair, So in pair,
1

2
00:00:08,910 --> 00:00:14,430
It allowed us to have a specific couple of items but in tuple you can have as much as you code.
2

3
00:00:14,430 --> 00:00:17,250
Remember, In pair and in tuple,
3

4
00:00:17,430 --> 00:00:22,980
The interesting really thing is you have like a data structure of different data types,
4

5
00:00:22,980 --> 00:00:28,320
So you can think of it as an array of different types. Here we are defining a tuple close to the definition
5

6
00:00:28,320 --> 00:00:30,040
of the pair of three items.
6

7
00:00:30,330 --> 00:00:36,810
The first would be char, int, and string to create a tuple to initialize it to these items.
7

8
00:00:36,820 --> 00:00:42,390
One easy way is to say t1 equal make tuple and then you start to assign values corresponding to
8

9
00:00:42,390 --> 00:00:48,020
the values here. The way that we get and send the value is a bit inconvenient.
9

10
00:00:48,030 --> 00:00:54,270
Your write here get then you write here the position then you write the tuple name,
10

11
00:00:54,480 --> 00:00:56,720
So get zero is for the first position,
11

12
00:00:56,970 --> 00:00:59,970
Get one is for the second position. In a similar way,
12

13
00:00:59,970 --> 00:01:01,110
You can set it this way.
13

14
00:01:01,300 --> 00:01:04,260
So just try to use it in this syntax.
14

15
00:01:04,620 --> 00:01:12,330
The weird thing here is like you are trying to use a position inside the less than and greater than.
15

16
00:01:13,530 --> 00:01:17,040
Similar to the pair, The comparisons are all supported in the tuples.
16

17
00:01:17,040 --> 00:01:20,730
So you can start to compare them, It is going to compare them one by one.
17

18
00:01:21,130 --> 00:01:26,730
So if the first element is equal then it moves to the second element, If they are equal, It moves
18

19
00:01:26,740 --> 00:01:33,000
to the third element and so on till it comes to an element that is different then it is used and applied 
19

20
00:01:33,000 --> 00:01:35,420
the comparator based on it.
20

21
00:01:36,510 --> 00:01:39,320
There is also something interesting in C++ named tie.
21

22
00:01:39,390 --> 00:01:41,820
We use the tie several times for comparisons.
22

23
00:01:42,210 --> 00:01:47,380
So now it's time to know that the tie is actually more of kind of creating a tuple here.
23

24
00:01:47,760 --> 00:01:53,490
So one thing here that the tie is helping us in breaking items, unpacking items.
24

25
00:01:53,850 --> 00:01:59,460
So let's say that you would like to separate these three items and really three different types.
25

26
00:01:59,870 --> 00:02:08,130
If you did tie with this Syntex equal T1, It is going to break this representation to
26

27
00:02:08,130 --> 00:02:13,080
these three items, If you are coming from something like Python language then this should be very
27

28
00:02:13,080 --> 00:02:13,620
easy for you.
28

29
00:02:13,620 --> 00:02:17,860
It usually can break something into the corresponding items this way.
29

30
00:02:18,510 --> 00:02:25,710
Finally, there is also in C++ the tuple cat, Which can take two tuples and just concatenate them
30

31
00:02:25,710 --> 00:02:25,980
here.
31

32
00:02:26,250 --> 00:02:34,280
So this is tuple number one and we are creating one more tuple with like one value here and so on.
32

33
00:02:34,290 --> 00:02:38,120
In C++ 17,
33

34
00:02:38,130 --> 00:02:39,720
there's a different syntax for that 
34

35
00:02:40,080 --> 00:02:41,070
but be careful.
35

36
00:02:41,350 --> 00:02:45,240
Don't run an example for C++ 14 unless you are
36

37
00:02:45,270 --> 00:02:47,040
make sure your compiler support 14.
37

38
00:02:47,040 --> 00:02:51,820
Don't write it for 17 unless it supports 17. That's it.
