0
1
00:00:02,160 --> 00:00:04,860
Today, we will discuss about the character array.
1

2
00:00:06,340 --> 00:00:12,610
But let's first refresh more about the characters, remember, we once said that every character is
2

3
00:00:12,610 --> 00:00:14,720
eventually Internally is just a number.
3

4
00:00:14,740 --> 00:00:21,760
We already did this conversion before and we saw that the letter A is at the range of 56.
4

5
00:00:21,970 --> 00:00:25,410
And the small letter a is at the range of 79.
5

6
00:00:25,750 --> 00:00:26,890
We can notice also that
6

7
00:00:26,890 --> 00:00:30,160
ABC they are it seems here also consecutive.
7

8
00:00:30,760 --> 00:00:37,660
Now this is a bit interesting that we can, given that, from A to Z are just consecutive,
8

9
00:00:37,870 --> 00:00:44,560
We can if we have the letter A here and we increment it 26 - 1, we're going to get also
9

10
00:00:44,560 --> 00:00:45,100
90 by ourselves.
10

11
00:00:46,060 --> 00:00:52,210
So this means a very interesting fact that we can just put character here with 90 and just print it,
11

12
00:00:52,210 --> 00:00:55,060
it is going to be Z. so we can play with math,
12

13
00:00:55,210 --> 00:00:56,290
when it comes to characters.
13

14
00:00:56,470 --> 00:00:58,710
The same conclusions comes here.
14

15
00:00:59,410 --> 00:01:00,370
How is that useful?
15

16
00:01:00,760 --> 00:01:05,650
This is very useful, for example, in conversions between uppercase and lowercase.
16

17
00:01:05,800 --> 00:01:12,210
Let's see how, first of all, this program is going to read here a character and doublecheck,
17

18
00:01:12,220 --> 00:01:13,840
if this is an upper letter or not?
18

19
00:01:14,320 --> 00:01:20,530
Given the math, we know that letters from A to Z are just consecutive, so we can double-check
19

20
00:01:20,530 --> 00:01:25,330
if ch1 is >= A or less than or Z.
20

21
00:01:25,540 --> 00:01:27,910
If this is the case, then this is an upper letter.
21

22
00:01:28,460 --> 00:01:30,550
Now here is more interesting thing,
22

23
00:01:30,730 --> 00:01:37,180
We can convert it to a lowercase, how? if you subtracted - A from it, it now becomes zero.
23

24
00:01:37,540 --> 00:01:44,650
If you added 'a' for it, it now becomes 'a', what if this is D, D - A, it is going to be
24

25
00:01:44,860 --> 00:01:50,410
I think 4, when you add the small 'a', is going to convert it to 'd' small.
25

26
00:01:50,710 --> 00:01:56,650
So this is how you convert an uppercase to lowercase, in the same way you can convert the lowercase
26

27
00:01:56,650 --> 00:01:57,280
to uppercase.
27

28
00:01:58,740 --> 00:02:03,690
If you'd like to double-check if it's lower case, in a very similar case, we should say if ch1
28

29
00:02:03,690 --> 00:02:12,090
is greater than or equal 'a' I'm sorry, this is 'a' small, up to character 'z'.  else here, if you'd like
29

30
00:02:12,090 --> 00:02:18,150
to check if it's digit, also, digit, but digit as a character, you can say if it is '0' here up to
30

31
00:02:18,150 --> 00:02:18,730
'9' here.
31

32
00:02:19,200 --> 00:02:27,770
So the moral of that is, given that C++ implemented the characters as integers and they are also consecutive,
32

33
00:02:28,020 --> 00:02:34,020
this means we can easily double-check the type of the character and we can also do conversion between
33

34
00:02:34,020 --> 00:02:35,650
some of the types.
34

35
00:02:35,670 --> 00:02:37,890
Please make sure that you understand what I said here.
35

36
00:02:39,210 --> 00:02:42,330
Let's go back to to arrays and strings.
36

37
00:02:43,830 --> 00:02:51,600
Remember, we did before something we called string name, like string name = "Hany" or "John" or whatever.
37

38
00:02:52,080 --> 00:02:55,530
Now look to this very interesting access,
38

39
00:02:55,530 --> 00:03:00,730
I'm saying name.size() and these two parentheses,
39

40
00:03:01,030 --> 00:03:03,390
This is our first time to use
40

41
00:03:03,390 --> 00:03:03,720
this style.
41

42
00:03:04,470 --> 00:03:07,740
This is called a method or a member function.
42

43
00:03:08,370 --> 00:03:15,390
And it's going to return for you the size of this array, which is here 4. we experienced before
43

44
00:03:15,390 --> 00:03:16,050
the name here.
44

45
00:03:16,290 --> 00:03:19,530
And I just would like you to memorize this syntax here for now.
45

46
00:03:19,650 --> 00:03:23,760
You put the dot "." without spaces, then size, then these two parenthesis.
46

47
00:03:24,930 --> 00:03:27,470
Now, if we know that this array is 4.
47

48
00:03:28,230 --> 00:03:30,030
Check out this interesting syntax.
48

49
00:03:30,240 --> 00:03:33,600
We say "for (int i = 0; i < sz; ++i).
49

50
00:03:33,600 --> 00:03:35,300
cout << name[i];".
50

51
00:03:35,460 --> 00:03:40,420
This is also going to print to the same one here, but is printing it letter by letter.
51

52
00:03:40,770 --> 00:03:46,210
What is very interesting here for us is that we can deal with the string name as an array.
52

53
00:03:46,280 --> 00:03:46,760
Why?
53

54
00:03:47,040 --> 00:03:49,480
Because internally it is an array,
54

55
00:03:49,530 --> 00:03:51,200
it is just a sequence of characters.
55

56
00:03:51,210 --> 00:03:52,350
It is just a char array.
56

57
00:03:52,680 --> 00:03:53,370
That's it.
57

58
00:03:54,240 --> 00:04:00,810
And today it's a good chance to know how actually this string is represented internally.
58

59
00:04:00,870 --> 00:04:02,340
This is mainly coming from C..
59

60
00:04:03,720 --> 00:04:06,720
I would like here to represent array of integer.
60

61
00:04:06,720 --> 00:04:07,800
We just do it this way,
61

62
00:04:07,800 --> 00:04:10,350
Integer numbers of five "int numbers [5]", which means five numbers.
62

63
00:04:10,860 --> 00:04:13,020
If we would like to create a double array, we create a double array.
63

64
00:04:13,620 --> 00:04:15,520
What about character array?
64

65
00:04:15,690 --> 00:04:22,460
It's also the same logic, we say char name1[5] =  Heni, wait a second, Hani
65

66
00:04:22,500 --> 00:04:23,840
Here is 4 letters.
66

67
00:04:24,180 --> 00:04:25,520
Why do we put 5?
67

68
00:04:25,890 --> 00:04:27,360
We will know after a minute,
68

69
00:04:27,790 --> 00:04:34,690
OK. but just keep in mind that, the length must be 1 + your expected size.
69

70
00:04:35,010 --> 00:04:38,580
We can also use name3, all of them when printed would be just Hani,
70

71
00:04:38,650 --> 00:04:42,450
OK. but this is more of C style and this is C++ style.
71

72
00:04:43,980 --> 00:04:52,680
So let's go back to the story of the extra position, when we define character name1[4], C++
72

73
00:04:52,690 --> 00:04:59,490
would like to give us this nice functionality of printing name1, when we were dealing with integer arrays, we never
73

74
00:04:59,490 --> 00:05:01,680
did something like cout an array.
74

75
00:05:02,160 --> 00:05:08,510
C++ wanted to give us a very conventional method to just cout a character name.
75

76
00:05:08,910 --> 00:05:09,920
This is very interesting,
76

77
00:05:09,930 --> 00:05:10,890
But where is the problem?
77

78
00:05:11,250 --> 00:05:16,740
The problem is internally, C++ doesn't know actually the size of this array.
78

79
00:05:16,770 --> 00:05:19,910
This has been reserved by the compiler in a way or another.
79

80
00:05:20,700 --> 00:05:26,360
When we put the word Hani, and we try to output it, you see here, this means garbage
80

81
00:05:26,370 --> 00:05:26,770
here.
81

82
00:05:26,790 --> 00:05:28,050
Something wrong in the memory.
82

83
00:05:28,680 --> 00:05:37,800
So C++ wanted us to tell the compiler when the string really ends, so this is where the null character
83

84
00:05:37,800 --> 00:05:38,160
comes.
84

85
00:05:38,370 --> 00:05:44,820
That's why we have 5 here not just 4, and we put here the backslash zero '\0'.
85

86
00:05:45,120 --> 00:05:46,470
This is called the null character.
86

87
00:05:46,680 --> 00:05:50,370
And this backslash, it is something called escape character,
87

88
00:05:50,370 --> 00:05:51,170
We will know about it.
88

89
00:05:51,570 --> 00:05:52,710
So now here you notice,
89

90
00:05:52,930 --> 00:05:55,110
when we wanted to create 4 elements,
90

91
00:05:55,230 --> 00:05:57,690
We needed to 5 elements.
91

92
00:05:57,840 --> 00:06:00,750
we needed 5, and we needed to mark the null character here.
92

93
00:06:01,560 --> 00:06:02,970
Let's make it more clear,
93

94
00:06:03,360 --> 00:06:09,270
When the C++ compiler sees the null character in the runtime, it just stops printing.
94

95
00:06:09,390 --> 00:06:17,700
For example, if someone came here at name1 and put this second letter with '\0', which
95

96
00:06:17,700 --> 00:06:18,510
is a null character.
96

97
00:06:18,840 --> 00:06:25,170
If we try to print name1, it is going to print only 'H' because the compiler at runtime will stop once it
97

98
00:06:25,170 --> 00:06:32,610
saw the '\0'. so '\0' or the null character, its main purpose is being a Terminator.
98

99
00:06:32,730 --> 00:06:34,740
It tells where to stop and when to stop.
99

100
00:06:36,320 --> 00:06:37,130
That's it for today.
