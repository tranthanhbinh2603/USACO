0
1
00:00:01,710 --> 00:00:08,940
Let's solve homework set number 2. The first one is compressing; the core of the idea is very, very
1

2
00:00:08,940 --> 00:00:12,990
close to the grouping idea, but the code might be a bit problematic for you.
2

3
00:00:14,460 --> 00:00:17,340
I'm writing it here in this way, which you might be a little more.
3

4
00:00:17,370 --> 00:00:21,210
You probably can write it in less code, but maybe this is more organized.
4

5
00:00:21,240 --> 00:00:21,600
Maybe.
5

6
00:00:23,040 --> 00:00:28,650
The first trick here that I would like to teach is: sometimes we can alter the input to make our
6

7
00:00:28,650 --> 00:00:29,600
life much easier.
7

8
00:00:29,940 --> 00:00:34,320
When you try to develop this code, this problem, you would need that observe....
8

9
00:00:34,320 --> 00:00:40,320
You might need extra handling for the last group in the input, if we would like our code to
9

10
00:00:40,320 --> 00:00:45,810
be handling everything and we don't have to do something after the last inputs
10

11
00:00:45,810 --> 00:00:48,600
here to verify one more last group.
11

12
00:00:48,960 --> 00:00:56,640
This is a very nice idea to add an artificial thing to your string that can help you to make
12

13
00:00:56,640 --> 00:01:01,710
sure that your same code is doing the same handling. Observe here in this problem,
13

14
00:01:01,710 --> 00:01:02,980
the input is only letters.
14

15
00:01:03,010 --> 00:01:06,480
So I can add this letter safely.
15

16
00:01:06,840 --> 00:01:11,050
You have to make sure that you are not adding something that can be part of the input itself.
16

17
00:01:13,130 --> 00:01:19,610
After that, I started to turn it on the string, but I started from one because this time you are not printing
17

18
00:01:19,610 --> 00:01:21,740
letter by letter, we would print group by group.
18

19
00:01:21,740 --> 00:01:26,370
So instead of keeping comparing if "i" not equal zero, we don't need that now.
19

20
00:01:26,930 --> 00:01:31,250
So I started my first group with size one and then I started here from one.
20

21
00:01:31,400 --> 00:01:32,960
And then you can keep going here.
21

22
00:01:33,470 --> 00:01:34,880
Similar to the previous time.
22

23
00:01:34,880 --> 00:01:37,330
If they are in equal letters then we have a new group.
23

24
00:01:37,910 --> 00:01:41,060
Now we would like to separate the groups by underscore.
24

25
00:01:41,840 --> 00:01:44,330
To do that I use the here this symbol letter;
25

26
00:01:44,330 --> 00:01:46,250
If is_first_ group or not.
26

27
00:01:46,430 --> 00:01:47,510
Very simple boolean.
27

28
00:01:47,520 --> 00:01:52,330
If it's not the first group, we can always print the underscore.
28

29
00:01:52,640 --> 00:01:58,250
Otherwise, if it's first time, we don't and we keep assigning this here to be zero to indicate it
29

30
00:01:58,250 --> 00:01:59,660
isn't a first group anymore.
30

31
00:02:00,050 --> 00:02:03,730
This way I handled the underscore between the groups in an easy way.
31

32
00:02:04,370 --> 00:02:08,690
The remaining thing is just to print the current group, which is the previous character and the size
32

33
00:02:08,690 --> 00:02:09,110
of it.
33

34
00:02:09,620 --> 00:02:12,380
And remember that "i" is starting from one.
34

35
00:02:12,380 --> 00:02:14,820
So "i" minus one would be a valid indexing.
35

36
00:02:15,110 --> 00:02:20,240
Again, you might be able to write that in an easier way, but maybe this is clear enough.
36

37
00:02:20,300 --> 00:02:20,810
Hopefully.
37

38
00:02:24,790 --> 00:02:25,590
Yeah, let's stop here.
