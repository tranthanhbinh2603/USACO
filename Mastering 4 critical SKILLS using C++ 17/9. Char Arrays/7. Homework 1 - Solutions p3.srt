0
1
00:00:01,140 --> 00:00:07,350
The third problem in that is Substring problem, which might be a bit harder than the first and the
1

2
00:00:07,350 --> 00:00:14,180
second. The problem in the substring problem, we can have a match anywhere in the string.
2

3
00:00:14,400 --> 00:00:16,590
So we need to know to do like a brute force.
3

4
00:00:16,590 --> 00:00:18,330
We need to try every possible thing.
4

5
00:00:18,810 --> 00:00:23,030
That's why I'm starting here, to try every possible position in big_str,
5

6
00:00:23,460 --> 00:00:25,860
so "i" is every possible string.
6

7
00:00:26,160 --> 00:00:30,000
And then for the small string, we will iterate on j with the small string.
7

8
00:00:30,000 --> 00:00:35,730
And I start to compare the big to the small one, for example, let's say that the
8

9
00:00:35,730 --> 00:00:42,710
big one is aabcd and the small one is for example abc.
9

10
00:00:43,230 --> 00:00:53,040
Now I need to try the aab with abc and then try abc with abc, then try bcd
10

11
00:00:53,250 --> 00:00:54,570
with abc.
11

12
00:00:55,110 --> 00:00:59,850
So that's what I mean by trying every possible position.  Observe that the last
12

13
00:00:59,850 --> 00:01:01,860
possible position to try is from bcd
13

14
00:01:02,100 --> 00:01:07,680
doesn't make any sense to convert from c because cd would be only two letters and this guy is three
14

15
00:01:07,680 --> 00:01:08,060
letters.
15

16
00:01:08,430 --> 00:01:13,500
That's why here I am actually trying to decide what is the last position to stop.
16

17
00:01:14,040 --> 00:01:19,800
And this is simply we need to stop....; we do need to iterate more
17

18
00:01:20,430 --> 00:01:24,240
if the length of the end of the string is less than this one,
18

19
00:01:24,240 --> 00:01:25,730
we do need to keep going.
19

20
00:01:26,550 --> 00:01:31,040
So I'm here subtracting the length of the small_str
20

21
00:01:31,040 --> 00:01:36,150
from the big_str to count for that. Observer that this is one-based string and this
21

22
00:01:36,150 --> 00:01:41,280
is one-based size, one-based minus one-based would be zero-based that's why I'm adding here
22

23
00:01:41,470 --> 00:01:43,200
a +1 make sure it is valid.
23

24
00:01:43,800 --> 00:01:49,680
If you would like to think in terms of low boundary, think that this is one letter and this is one
24

25
00:01:49,680 --> 00:01:50,040
letter.
25

26
00:01:50,220 --> 00:01:54,980
So one minus one is zero, plus one is very important to iterate at least one step.
26

27
00:01:57,060 --> 00:02:03,000
Also, if the two strings are empty, this would be zero and zero then plus one would
27

28
00:02:03,000 --> 00:02:05,940
also get inside but still would be valid.
28

29
00:02:06,660 --> 00:02:11,640
It is very important when you are dealing with the size to cast two integers. Somewhere in the course, 
29

30
00:02:11,640 --> 00:02:13,740
I will tell, I will let you know what's happening
30

31
00:02:13,740 --> 00:02:17,700
if you didn't cast this integer with an empty string, it will work for infinity.
31

32
00:02:18,120 --> 00:02:23,190
So always cast for now, this integer here at avoid problems.
32

33
00:02:23,850 --> 00:02:26,190
Now let's say that we have this position
33

34
00:02:26,190 --> 00:02:29,760
"i" and I would like to match the internal substring with it.
34

35
00:02:30,120 --> 00:02:35,820
I'm just going to iterate over the small_str and compare the current small_str with the
35

36
00:02:35,820 --> 00:02:39,240
big_str. If it doesn't match, our marking is matched with false.
36

37
00:02:39,870 --> 00:02:42,420
If it happen that one string is done correctly,
37

38
00:02:42,810 --> 00:02:48,210
once everything is done correctly then we have in his match with True. we see out "YES" and just return.
38

39
00:02:48,570 --> 00:02:49,620
That's all about this one.
