0
1
00:00:00,660 --> 00:00:05,910
In this video, we will highlight some of the common mistakes when it comes to exceptions to keep in
1

2
00:00:05,910 --> 00:00:13,770
mind. The first thing is, as we said, there is an approach for using error codes and there is another
2

3
00:00:13,770 --> 00:00:18,720
approach for exception handling. Some guys would tell you don't use exception handling because it's
3

4
00:00:18,720 --> 00:00:20,760
very expensive (resources wise
4

5
00:00:20,760 --> 00:00:24,290
I mean), but however, this isn't a proper advice.
5

6
00:00:24,600 --> 00:00:28,470
The current model implementation of exception handling is very efficient,
6

7
00:00:28,920 --> 00:00:34,910
and the exception handling, in the opinion of many guys, is a very strong mechanism to deal with
7

8
00:00:35,040 --> 00:00:35,630
exceptions.
8

9
00:00:35,850 --> 00:00:39,840
So this isn't a reason or an excuse to avoid exception handling.
9

10
00:00:41,500 --> 00:00:48,250
The second rule is: some guys might try to do some mixing for the exception handling with the error codes.
10

11
00:00:48,760 --> 00:00:50,900
Probably, this might not be a good idea.
11

12
00:00:51,220 --> 00:00:55,510
It's good to stick to one approach to avoid issues in your software.
12

13
00:00:56,590 --> 00:01:02,590
The third advice here is to avoid using exceptions for normal code flow.
13

14
00:01:02,950 --> 00:01:08,320
Remember, the exception is an indicator that something is really broken, something is really invalid.
14

15
00:01:08,810 --> 00:01:15,160
If your function can handle wrong parameters, for example, in a meaningful way, then
15

16
00:01:15,160 --> 00:01:15,640
do it.
16

17
00:01:15,850 --> 00:01:19,420
So the exception is something that might terminate your program,
17

18
00:01:19,750 --> 00:01:26,260
there is some missing handling. So do not use an exception for no reason, use it because
18

19
00:01:26,260 --> 00:01:29,830
there is a good reason, and there is something, for example, blocking for us.
19

20
00:01:32,320 --> 00:01:37,630
Also, one advice is don't throw an exception for a constructor.
20

21
00:01:37,840 --> 00:01:38,810
This is a common mistake.
21

22
00:01:39,050 --> 00:01:41,620
It's OK to throw an exception from a constructor.
22

23
00:01:41,650 --> 00:01:46,180
Nothing wrong about that actually is a good idea because constructor cannot return a value.
23

24
00:01:46,930 --> 00:01:51,730
Some guys may say that it's also OK to throw an exception in destructures,
24

25
00:01:51,910 --> 00:01:53,140
and this isn't OK.
25

26
00:01:53,140 --> 00:02:00,430
your stack unwinding may fail to handle the different exceptions that are throwing together
26

27
00:02:00,430 --> 00:02:00,880
this way.
27

28
00:02:04,850 --> 00:02:16,670
Some guys throw an exception by value, not by reference.
28

29
00:02:17,510 --> 00:02:22,430
So there is a big difference between throwing by value and throwing by reference.
29

30
00:02:22,760 --> 00:02:29,690
Remember, if it's a pointer, for example, to some local variable and you try to return to some reference
30

31
00:02:29,690 --> 00:02:30,080
for it,
31

32
00:02:30,380 --> 00:02:32,710
this reference is going to be destroyed,
32

33
00:02:33,080 --> 00:02:38,520
and if you tried to throw a dynamic memory, for example, then this is also a problem.
33

34
00:02:38,520 --> 00:02:38,910
Why?
34

35
00:02:38,990 --> 00:02:39,920
For two reasons:
35

36
00:02:40,170 --> 00:02:48,490
Let's say you are trying to return some pointer to the error itself.
36

37
00:02:50,060 --> 00:02:56,480
Scenario number one is: if you are actually failing in a bad_alloc scenario like you tried to create
37

38
00:02:56,480 --> 00:03:02,270
something as a bad_alloc, and now while you are throwing it, you are trying to create new memories and
38

39
00:03:02,330 --> 00:03:05,660
you already are suffering from a new memory issue.
39

40
00:03:05,780 --> 00:03:08,080
So this is one issue in throwing pointers.
40

41
00:03:08,860 --> 00:03:12,650
Another issue is: when you throw created dynamically pointer,
41

42
00:03:13,890 --> 00:03:20,490
then the caller has to remove it, and this is still now confusing about the responsibility of freeing
42

43
00:03:20,490 --> 00:03:20,920
a pointer.
43

44
00:03:21,120 --> 00:03:22,350
So be careful about that.
44

45
00:03:24,740 --> 00:03:29,420
So always through by value.
45

46
00:03:29,460 --> 00:03:32,310
This is the moral of the advice here.
46

47
00:03:34,790 --> 00:03:41,600
The second idea here about the catching itself. When you try to catch, it is a good idea to catch by reference,
47

48
00:03:41,900 --> 00:03:49,580
because if you didn't try to catch by reference, you will end up copying the object itself
48

49
00:03:49,790 --> 00:03:53,030
twice, which is problematic. There is also in the future
49

50
00:03:53,030 --> 00:03:54,860
something called object slicing problem.
50

51
00:03:54,860 --> 00:03:58,270
I would like you after reading OOP to come back and read about it.
51

52
00:04:00,190 --> 00:04:07,330
Another issue is: if you are marking the function with no_except, although you didn't do enough effort,
52

53
00:04:07,330 --> 00:04:12,430
verify that there were no exceptions that would be thrown from this function.
53

54
00:04:14,300 --> 00:04:21,480
A common issue is to swallow an exception like you are hiding the exception. You are doing some
54

55
00:04:21,530 --> 00:04:26,220
try-catch that catch anything, and then you are just blocking it, and you let your program keep going,
55

56
00:04:26,540 --> 00:04:27,500
but there is an exception.
56

57
00:04:27,500 --> 00:04:28,900
There is something wrong in the flow.
57

58
00:04:29,210 --> 00:04:30,550
We should handle exceptions.
58

59
00:04:30,890 --> 00:04:31,730
Can you handle it?
59

60
00:04:31,730 --> 00:04:33,280
Handle it. Can you can't handle it?
60

61
00:04:33,470 --> 00:04:36,840
You throw it back to the caller and so on.
61

62
00:04:37,400 --> 00:04:43,340
Finally, as we learned, there is a big difference between when you say throw and throw e.
62

63
00:04:43,340 --> 00:04:45,450
The throw doesn't create copies, which is good.
63

64
00:04:45,650 --> 00:04:51,560
So as you see, we have here a few relevant things like - Are you going to throw by value or throwing from
64

65
00:04:51,560 --> 00:04:52,100
reference?
65

66
00:04:52,550 --> 00:04:54,970
Are you going to catch by value or by reference?
66

67
00:04:55,270 --> 00:04:57,080
Are you going to throw E or throw?
67

68
00:04:57,320 --> 00:05:02,300
All of them are relevant to the memory and what's happening behind the scene. That's it.
