0
1
00:00:01,200 --> 00:00:07,050
Let's practice on for-loops, the practice on for-loops isn't different in any way from practicing
1

2
00:00:07,050 --> 00:00:07,760
on while-loops.
2

3
00:00:07,770 --> 00:00:09,570
It's more of a different structures.
3

4
00:00:11,230 --> 00:00:17,120
The special sum Program is a program from the latest homework on the while-loops.
4

5
00:00:17,460 --> 00:00:24,690
So let's see how this homework can be written in terms of a for-loop.
5

6
00:00:26,430 --> 00:00:28,440
We need one for-loop,
6

7
00:00:28,500 --> 00:00:32,040
We need to iterate on three things here.
7

8
00:00:32,400 --> 00:00:34,710
We need to iterate on the number of test cases.
8

9
00:00:34,950 --> 00:00:37,170
So I'm here doing it for convenient as while-loop.
9

10
00:00:37,380 --> 00:00:44,130
So I'm reading here the T and saying "while(T--)", so the body here is just anyway we are going
10

11
00:00:44,130 --> 00:00:52,980
to read T, so while (T--) would be enough to do the condition and to do the subtraction, and this is
11

12
00:00:52,980 --> 00:00:55,160
one of the nice cases for the postfix
12

13
00:00:55,180 --> 00:01:01,010
Operator, if you look to it, you see here, let's say that T is 5.
13

14
00:01:01,020 --> 00:01:06,720
So you say while T--, we know the value of the T, is going to be evaluated first,
14

15
00:01:06,760 --> 00:01:08,120
then later the --.
15

16
00:01:08,460 --> 00:01:10,560
So while 5, is 5 true?
16

17
00:01:10,560 --> 00:01:10,860
Yes, five true
17

18
00:01:10,860 --> 00:01:16,140
and then 5, 4, 3, 2, 1, when T is 0,
18

19
00:01:16,560 --> 00:01:21,060
The while-loop is going to be broken and T here will end up with -1.
19

20
00:01:21,300 --> 00:01:26,660
So this is the first while-loop, you can think of it here a while
20

21
00:01:26,670 --> 00:01:27,350
(T--)
21

22
00:01:27,390 --> 00:01:30,990
This is a shortcut for while (T-- Not equal 0).
22

23
00:01:31,260 --> 00:01:38,580
And if this is hard code for you, you could just say "while" and put here T--.
23

24
00:01:38,640 --> 00:01:40,410
But just for convenient we do it this way.
24

25
00:01:41,040 --> 00:01:44,640
The second loop that we need is a loop that is going to read the N values.
25

26
00:01:44,970 --> 00:01:50,300
So we are going here to read N, and then we are going to do a for-Loop to read N number values,
26

27
00:01:50,480 --> 00:01:54,330
OK. so this is a classical way to do the for loop, i = 0;
27

28
00:01:54,330 --> 00:01:57,180
i < N; ++i, then we read the value.
28

29
00:01:57,780 --> 00:02:04,940
The third nested loop is that we need to iterate up to i times to multiply the value.
29

30
00:02:05,220 --> 00:02:08,430
So let's say i is 0 then we need to iterate for one step.
30

31
00:02:08,430 --> 00:02:09,930
that's way we have here the + 1.
31

32
00:02:10,350 --> 00:02:15,570
If i is 5, we need to iterate here 5 + 1,
32

33
00:02:15,600 --> 00:02:19,640
OK. if you put here less than and equal "<=" you can just remove the + 1.
33

34
00:02:19,950 --> 00:02:22,770
So this inner loop is just iterating for us
34

35
00:02:23,100 --> 00:02:27,530
(i + 1) times here and then, then we have the sum.
35

36
00:02:27,930 --> 00:02:29,980
So this way we ended the code.
36

37
00:02:30,240 --> 00:02:37,080
As you notice here, these two for-loops made the code look much more elegant than we were
37

38
00:02:37,080 --> 00:02:38,810
doing using while-loops.
38

39
00:02:40,210 --> 00:02:49,300
Let's go more, we are to read 3 numbers, N and M and sum, we would like to find all the pair of numbers
39

40
00:02:49,300 --> 00:02:57,760
such that A + B == to the sum value, A is a number ranging between 1 to N and B is a
40

41
00:02:57,760 --> 00:03:03,100
number ranging between 1 to M. So we would like to find all the pairs of numbers
41

42
00:03:03,170 --> 00:03:09,610
That satisfy this condition. try to stop the video, write it, challenge yourself, and try also the following
42

43
00:03:09,610 --> 00:03:13,720
inputs and think about how many number of steps can your code do.
43

44
00:03:16,210 --> 00:03:21,670
This is the program, if you would like to find all the pairs of them, then we need one loop to iterate
44

45
00:03:21,670 --> 00:03:24,240
on N and one loop to iterate on M.
45

46
00:03:24,580 --> 00:03:26,980
And given that we are targeting 1 to N,
46

47
00:03:26,990 --> 00:03:33,400
So I made here the condition to start from 1 end to N, start from 1 end to M. and then I'm
47

48
00:03:33,400 --> 00:03:34,060
telling here,
48

49
00:03:34,270 --> 00:03:41,980
If i + j == sum, then we satisfied the condition, let's count it, this loop, this way we are
49

50
00:03:41,980 --> 00:03:45,100
actually iterating on every pair of number.
50

51
00:03:45,400 --> 00:03:50,140
So if I told you to find all pairs, we are expected to do 2 for-loops nested.
51

52
00:03:50,420 --> 00:03:55,490
If I told you to find all triples, you are expected to do three loops, before proceeding more,
52

53
00:03:55,510 --> 00:03:57,310
It's very important to understand this code.
53

54
00:03:58,330 --> 00:04:00,330
Let's now, make this code a bit faster.
54

55
00:04:00,610 --> 00:04:05,110
This is a very simple math trick, that we can actually remove the whole second loop.
55

56
00:04:05,380 --> 00:04:09,220
If you noticed, the previous code was very very very slow
56

57
00:04:09,260 --> 00:04:09,660
code.
57

58
00:04:09,730 --> 00:04:14,850
If you enter something like one million, it's going to do one million times one million operations.
58

59
00:04:15,430 --> 00:04:19,260
And this way we're going to do simple math to remove the second loop.
59

60
00:04:19,690 --> 00:04:26,620
The observation was as following: the previous loop, the nested loop, was actually activated only once
60

61
00:04:26,620 --> 00:04:28,590
in the whole loop, only once.
61

62
00:04:28,810 --> 00:04:33,960
So it's actually like we are iterating M times for only one value to be right.
62

63
00:04:34,240 --> 00:04:35,970
So we just get it by math here.
63

64
00:04:36,400 --> 00:04:43,990
So now we know if we are reading i, and the condition was that i + j == sum, this means that
64

65
00:04:43,990 --> 00:04:45,000
j = sum - i
65

66
00:04:45,370 --> 00:04:46,810
So we are here to compute
66

67
00:04:46,810 --> 00:04:52,530
The "j = sum - i" and then we are verifying that j is really between the 1 to M range.
67

68
00:04:52,870 --> 00:04:59,080
If this is true, then we count (cnt++), this is how we switch the code to one loop only.
68

69
00:05:00,910 --> 00:05:06,850
What's very important here is that if you thought about this code, it just likes one million step times
69

70
00:05:07,030 --> 00:05:10,090
some simple fact like say here, three million steps.
70

71
00:05:10,540 --> 00:05:18,640
But if you compare the other code, it's actually 3 * 10¹² steps.
71

72
00:05:19,150 --> 00:05:27,070
And now this takes you to a very new thing that we call it efficiency, and efficient
72

73
00:05:27,070 --> 00:05:29,860
code is something that's much faster than a slow code.
73

74
00:05:30,430 --> 00:05:37,030
The difference between a good programmer and a weak programmer is that a good programmer can write much
74

75
00:05:37,030 --> 00:05:40,650
faster code and can figure out what is wrong with the code.
75

76
00:05:40,930 --> 00:05:42,760
So here with a simple math trick,
76

77
00:05:42,760 --> 00:05:45,430
We managed to make the code much, much faster.
77

78
00:05:46,450 --> 00:05:47,830
Let's move to another case.
78

79
00:05:48,130 --> 00:05:53,830
I'm telling you that we would like to find all triples with the following conditions of N, M, and W.
79

80
00:05:54,310 --> 00:06:04,240
So an A is between 1 and M, B is between A and M, notice here, C between 1 and W, and we would
80

81
00:06:04,240 --> 00:06:12,460
like to find all triples such that it is A + B <= C, again writing that is
81

82
00:06:12,460 --> 00:06:19,600
just need triple loops, so one loop iterating from 1 to N, the second loop iterating from i to M.
82

83
00:06:19,870 --> 00:06:25,120
The third loop is iterating from 1 to W, and then we are making our condition,
83

84
00:06:25,120 --> 00:06:31,750
If i + j is <= K then this is a valid condition. in a very similar way,
84

85
00:06:31,960 --> 00:06:38,080
If you understood this code, you can remove the nested loop here, the third loop here to make it a
85

86
00:06:38,080 --> 00:06:38,650
bit faster
86

87
00:06:38,650 --> 00:06:38,890
code.
87

88
00:06:39,340 --> 00:06:44,410
I would like you to give a good trial to think how to remove this code in a very similar way to the
88

89
00:06:44,410 --> 00:06:45,040
previous one.
89

90
00:06:46,480 --> 00:06:47,770
The trick is as following,
90

91
00:06:48,660 --> 00:06:55,740
If we would like to remove the inner loop, we just have a problem, it isn't like the
91

92
00:06:55,740 --> 00:07:02,530
last time when we say i + j == k, it's this time i + j <= K.
92

93
00:07:03,060 --> 00:07:05,370
But we are again using some very simple math.
93

94
00:07:05,520 --> 00:07:11,210
We can do this a very similar trick, we know that in i+ j == k,
94

95
00:07:11,460 --> 00:07:16,370
The condition was satisfied one time, but i + j <= k
95

96
00:07:16,650 --> 00:07:27,750
The condition would be satisfied starting
96

97
00:07:30,180 --> 00:07:40,640
The condition would be satisfied starting from 1 up to..., the K here would be valid,
97

98
00:07:40,650 --> 00:07:41,490
This is the last code,
98

99
00:07:41,730 --> 00:07:47,310
The K would be valid as long as the K itself is greater than i + j,
99

100
00:07:47,600 --> 00:07:49,650
OK. so look from the other perspective.
100

101
00:07:51,240 --> 00:07:58,710
So thinking about that, this means if the K was 4 and the W was 7, this means that all the
101

102
00:07:58,710 --> 00:08:01,830
Ks from 4 to 7 are valid for us,
102

103
00:08:02,080 --> 00:08:05,040
OK. so now this is more like a valid range.
103

104
00:08:05,280 --> 00:08:07,020
So here it goes like a valid number,
104

105
00:08:07,200 --> 00:08:11,850
here is a valid range, the range starting from K = 4 to K = 7.
105

106
00:08:12,210 --> 00:08:14,400
So how many numbers in this range?
106

107
00:08:14,730 --> 00:08:16,680
W - k + 1, please,
107

108
00:08:16,680 --> 00:08:20,540
verify it, try to think about it relative to these numbers.
108

109
00:08:20,790 --> 00:08:26,190
So the way that we are going to solve it, we're going to compute K, which is the first valid number.
109

110
00:08:26,370 --> 00:08:31,940
If this number is valid, we just are adding here W - K + 1, that's it.
110

111
00:08:32,100 --> 00:08:36,780
So this way we remove a complete loop.
111

112
00:08:38,190 --> 00:08:42,090
Fibonacci, Fibonacci is a very, very math popular sequence.
112

113
00:08:42,120 --> 00:08:49,230
The word sequence means that sum of numbers. in this sequence, every number is the sum of the last two
113

114
00:08:49,230 --> 00:08:49,650
numbers.
114

115
00:08:49,650 --> 00:08:53,700
So here is the sequence, 0, 1, 1, 2, 3, 5, 8,
115

116
00:08:53,700 --> 00:08:57,840
and so on. look at 13, for example.
116

117
00:08:58,050 --> 00:09:03,270
13 is just the summation of 5 and 8, look on 34, it is the sum of 30 and
117

118
00:09:03,270 --> 00:09:03,840
21.
118

119
00:09:04,170 --> 00:09:08,460
So every number is the sum of the previous two numbers.
119

120
00:09:08,760 --> 00:09:09,110
Write
120

121
00:09:09,180 --> 00:09:09,630
a code
121

122
00:09:09,750 --> 00:09:12,990
That can generate for us the Fibonacci sequence.
122

123
00:09:14,990 --> 00:09:22,040
Let's see, we can do it as following, we can start with a = 0 and b = 1 and then print
123

124
00:09:22,050 --> 00:09:22,400
them.
124

125
00:09:22,970 --> 00:09:30,950
Now here, what I'm doing here,  the three lines of code here are doing the logic to keep going
125

126
00:09:30,950 --> 00:09:31,450
forward.
126

127
00:09:31,880 --> 00:09:39,500
We take the c to be equal to a + b and then we move the b in a and we put the summation b in
127

128
00:09:39,500 --> 00:09:42,460
c. for twice in this course,
128

129
00:09:42,470 --> 00:09:49,010
You saw already these three lines of code doing the Fibonacci printing, but you weren't aware exactly
129

130
00:09:49,250 --> 00:09:50,840
what is happening. here,
130

131
00:09:50,990 --> 00:09:57,080
Here, we are doing an iterating to print the first n Fibonacci numbers.
131

132
00:09:57,080 --> 00:10:03,250
We printed the first two already and in these two we are generating the remaining of them, please take
132

133
00:10:03,620 --> 00:10:09,710
a paper and pen and start to simulate that to double-check that you are generating really this sequence.
133

134
00:10:09,980 --> 00:10:16,760
the moral of it is c is the answer of the last two numbers and then you are making a single
134

135
00:10:17,090 --> 00:10:17,840
shift step.
135

136
00:10:20,040 --> 00:10:22,550
Here is another way for coding it.
136

137
00:10:22,730 --> 00:10:23,960
It's a bit more ugly.
137

138
00:10:24,140 --> 00:10:29,500
But the point is I'm teaching you something about the initialization. in for-loop here,
138

139
00:10:29,510 --> 00:10:35,780
If you looked, this is the initialization part, look how big it, initializing a to 0, b to 1, C
139

140
00:10:35,780 --> 00:10:37,330
to - 1, count "cnt" = 0.
140

141
00:10:37,520 --> 00:10:41,530
So I did four initializations. In the increment step,
141

142
00:10:41,540 --> 00:10:43,730
I also did several steps,
142

143
00:10:43,730 --> 00:10:51,440
I incremented the count, I put c with a + b, a = b, b = c, OK, and remember the comma operator
143

144
00:10:51,440 --> 00:10:53,180
is just left-to-right evaluation.
144

145
00:10:53,580 --> 00:10:55,120
So here we are just iterating it.
145

146
00:10:55,490 --> 00:11:00,670
The point of this way is just I'm telling you that you can initialize a lot here and you can increment a lot
146

147
00:11:00,800 --> 00:11:01,100
here.
147

148
00:11:02,630 --> 00:11:03,380
Your turn,
148

149
00:11:03,530 --> 00:11:10,370
I would like you first to try to get all or most of the homework using the while-loop and rewrite it using the
149

150
00:11:10,370 --> 00:11:10,940
for-loops.
150

151
00:11:11,090 --> 00:11:13,030
This would make it more comfortable for you.
151

152
00:11:13,580 --> 00:11:14,080
That's it.
