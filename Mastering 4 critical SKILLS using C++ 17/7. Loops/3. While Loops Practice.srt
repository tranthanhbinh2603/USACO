0
1
00:00:01,020 --> 00:00:08,670
It's a practice on the while-loops. the first program is reading an integer X, find all numbers
1

2
00:00:08,670 --> 00:00:14,490
divisible by 3 from 1 to X. Remember, the divisibility is more about the multiples.
2

3
00:00:14,640 --> 00:00:19,530
So the multiples of 3, are 3, 6, 9, 12, and so on.
3

4
00:00:20,250 --> 00:00:27,390
So here to do this program, we need looping from 1 to X. This is our looping and we need the logic
4

5
00:00:27,390 --> 00:00:31,990
to make sure that something is divisible by 3, which is just 
mod "%" 3 == 0.
5

6
00:00:32,490 --> 00:00:35,250
So to loop, we just have here the start = 1,
6

7
00:00:35,580 --> 00:00:40,420
We have (start <= end), which is the input number, and we have the (start += 1).
7

8
00:00:40,710 --> 00:00:45,030
So this is what guarantees that we have a loop from 1 to end.
8

9
00:00:45,420 --> 00:00:53,420
And our logic is, if the current number is (%3) == 0, then we just print the number,
9

10
00:00:53,460 --> 00:01:01,410
OK. by the way, thinking about the operator precedence, then the mode operator has higher
10

11
00:01:01,410 --> 00:01:03,310
precedence than the == operator.
11

12
00:01:03,330 --> 00:01:07,290
That's why this one is applied first, then compared with the 0.
12

13
00:01:09,230 --> 00:01:14,420
In the second program, we need to do something popular in programming named as the power function, what
13

14
00:01:14,420 --> 00:01:20,750
is power ? if you have something like 2 to the power of 5 "2âµ", it means to multiply the 2 by itself
14

15
00:01:20,750 --> 00:01:21,560
5 times.
15

16
00:01:22,100 --> 00:01:26,410
You are to read 2 integers, X and Y and to compute the X to the power of Y.
16

17
00:01:26,660 --> 00:01:28,840
This is how we write this notation, the power.
17

18
00:01:29,210 --> 00:01:33,580
But anyway it just means multiply X by itself Y times.
18

19
00:01:33,980 --> 00:01:39,470
So thinking about the looping, we again need something to iterate Y number of times.
19

20
00:01:39,470 --> 00:01:45,020
So we read here num and power, "pow" here is like the Y and we need to iterate
20

21
00:01:45,230 --> 00:01:53,240
(pow) number of times; so we say "while (pow >= 1)", we do "pow--".
21

22
00:01:53,450 --> 00:01:57,390
This is interesting, now I'm actually doing it from top to bottom.
22

23
00:01:57,770 --> 00:01:59,840
So for example if Y is 5,
23

24
00:02:00,140 --> 00:02:07,010
I'm doing 5, 4, 3, 2, 1 and stopping, notice also I'm stopping here at the 1.
24

25
00:02:07,010 --> 00:02:12,340
So it's more of iterating from 5 to 1 not to 0. for our code logic,
25

26
00:02:12,350 --> 00:02:14,270
We need to keep multiplying ourself.
26

27
00:02:14,570 --> 00:02:16,340
So we have some result here.
27

28
00:02:16,340 --> 00:02:23,030
And every time we are multiplying the results by our self, the result by ourself, let's make a minor tracing, if we enter
28

29
00:02:23,030 --> 00:02:24,940
2 and 5, 2 and 5.
29

30
00:02:25,280 --> 00:02:27,020
So as we said, 5?
30

31
00:02:27,380 --> 00:02:28,820
Yes, greater than one.
31

32
00:02:29,240 --> 00:02:30,320
4? yes.
32

33
00:02:30,320 --> 00:02:31,730
3, 2, 1.
33

34
00:02:32,030 --> 00:02:38,330
And the result had been multiplied by 5, 4, 3, 2, sorry, is multiplied by (num)
34

35
00:02:38,330 --> 00:02:38,810
5 times.
35

36
00:02:40,520 --> 00:02:46,250
In the next program, we would like to read an integer and count the number of digits of it.
36

37
00:02:46,970 --> 00:02:51,580
For example, if we entered 123, this consists of 3 digits.
37

38
00:02:51,800 --> 00:02:53,360
Think for a while how to do that.
38

39
00:02:53,960 --> 00:02:56,180
We will show several tricks in this
39

40
00:02:56,180 --> 00:03:01,640
code. the way to count the number of digits of
40

41
00:03:01,680 --> 00:03:07,310
a number is as simple as keep removing a digit and verify if the number is 0 or not,
41

42
00:03:07,900 --> 00:03:13,380
OK. so for example, if we have 123, remove the 3, incremental your counters, we now
42

43
00:03:13,400 --> 00:03:14,210
have 1 digit.
43

44
00:03:14,510 --> 00:03:15,410
Remove the 2,
44

45
00:03:15,620 --> 00:03:16,790
Now we have 2 digits.
45

46
00:03:16,790 --> 00:03:17,620
Remove the 1,
46

47
00:03:17,810 --> 00:03:19,020
Now we have 3 digits.
47

48
00:03:19,310 --> 00:03:24,230
So here the logic is as following, we read the number, which is 123.
48

49
00:03:24,350 --> 00:03:31,700
We say "while (num > 0)", as long as this number isn't 0, we say here, num = 
49

50
00:03:31,810 --> 00:03:32,880
num / 10,
50

51
00:03:32,900 --> 00:03:34,720
So we are removing the last digit.
51

52
00:03:35,270 --> 00:03:40,750
And with every step, our logic is incrementing the digits with one step.
52

53
00:03:41,030 --> 00:03:47,480
I would like you to trace this code to make sure that you are comfortable with it, after you are done
53

54
00:03:47,480 --> 00:03:47,980
with that,
54

55
00:03:48,260 --> 00:03:51,050
There are at least two bugs in this code.
55

56
00:03:51,350 --> 00:03:57,460
I would like you to think about two different test cases that make this code not complete.
56

57
00:03:57,470 --> 00:03:59,600
We need to find more improvements in it.
57

58
00:04:00,750 --> 00:04:07,920
Let's proceed, the first bug here in this code, it doesn't handle the input 0, for example,
58

59
00:04:08,160 --> 00:04:13,080
if the input was 0, the program will say "while(num > 0),
59

60
00:04:13,080 --> 00:04:16,090
It will never get inside the loop and say the digits were zero.
60

61
00:04:16,530 --> 00:04:21,630
So actually, this wasn't the case, and we also couldn't just put equal in the loop.
61

62
00:04:21,630 --> 00:04:23,480
Otherwise, it keeps going for infinity.
62

63
00:04:23,850 --> 00:04:28,620
So the best way to do that is to make a special handling for the 0.
63

64
00:04:28,920 --> 00:04:32,840
So we say here, "if(num == 0), then we have 1 digit,
64

65
00:04:33,030 --> 00:04:37,620
Otherwise, we do the previous code of counting the digits one by one.
65

66
00:04:38,070 --> 00:04:41,130
So now what is the other bug in this code?
66

67
00:04:43,690 --> 00:04:46,460
This code will fail if the number is negative.
67

68
00:04:46,810 --> 00:04:52,570
OK, because it says here, "while(num > 0)", what if the number is less than
68

69
00:04:52,570 --> 00:04:53,080
or equal?
69

70
00:04:53,170 --> 00:04:54,900
What if the number is a negative number?
70

71
00:04:55,300 --> 00:04:56,760
This loop, again, will not work.
71

72
00:04:57,070 --> 00:05:02,010
So while we have here a special handling for the 0, we need also special handling if the number is
72

73
00:05:02,020 --> 00:05:02,400
negative.
73

74
00:05:02,860 --> 00:05:06,060
An easy way for that is just multiply the number with some negative value.
74

75
00:05:06,400 --> 00:05:12,250
For example, let's say the input is -123, then multiply it by -1, is now
75

76
00:05:12,250 --> 00:05:15,540
123 and then you do your normal processing.
76

77
00:05:15,820 --> 00:05:16,990
So far, so good.
77

78
00:05:17,320 --> 00:05:20,230
There is still one very, very tricky trick here.
78

79
00:05:20,560 --> 00:05:23,920
And I would like you to think about it.
79

80
00:05:25,090 --> 00:05:27,700
Here is a hint, think about the overflow.
80

81
00:05:28,650 --> 00:05:29,220
Give a trail.
81

82
00:05:30,490 --> 00:05:31,600
OK, let's proceed more.
82

83
00:05:32,310 --> 00:05:35,010
What is the minimum value in C++?
83

84
00:05:35,340 --> 00:05:37,090
It is minus this number.
84

85
00:05:37,770 --> 00:05:39,150
What is the maximum value?
85

86
00:05:39,150 --> 00:05:43,240
it is very similar to this number, but with -1 here.
86

87
00:05:43,830 --> 00:05:50,100
Now, what happens if you multiply this number with -1? it is going to be the same value as
87

88
00:05:50,100 --> 00:05:53,580
positive value, but this is greater than the C++ limit,
88

89
00:05:53,850 --> 00:05:55,730
So this causes the program to overflow.
89

90
00:05:56,070 --> 00:05:58,610
We need a special handling for this test case.
90

91
00:05:58,980 --> 00:06:02,310
So we say here, if num is 0, it's just single digit.
91

92
00:06:02,670 --> 00:06:06,180
If num is this negative value, we know it is ten digits.
92

93
00:06:06,540 --> 00:06:08,980
Otherwise we do the same logic.
93

94
00:06:09,540 --> 00:06:17,220
So if I wanted to share a message with you from this simple program, it is as following; It's actually
94

95
00:06:17,640 --> 00:06:20,830
very tricky to write a very complete code.
95

96
00:06:21,090 --> 00:06:24,480
It takes really time. during the course,
96

97
00:06:24,480 --> 00:06:30,630
I will not necessarily be doing the same way with every single logic because in many cases I'm just
97

98
00:06:30,630 --> 00:06:32,580
trying to reveal a specific message.
98

99
00:06:32,820 --> 00:06:37,470
But I just wanted to share with you what it takes to make really a very strong program.
99

100
00:06:43,170 --> 00:06:49,710
Yeah, there was a request here that we would like to print something like, cout<<"number of
100

101
00:06:49,740 --> 00:06:51,570
digits of " << num << " is " << digits;
101

102
00:06:51,690 --> 00:06:58,830
For example, you cout number of digits of 123 is 3 digits.
102

103
00:06:59,100 --> 00:07:01,320
But this message will not be correct.
103

104
00:07:01,500 --> 00:07:04,260
I would like you to read it and think why it would not be correct.
104

105
00:07:05,190 --> 00:07:09,470
The reason is that the (num) is already we kept dividing by it.
105

106
00:07:09,480 --> 00:07:11,830
So eventually here num is 0.
106

107
00:07:12,180 --> 00:07:16,860
So it would be num = 0, it would be 0 is 3 digits, for example.
107

108
00:07:17,730 --> 00:07:23,160
The right way is you take a copy of num because you are actually going to play with your num variable
108

109
00:07:23,190 --> 00:07:23,730
now.
109

110
00:07:26,260 --> 00:07:27,430
Nested loops.
110

111
00:07:30,010 --> 00:07:41,830
Let's say that we would like to make a program that reads T integers for T test cases, then read T numbers
111

112
00:07:42,010 --> 00:07:44,380
for each number, print them from 1 to N.
112

113
00:07:44,710 --> 00:07:52,930
Remember, we before had (if-conditions) and we also say that we can had nested if-conditions in a nested-if
113

114
00:07:53,320 --> 00:07:55,300
conditions. in a very similar way,
114

115
00:07:55,540 --> 00:08:01,750
Nothing prevent you from having while-loop inside it another loop, inside it another loop and so on.
115

116
00:08:02,110 --> 00:08:07,990
In this program we would like to read test cases and for each  test case you'd like to print something.
116

117
00:08:07,990 --> 00:08:11,420
For example, let's say the user entered 3.
117

118
00:08:11,590 --> 00:08:16,150
It means the user is going to test us on three different test cases,
118

119
00:08:16,460 --> 00:08:21,700
OK. and for every test case,  we would like to print the sum from 1 to N. for example, if the
119

120
00:08:21,700 --> 00:08:25,000
user entered 3, then the sum from 1 to 3 is 6.
120

121
00:08:25,300 --> 00:08:28,630
4, the sum is from 1 to 4 is 10.
121

122
00:08:28,630 --> 00:08:30,670
5, The sum from 1 to 5 is 15.
122

123
00:08:31,180 --> 00:08:35,680
So now, it seems I need two things that help us to iterate.
123

124
00:08:36,040 --> 00:08:42,720
The first one is the while-loop on the test cases, and the second one is while-loop to sum from 1 to N,
124

125
00:08:42,910 --> 00:08:50,320
OK. so now here we are reading T for test cases and I'm saying here "while t > 0",
125

126
00:08:50,830 --> 00:08:52,750
Here you see  --T.
126

127
00:08:53,200 --> 00:08:58,900
So for the first while-loop we are reading its value, we have a condition that we are still not zero
127

128
00:08:59,140 --> 00:09:00,490
and we are decreasing it,
128

129
00:09:00,490 --> 00:09:04,240
So test cases are actually going less. inside the loop
129

130
00:09:04,360 --> 00:09:09,880
we start to read the number and then we prepare another while-loop with the start from 1,
130

131
00:09:10,360 --> 00:09:16,210
As long as the start is less than num, and we do start to ++, and we have here our own logic.
131

132
00:09:16,420 --> 00:09:21,070
sum += start, and sum is something that's defined locally here.
132

133
00:09:21,370 --> 00:09:28,150
Then we just keep summing it and we print it. this is what we call nested loop or nested while-loop.
133

134
00:09:28,480 --> 00:09:34,570
We did one loop to iterate on test cases and another loop to iterate from 1 to N.
134

135
00:09:34,870 --> 00:09:36,640
Please make sure that you understand this one.
135

136
00:09:37,990 --> 00:09:38,560
That's it.
