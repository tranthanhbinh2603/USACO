0
1
00:00:01,440 --> 00:00:06,750
In this video, we will discuss the relational operators. Relational is all about comparisons.
1

2
00:00:07,110 --> 00:00:13,920
I would like you to stop the video for a minute and then read all of these normal text expressions
2

3
00:00:14,100 --> 00:00:20,050
and then think about their answers and then visualize with your eyes what is on the right side.
3

4
00:00:21,510 --> 00:00:30,930
OK, so is 3 greater than 5? false, how to express that in math we say 3 greater than 5.
4

5
00:00:30,930 --> 00:00:34,020
Is 3 < 5? true.
5

6
00:00:34,180 --> 00:00:41,160
We present it with that, now when come to equal, is 3 = 5? in math we use a single equal
6

7
00:00:41,160 --> 00:00:43,400
but this in C++ is the assignment operator.
7

8
00:00:43,650 --> 00:00:50,280
So we use here an == to express an equality, is 3 greater than or equal ">=" 5
8

9
00:00:50,370 --> 00:00:52,050
false, how to write it
9

10
00:00:52,050 --> 00:00:56,300
we write greater than ">", equal "=" and so on, notice
10

11
00:00:56,340 --> 00:00:57,390
there is no spaces here.
11

12
00:00:57,810 --> 00:01:03,680
If we would like to represent to the..., this is another one for greater than equal ">=".
12

13
00:01:03,690 --> 00:01:04,500
This is for equal
13

14
00:01:04,500 --> 00:01:05,820
equal "==" which is true.
14

15
00:01:05,820 --> 00:01:08,400
Is 3 == 3 true , this is for greater (than) ">"
15

16
00:01:08,400 --> 00:01:10,730
This is for not equal "!=".
16

17
00:01:11,070 --> 00:01:16,230
So in a similar way we can make the less than or equal  like "<=".
17

18
00:01:18,880 --> 00:01:26,080
Now, moving to the C++, this is just how we do, it so we can say 3 > 5, 3 < 5, and 3 == 5
18

19
00:01:26,380 --> 00:01:30,840
>=, >=, ==, >, !=, !=.
19

20
00:01:31,090 --> 00:01:37,670
3 != 4, you notice we use here parentheses usually we use them to avoid compiler errors.
20

21
00:01:38,020 --> 00:01:42,130
So this is what we mean by a relational operator.
21

22
00:01:42,310 --> 00:01:46,260
Relational is about the relation between two things, it help us to compare.
22

23
00:01:46,690 --> 00:01:51,820
And as we are comparing it ends up with Boolean, it ends up with true or false.
23

24
00:01:51,850 --> 00:01:56,950
So just what we call in C++ a condition. in a similar way,
24

25
00:01:56,980 --> 00:02:04,960
we can only just work on constants, we can work on variables so we can say X > Y and
25

26
00:02:04,960 --> 00:02:06,910
we have 2 X and Y values that
26

27
00:02:06,910 --> 00:02:10,690
for example, we read them or so. X == Y and so on.
27

28
00:02:11,900 --> 00:02:18,230
In a similar way, we can put the result in some boolean because we know they are eventually end
28

29
00:02:18,230 --> 00:02:19,280
up with a true or false.
29

30
00:02:19,430 --> 00:02:24,980
So one can say "bool result = x > y", then we just print it and so on.
30

31
00:02:25,310 --> 00:02:29,660
Also, it's boolean so we can put the not operator "!", not result "!result" or not
31

32
00:02:30,800 --> 00:02:32,180
x < y, (x<y)
32

33
00:02:32,210 --> 00:02:38,200
is evaluated first as a parenthesis, then the "!" is applied second and so on.
33

34
00:02:38,240 --> 00:02:41,470
Please make sure that all of the outputs here make sense for you.
34

35
00:02:43,010 --> 00:02:47,660
In a similar way, we can not  just compare numbers,
35

36
00:02:47,690 --> 00:02:49,090
we can also compare strings.
36

37
00:02:49,370 --> 00:02:56,180
So if I have a string ' name1 = "Ali" ', string ' name2 = ali mostafa'  , string ' name3 = "Ziad" ' , Ali, Ali and so on.
37

38
00:02:56,540 --> 00:03:01,840
We can start to say name1 less than "<" name2, name1  greater than ">" name2, and so on.
38

39
00:03:02,270 --> 00:03:05,120
But the question now, how are they compared?
39

40
00:03:05,960 --> 00:03:07,310
We assume two things,
40

41
00:03:07,730 --> 00:03:11,980
First, that we have a dictionary that is sorted based on name.
41

42
00:03:11,990 --> 00:03:18,270
So as we know in the dictionary, something like "car" would be, for example, before something like
42

43
00:03:18,270 --> 00:03:23,710
"laptop", OK, because 'C' is coming before 'L' in laptop and so on.
43

44
00:03:24,020 --> 00:03:31,740
The second thing is we assume, we said before that C++ is case sensitive, we assume the small letter 'a' and
44

45
00:03:31,740 --> 00:03:36,230
the small letters in general, the uppercase letters comes before the small letters.
45

46
00:03:36,230 --> 00:03:37,980
So the small letter "a" here.
46

47
00:03:38,270 --> 00:03:43,930
So for example, here, let's say that we have a name1, "ali", and name5, "ALI".
47

48
00:03:44,150 --> 00:03:48,650
If we say name1 "ali" == name5 "ALI" -capital-,  it would be false.
48

49
00:03:48,980 --> 00:03:59,270
If we say name1 > name5, the answer would be true, why? because the small letter 'a'
49

50
00:03:59,270 --> 00:04:02,540
is greater than the upercase letter 'A'.
50

51
00:04:02,960 --> 00:04:06,860
OK, so this is mainly how to compare strings. finally,
51

52
00:04:06,860 --> 00:04:08,950
And more tricky is a double comparison.
52

53
00:04:10,580 --> 00:04:12,440
The double comparison is very tricky.
53

54
00:04:12,560 --> 00:04:16,160
Double in C++ is represented in an approximate way.
54

55
00:04:16,160 --> 00:04:20,060
If you would like to go in a bit advanced, there are couple of very interesting articles here.
55

56
00:04:21,590 --> 00:04:29,210
Now, let's say that we have something like "a = 3.0" divided by 7.0 and another expression
56

57
00:04:29,210 --> 00:04:32,810
b = 1 + 3.0 / 7.0 - 1
57

58
00:04:33,320 --> 00:04:35,870
Mathematically, these two terms are very equal.
58

59
00:04:35,870 --> 00:04:43,670
If we printed A and B, it would be this expression. if we here wrote A == B, surprisingly, sometimes
59

60
00:04:43,670 --> 00:04:44,390
it would be zero
60

61
00:04:44,480 --> 00:04:46,640
not one, this is very weird.
61

62
00:04:46,640 --> 00:04:47,750
They look the same number.
62

63
00:04:47,880 --> 00:04:53,570
They are the same math, but not necessarily equal because they are internally approximate numbers. in
63

64
00:04:53,570 --> 00:04:54,280
a similar way,
64

65
00:04:54,530 --> 00:04:58,750
Let's say you said "a = 5" and "b = 4.9999999999999999".
65

66
00:04:59,150 --> 00:05:05,240
If you try to print them, they will be printed like 5 and 5 because C++ will approximate that
66

67
00:05:05,240 --> 00:05:05,750
to 5.
67

68
00:05:06,380 --> 00:05:12,350
And still, if you compare them, it might not be 1 because it's still internally, it might not be
68

69
00:05:12,350 --> 00:05:13,450
represented as 5.
69

70
00:05:13,850 --> 00:05:21,290
So the moral of that is we do not compare directly doubles specifically the ==, especially
70

71
00:05:21,290 --> 00:05:24,530
the == operator, the "<" and ">" are OK.
71

72
00:05:24,770 --> 00:05:27,650
But the ==, <=, >=.
72

73
00:05:27,650 --> 00:05:30,020
We don't compare them directly.
73

74
00:05:30,590 --> 00:05:32,300
In the future we will learn how to do that.
74

75
00:05:32,480 --> 00:05:36,890
You might think about, how in future this would work.
75

76
00:05:37,130 --> 00:05:41,180
But for now, just be careful from comparing doubles directly.
76

77
00:05:41,870 --> 00:05:42,380
That's it.
