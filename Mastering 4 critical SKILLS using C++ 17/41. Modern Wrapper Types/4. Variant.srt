1
00:00:01,260 --> 00:00:09,690
Another interesting reverend, C++, 17, is a very introvert, let's introduce the case, let's say

2
00:00:09,720 --> 00:00:13,970
I defined I make beer of Mustafa Antin and defining year string event.

3
00:00:14,310 --> 00:00:18,630
This is normally that we have two variables here, two data types.

4
00:00:18,810 --> 00:00:22,550
We have the type of type integer and another type of diversity.

5
00:00:22,560 --> 00:00:23,640
We have two of them.

6
00:00:24,060 --> 00:00:26,850
You can make table with two and three of them and so on.

7
00:00:28,170 --> 00:00:29,210
There's a question here.

8
00:00:29,640 --> 00:00:32,860
What if you would like only one of them to be available at some point?

9
00:00:33,210 --> 00:00:39,870
What if you have a function that can return a double or return an integer or alternatively or even returning

10
00:00:39,870 --> 00:00:40,260
nothing.

11
00:00:40,680 --> 00:00:43,190
But but but the function isn't going to return.

12
00:00:43,200 --> 00:00:46,020
All of them just have different different cases.

13
00:00:46,770 --> 00:00:47,810
Now, this is weird.

14
00:00:48,150 --> 00:00:53,140
Now we have different data types and we we just need one of them only.

15
00:00:53,340 --> 00:01:00,720
So one way for us as a engineers, as a workaround is just to try to maybe have like a function that

16
00:01:00,720 --> 00:01:03,330
returns a table or pair of your things.

17
00:01:03,330 --> 00:01:05,970
And then some flags are to say if it exists or not.

18
00:01:06,240 --> 00:01:07,640
Again, this is a waste of time.

19
00:01:07,920 --> 00:01:14,340
The C++ 17 provide us with what we call Verin actually C plus C++ before that has something that's good

20
00:01:14,340 --> 00:01:18,320
union and it was used but was unsafe one.

21
00:01:18,600 --> 00:01:22,090
So then you C++ 17 is what we call a variant.

22
00:01:22,560 --> 00:01:24,750
So it is how we define a variant.

23
00:01:25,200 --> 00:01:34,010
You say variant of a string integer var unless initialized with then this means that var can hold either

24
00:01:34,020 --> 00:01:38,570
string or an integer and at this time of completion it has a value of 10.

25
00:01:38,580 --> 00:01:39,510
So it's an integer.

26
00:01:39,930 --> 00:01:41,940
So now this isn't like a beer.

27
00:01:41,940 --> 00:01:43,230
You don't have both of them.

28
00:01:43,260 --> 00:01:45,660
They will be, you will have only one of them.

29
00:01:46,260 --> 00:01:47,910
Now let's forget the value of the bar.

30
00:01:48,420 --> 00:01:51,120
You can do that in two ways.

31
00:01:51,330 --> 00:01:53,580
You can do it by index or by the time.

32
00:01:53,880 --> 00:01:55,420
So what is the index of that guy?

33
00:01:55,500 --> 00:01:56,850
It is here in position one.

34
00:01:57,000 --> 00:02:01,920
So you can say get one of our look to the syntax to get one over.

35
00:02:02,340 --> 00:02:08,850
Another way is by the time we say get integer over and normally if you are, you are going to make an

36
00:02:08,850 --> 00:02:09,720
integer, an integer.

37
00:02:09,720 --> 00:02:12,160
Does it make sense because only one of them here is available.

38
00:02:13,110 --> 00:02:14,280
So this is how you get it.

39
00:02:14,310 --> 00:02:19,390
Another interesting function is an index function, which tells you which index is active at the moment.

40
00:02:19,410 --> 00:02:22,860
So for the string, it will be zero for the integral to be one.

41
00:02:23,550 --> 00:02:29,910
Now, what's going to happen if you try to wrongly get the variable, you will get a new exception named

42
00:02:29,910 --> 00:02:31,290
the bad variant Texas.

43
00:02:31,450 --> 00:02:36,110
So if you try to say get string over, but only integer is available now.

44
00:02:36,120 --> 00:02:42,500
So this will give you exception if you get zero of also another exception, because zero isn't active

45
00:02:42,510 --> 00:02:42,750
one.

46
00:02:43,700 --> 00:02:49,180
There are two conversion errors if you try to use a data type that doesn't exist right now, the compiler

47
00:02:49,190 --> 00:02:54,410
will notice that if you try to use an index that doesn't exist, the compiler will notice that this

48
00:02:54,410 --> 00:02:55,460
is because this is standard.

49
00:02:55,490 --> 00:02:58,220
And all of that is is spelled in the comparison type.

50
00:02:59,830 --> 00:03:05,470
Another interesting function, you can use a pointer, you call the get a function with data type,

51
00:03:05,710 --> 00:03:12,430
and you are going to guess it refers to the variable and it's going to return a pointer for you if the

52
00:03:12,520 --> 00:03:13,670
variable exists.

53
00:03:13,690 --> 00:03:19,510
It would be to have a value if this variable doesn't exist, like you're using the wrong data type is

54
00:03:19,510 --> 00:03:21,250
going to give you another pointer.

55
00:03:21,430 --> 00:03:27,040
So now you can also use the get to like use it in a different way so you can return the value in different

56
00:03:27,040 --> 00:03:29,370
ways to assign it.

57
00:03:29,380 --> 00:03:31,390
You can just go and assign it with a variable.

58
00:03:31,420 --> 00:03:32,930
So this is creating temporary variable.

59
00:03:32,950 --> 00:03:39,250
And just using it another way is you can use it by reference here for more efficient like say get into,

60
00:03:39,400 --> 00:03:42,970
over, get into it is returning by Bio-Reference.

61
00:03:43,210 --> 00:03:48,160
You can assign it a different variable, a different value, and the index would be changing.

62
00:03:48,400 --> 00:03:55,210
So now the VA has a new value here in terms of constructor and structure.

63
00:03:55,210 --> 00:04:00,730
When you assign a new value than the old one, if has a structure, it would be destroyed probably first.

64
00:04:01,930 --> 00:04:03,690
Now let's see an application for that.

65
00:04:04,660 --> 00:04:11,140
If you remember the roots of the quadratic equation, A squared plus B, C equals zero.

66
00:04:11,410 --> 00:04:14,830
This function in math has three different solution.

67
00:04:15,070 --> 00:04:16,660
One solution that has no roots.

68
00:04:16,910 --> 00:04:18,690
Another solution that has one rule.

69
00:04:18,880 --> 00:04:20,620
Another solution that has two roots.

70
00:04:20,860 --> 00:04:24,740
If you do remember this math tutorial we just using as an example.

71
00:04:25,120 --> 00:04:29,460
So now the model of that is this equation has three different statuses.

72
00:04:29,920 --> 00:04:32,510
Nothing, one, return to return.

73
00:04:32,860 --> 00:04:38,900
So as you see here, we have three different cases and only one of them will be available at a time.

74
00:04:39,250 --> 00:04:42,160
So if we would like to represent that guy, we just can use double.

75
00:04:42,550 --> 00:04:43,900
Who would like to represent this guy?

76
00:04:43,900 --> 00:04:45,670
Who can represent a pair of double double.

77
00:04:45,970 --> 00:04:47,580
What about the case?

78
00:04:48,070 --> 00:04:50,890
We have something in the variable that's good.

79
00:04:50,890 --> 00:04:53,650
Monistat So what's more, state molested me.

80
00:04:53,650 --> 00:04:55,140
Just MBT alternative.

81
00:04:55,510 --> 00:04:57,910
Let's say we have here a class embley.

82
00:04:58,150 --> 00:05:00,610
And I would like to say it may exist or not.

83
00:05:00,610 --> 00:05:06,310
You can say a variant of Monastir trembly and by now directly we can use the optional here as a better

84
00:05:06,310 --> 00:05:06,580
way.

85
00:05:06,730 --> 00:05:12,450
But the model of Monistat, it can be used with variant to provide you with an embittered alternative.

86
00:05:13,120 --> 00:05:17,140
And there is an advice here I would advise you to always put it in the beginning.

87
00:05:17,140 --> 00:05:17,620
Why?

88
00:05:17,980 --> 00:05:22,760
Because the variant always by default initialized the first member.

89
00:05:23,140 --> 00:05:29,740
So if you say the variant of Embley is going to initialize the variant to the barrier to Embley, but

90
00:05:29,740 --> 00:05:34,630
looking to this guy, it doesn't have a default constructor, this line will convert.

91
00:05:35,380 --> 00:05:40,030
So the advantage of model state, when you put it first, the word would be initialized to MBT.

92
00:05:40,210 --> 00:05:46,150
And then if Embley doesn't have a default constructor, everything would be OK.

93
00:05:46,900 --> 00:05:48,550
Now, let's go back to our function.

94
00:05:49,000 --> 00:05:50,410
I need a variant.

95
00:05:50,410 --> 00:05:59,830
The take three things Monistat state, a double, a double, and let's use the using from C++ and just

96
00:06:00,040 --> 00:06:00,890
give it a name here.

97
00:06:01,180 --> 00:06:03,490
So my function is going to return to this variant.

98
00:06:03,880 --> 00:06:07,600
And now we have three cases who are doing some math that we don't care about it here.

99
00:06:07,870 --> 00:06:09,820
In this case, we can return it to Bill.

100
00:06:09,970 --> 00:06:11,560
So we are going to return to the beer.

101
00:06:11,770 --> 00:06:13,810
In this case, we can return a single number.

102
00:06:13,900 --> 00:06:16,520
So we are returning a single number otherwise empty.

103
00:06:16,870 --> 00:06:23,080
So you see now how our function is returning three different things and the caller can start to use

104
00:06:23,080 --> 00:06:23,320
it.

105
00:06:23,650 --> 00:06:25,210
For example, calling the computer.

106
00:06:25,220 --> 00:06:30,300
It's a function of three values which would be solved to two items and then we are going to print it.

107
00:06:30,790 --> 00:06:32,300
Now let's see the print function.

108
00:06:32,740 --> 00:06:38,140
Now, the problem is we don't know which one is is the return side so we can use that index function.

109
00:06:38,410 --> 00:06:41,860
If the index is zero, then it is a real case.

110
00:06:41,860 --> 00:06:43,990
If the index is one, it is a one rule case.

111
00:06:44,230 --> 00:06:46,670
If the index is two is a too good case.

112
00:06:47,230 --> 00:06:52,150
Now, this is an ugly the the new standard or the standard.

113
00:06:52,600 --> 00:06:59,530
The best practice is pushing to do something good is to visit the division visit is following what we

114
00:06:59,530 --> 00:07:01,000
call a vista design better.

115
00:07:01,000 --> 00:07:02,350
You should study that in the design.

116
00:07:02,350 --> 00:07:03,880
Better for now.

117
00:07:04,270 --> 00:07:15,370
I would like you to define some struct and override and over overwrite three different overload, three

118
00:07:15,370 --> 00:07:19,660
different function corroborators, one for every argument.

119
00:07:19,990 --> 00:07:21,460
So here I'm defining it.

120
00:07:21,490 --> 00:07:29,110
One for the single parameter, one for the double for the beer, around for the honesty, and then do

121
00:07:29,110 --> 00:07:30,130
whatever you would like.

122
00:07:30,610 --> 00:07:33,730
No here one would like to print you create you call.

123
00:07:33,730 --> 00:07:39,430
The function is to visit and you give it the visitor that you would like to give here and you would

124
00:07:39,430 --> 00:07:40,440
like to give the result.

125
00:07:40,810 --> 00:07:42,930
So the model of that is behind the scene.

126
00:07:43,120 --> 00:07:44,740
This also will be happened.

127
00:07:44,740 --> 00:07:49,870
And just calling your function so for you, instead of you doing the FSA by yourself, someone else

128
00:07:49,870 --> 00:07:50,650
will do it for you.

129
00:07:50,920 --> 00:07:52,950
You just provide the different functions here.

130
00:07:53,830 --> 00:07:58,670
What I would like to do some function that maybe something, something or so do another vista.

131
00:07:59,030 --> 00:08:08,330
So for every operation defying your own Vestor before Bidis, yeah, you can also provide along the

132
00:08:08,330 --> 00:08:14,290
way, the way like let's say here, let's say I have a variant of integer, double and string.

133
00:08:14,330 --> 00:08:22,460
OK, let's make our code more generic so I can define the final number that is taking auto with reference

134
00:08:22,460 --> 00:08:22,820
reference.

135
00:08:23,180 --> 00:08:23,740
This is a very.

136
00:08:24,200 --> 00:08:28,230
It was a reference for forwarding and just printing it.

137
00:08:28,880 --> 00:08:31,610
Now I can say visit of the visitor Anvar.

138
00:08:31,880 --> 00:08:38,290
So the moral of that is you didn't have to write a case for integer and another case for double and

139
00:08:38,300 --> 00:08:39,350
after the case for string.

140
00:08:39,470 --> 00:08:46,810
So you can make it more than the problem is what if I have really different types were such a generic

141
00:08:46,810 --> 00:08:47,960
good cannot work.

142
00:08:48,170 --> 00:08:53,120
It really can get very complicated to do again in a way or another.

143
00:08:53,120 --> 00:08:54,650
Some offenses or very generic.

144
00:08:54,650 --> 00:08:54,950
Good.

145
00:08:56,150 --> 00:08:58,130
But for now I would like to keep it simple for that.

146
00:09:00,720 --> 00:09:07,000
The endless function similar to the optional, the simplest can help you to make your code more efficient.

147
00:09:07,200 --> 00:09:12,400
Let's say you have a variant of integral double and you initialize it with ten point five.

148
00:09:12,690 --> 00:09:13,930
By the way, this is OK.

149
00:09:14,370 --> 00:09:20,610
Now, what if you have your variant of integrating offloads and you give it ten point five?

150
00:09:21,090 --> 00:09:25,390
The problem is ten point five can be converted to fluid or an integer.

151
00:09:25,500 --> 00:09:27,280
We have three different types in this line.

152
00:09:27,540 --> 00:09:28,460
This will combine error.

153
00:09:28,470 --> 00:09:32,560
Actually, you cannot do that in this way to solve that.

154
00:09:32,820 --> 00:09:39,780
One way is to use the endless function so you can say here you best the emplace index of zero to mean

155
00:09:39,780 --> 00:09:41,820
that this guy will be converted to into you.

156
00:09:42,240 --> 00:09:45,750
Or you can best in this type of integer to sit here.

157
00:09:49,620 --> 00:09:53,850
So, yeah, let's let's try another thing here.

158
00:09:54,190 --> 00:10:01,080
Let's let's define a vector of integer and string as variant so you can see here the in place of index

159
00:10:01,080 --> 00:10:08,040
to zero and give it the list of arguments now that one advantage for the employees, it's very memory

160
00:10:08,040 --> 00:10:08,620
efficient.

161
00:10:08,850 --> 00:10:12,900
So this guy would be constructed directly in the vector of integer.

162
00:10:13,020 --> 00:10:16,730
So this is more efficient, more, more, more efficient.

163
00:10:16,740 --> 00:10:19,660
This initialized less would be best to the vector of it.

164
00:10:19,770 --> 00:10:19,930
You.

165
00:10:22,970 --> 00:10:30,200
If you define here, Victor, of integration double and and you give it value zero, this is OK.

166
00:10:30,200 --> 00:10:36,130
Definitely this is going to be going to a of of intriguer here.

167
00:10:37,850 --> 00:10:43,700
But what if you just defined the look and you give it zero to zero can be converted to any one of them

168
00:10:44,060 --> 00:10:46,390
according to the standard disjointed compiler?

169
00:10:46,400 --> 00:10:48,040
I don't know why it doesn't compile.

170
00:10:48,050 --> 00:10:52,480
It combines with me maybe some some differences in implementation in a way.

171
00:10:52,490 --> 00:10:56,900
Again, if you hear just the custody too long, then it's going to just work.

172
00:10:57,290 --> 00:11:03,830
And normally the moral of that is the English can help you with the index or type to solve the conversion

173
00:11:03,830 --> 00:11:04,420
error here.

174
00:11:04,580 --> 00:11:07,490
And also it is more of being more efficient, the choice here.
