0
1
00:00:01,380 --> 00:00:09,120
One of the interesting features in C++ 11 is the default keyword. Let's read this code.
1

2
00:00:09,450 --> 00:00:15,240
You have here a class employee with a single parametrized employee class that has a salary and has a string name.
2

3
00:00:15,900 --> 00:00:23,040
As we know, if we tried to create an object without parameters here like that, which
3

4
00:00:23,040 --> 00:00:26,880
is trying to call the copy constructor, the compiler would generate an error.
4

5
00:00:27,240 --> 00:00:31,050
You cannot call the default constructor if you didn't provide it,
5

6
00:00:31,260 --> 00:00:37,170
and meanwhile, there is a parameterized constructor, as we learned before.
6

7
00:00:37,500 --> 00:00:39,380
So this case is a compilation error.
7

8
00:00:39,780 --> 00:00:48,200
The main way to be able to call this code is to come here and provide some employee with an empty body. In C++11
8

9
00:00:48,300 --> 00:00:48,700
...
9

10
00:00:48,840 --> 00:00:50,480
there is a simplification for that.
10

11
00:00:50,670 --> 00:00:58,170
You can come here to line 12 and just uncommented it, it says employee equals default. When the compiler
11

12
00:00:58,170 --> 00:01:03,520
see this instruction, it is going to generate a default constructor for you.
12

13
00:01:03,810 --> 00:01:06,960
So it just something that makes your life a bit easier
13

14
00:01:06,970 --> 00:01:11,310
like - you can always if you don't have a problem with an empty constructor, you can just
14

15
00:01:11,790 --> 00:01:15,720
provide it. This generated what is called defaulted default constructor.
15

16
00:01:15,960 --> 00:01:20,910
So default constructor, it means it doesn't take parameters and it's generated by a compiler.
16

17
00:01:21,120 --> 00:01:29,460
So if you uncommented line 12, it will compile. Now,
17

18
00:01:29,670 --> 00:01:31,270
it seems like very easy,
18

19
00:01:31,290 --> 00:01:33,170
everything is done. Not exactly,
19

20
00:01:33,750 --> 00:01:39,440
there are now four cases for a default constructor that has an empty body.
20

21
00:01:40,080 --> 00:01:46,530
The first case is you declared by yourself. You define a default constructor by yourself in an explicit
21

22
00:01:46,530 --> 00:01:46,790
way.
22

23
00:01:47,610 --> 00:01:50,240
The second way is you write nothing,
23

24
00:01:50,250 --> 00:01:52,890
however, you do not have a parameterize constructor.
24

25
00:01:53,250 --> 00:01:57,870
In this case, the compiler will generate a default constructor for you,
25

26
00:01:58,680 --> 00:02:03,460
and with the third way that we just learned, we can declare and define the class with the keyword
26

27
00:02:03,460 --> 00:02:04,070
default,
27

28
00:02:04,740 --> 00:02:11,430
and this case also can be like switched also to declare in the class and have another dot_h file or
28

29
00:02:11,430 --> 00:02:14,140
some separate definition where you are using the default.
29

30
00:02:14,430 --> 00:02:20,190
So here, declare, define together in one statement like we did here, and here, declare in the class
30

31
00:02:20,340 --> 00:02:22,750
and separate the definition in another file.
31

32
00:02:22,920 --> 00:02:27,360
So in the separation, you just say constructor name equals default in that definition,
32

33
00:02:27,360 --> 00:02:29,800
colon-colon constructor's name equals default.
33

34
00:02:30,240 --> 00:02:33,600
So let's see the code of these four different cases. Here
34

35
00:02:33,810 --> 00:02:38,330
you define the class, and you define the constructor and just an empty code here.
35

36
00:02:39,690 --> 00:02:40,830
This is a default constructor.
36

37
00:02:41,250 --> 00:02:48,870
In the second case here, you didn't define the default constructor, but there is also no
37

38
00:02:49,680 --> 00:02:53,390
parametrized constructor so the compiler will generate one for you.
38

39
00:02:53,970 --> 00:02:57,540
The third case you define the constructor with the key keyword default.
39

40
00:02:58,200 --> 00:03:01,290
In the fourth case, you define the constructor,
40

41
00:03:02,310 --> 00:03:06,480
and here in the definition, you declared here and in the definition,
41

42
00:03:06,480 --> 00:03:07,810
you say the keyword default.
42

43
00:03:08,460 --> 00:03:12,780
Now, we have four cases, but who cares, they are all anyway
43

44
00:03:15,540 --> 00:03:17,290
default constructor,
44

45
00:03:17,910 --> 00:03:23,220
and if you would like to get a sense of the differences, you might say, oh, this is the only one
45

46
00:03:23,220 --> 00:03:30,100
that I generated, and B, C, and D are 3 generated cases, but still who cares about that.
46

47
00:03:30,930 --> 00:03:31,940
So here is a point.
47

48
00:03:31,950 --> 00:03:38,760
If I told you that the user defined constructor is behaving in some scenarios in a different way
48

49
00:03:39,090 --> 00:03:44,580
than the generated constructors. What is your guess?
49

50
00:03:45,060 --> 00:03:46,470
Your guess is now OK,
50

51
00:03:46,480 --> 00:03:50,370
One here is my user provided constructor, B, C and D,
51

52
00:03:50,370 --> 00:03:54,180
cases 2, 3, 4 are user defined constructor.
52

53
00:03:54,600 --> 00:03:55,530
Sadly no,
53

54
00:03:55,890 --> 00:03:57,980
and this is a bit very counterintuitive.
54

55
00:03:59,250 --> 00:04:00,650
The B is actually Yes.
55

56
00:04:00,810 --> 00:04:02,020
Isn't provided by you.
56

57
00:04:02,040 --> 00:04:03,870
So this is very clear.
57

58
00:04:04,320 --> 00:04:11,190
The C also isn't provided by you, but D is considered as a user-provided constructor.
58

59
00:04:11,700 --> 00:04:12,300
Why?
59

60
00:04:12,450 --> 00:04:17,910
Because you declared it here without any intentions, and later you decide that the definition is going
60

61
00:04:17,910 --> 00:04:20,970
to be this way, or maybe later you can define it in a different way,
61

62
00:04:21,480 --> 00:04:27,780
and the decision if it is a user-provided constructor or implicitly generated one, depends on the
62

63
00:04:27,780 --> 00:04:29,190
declaration of the definition.
63

64
00:04:29,460 --> 00:04:35,940
So the declaration here says default, but the definition declaration here doesn't say. 
64

65
00:04:35,940 --> 00:04:44,250
so the moral of that is the constructor of A and D are considered to be user-provided constructor and
65

66
00:04:44,250 --> 00:04:49,620
constructors of B and C are considered to not be a user-provided constructor.
66

67
00:04:49,890 --> 00:04:56,370
It is counterintuitive because you think here you didn't provide anything. Now still again, why there
67

68
00:04:56,370 --> 00:04:56,940
is difference?
68

69
00:04:56,940 --> 00:04:59,640
Anyway they are all four generated empty by the constructor.
69

70
00:05:00,840 --> 00:05:06,270
Sadly, there is a difference. There is what we call a default initialization and what we call a value
70

71
00:05:06,270 --> 00:05:15,180
initialization. Here in default initialization, we created A, B, C, D, and then as we didn't
71

72
00:05:15,180 --> 00:05:18,440
initialize anything for the variable i in this constructor,
72

73
00:05:18,870 --> 00:05:26,240
then when you try to output the value i of any of these objects, it's going to be garbage typically.
73

74
00:05:26,430 --> 00:05:27,150
Don't be cheated
74

75
00:05:27,150 --> 00:05:32,100
if the compiler printed zero. If you tried to print it many, many times, it is going to show you an actual
75

76
00:05:32,100 --> 00:05:32,660
garbage.
76

77
00:05:33,210 --> 00:05:39,990
So the default initialization here is just calling the empty constructor, which is doing nothing
77

78
00:05:39,990 --> 00:05:40,510
for i.
78

79
00:05:40,530 --> 00:05:42,980
So i is going to be garbage in the four cases.
79

80
00:05:43,620 --> 00:05:44,760
Now, here is the difference.
80

81
00:05:45,060 --> 00:05:47,040
What we call a value initialization.
81

82
00:05:47,190 --> 00:05:54,320
When you use the braces or the uniform initialization this way, these braces without equal is calling 
82

83
00:05:54,510 --> 00:05:55,650
value initialization.
83

84
00:05:56,010 --> 00:06:04,320
The value initialization has a different mechanism that goes directly to the values and does something
84

85
00:06:04,500 --> 00:06:12,410
only if the constructor was automatically generated.
85

86
00:06:13,080 --> 00:06:18,300
So as we said, the A and D are considered user-provided.
86

87
00:06:18,450 --> 00:06:24,350
So even in A and D with value initialization, still your constructor, which is empty, would be called.
87

88
00:06:24,540 --> 00:06:25,770
It would be still garbage.
88

89
00:06:26,200 --> 00:06:34,980
Now in the case of B and C, they are compiler defined constructor, and the compiler will
89

90
00:06:34,980 --> 00:06:37,920
not call the default constructor.
90

91
00:06:38,160 --> 00:06:45,240
It will call another mechanism that does the two value initialization with the default values
91

92
00:06:45,360 --> 00:06:46,510
for your variables.
92

93
00:06:46,860 --> 00:06:52,800
So I here, in the case of B and C, will be initialized to zero again.
93

94
00:06:52,980 --> 00:06:59,040
The constructor will not be called for the B and C, the empty constructor will not be called.
94

95
00:06:59,310 --> 00:07:02,700
There will be a special initialization for the variables that happened.
95

96
00:07:03,210 --> 00:07:09,450
So in the case of A and D, which are user-provided, the constructor will be called, and i will
96

97
00:07:09,450 --> 00:07:11,970
be just said to garbage because no one handle it,
97

98
00:07:12,300 --> 00:07:20,370
but in the case of B and C with using value initialization then  only B and C initialize member wise
98

99
00:07:20,370 --> 00:07:22,410
in a special treatment.
99

100
00:07:23,880 --> 00:07:27,270
Now, this is overall is very counterintuitive in everything,
100

101
00:07:27,660 --> 00:07:33,090
and some people say, C++ initialization is just a nightmare,
101

102
00:07:33,540 --> 00:07:35,070
and this is just one case of that.
102

103
00:07:35,340 --> 00:07:43,950
You might know that a single integer can be declared and initialized in C++ like declared in 15 different
103

104
00:07:43,950 --> 00:07:44,390
ways.
104

105
00:07:44,880 --> 00:07:45,620
This is a hell,
105

106
00:07:45,660 --> 00:07:46,380
this is a lot.
106

107
00:07:46,770 --> 00:07:52,350
So if there is a tip I would like to give you here to avoid all of these issues, even if you didn't
107

108
00:07:52,350 --> 00:07:56,570
know about them or you forgot about them or you cannot understand them is as follows:
108

109
00:07:57,030 --> 00:07:59,760
First of all, always initialize your variables.
109

110
00:07:59,940 --> 00:08:05,010
Don't let your variables here be left for the compiler or for some
110

111
00:08:05,460 --> 00:08:09,850
guessing that is going to be initialized zero if I used the value initialization.
111

112
00:08:09,850 --> 00:08:11,380
No, it will not happened, not necessary.
112

113
00:08:11,820 --> 00:08:15,090
The second way, use this value initialization.
113

114
00:08:15,090 --> 00:08:16,920
Don't leave it in the default initialization
114

115
00:08:16,920 --> 00:08:20,490
this way, this guy is going to do more mechanism.
115

116
00:08:20,670 --> 00:08:29,580
So you are by initializing your variables and using the braces style or the value initialization style, you are having
116

117
00:08:29,580 --> 00:08:31,380
more chance of more robust code.
117

118
00:08:32,000 --> 00:08:33,960
One more comment here about the variable S.
118

119
00:08:33,960 --> 00:08:40,230
The variable S here, in all cases, will be initialized to an empty constructor.
119

120
00:08:40,230 --> 00:08:40,620
Why?
120

121
00:08:40,890 --> 00:08:43,770
Because this is an object, so it's going to call anyway
121

122
00:08:43,770 --> 00:08:48,420
Its default constructor, which will be an empty case.
122

123
00:08:48,630 --> 00:08:49,680
So it's a big deal here
123

124
00:08:49,680 --> 00:08:54,030
in this string s because it has a proper constructor for it,
124

125
00:08:54,240 --> 00:08:59,820
but i here is a primitive, there's no initialization that would happen here. That's all.
