0
1
00:00:01,950 --> 00:00:04,870
Let's take the homework for the copy constructor.
1

2
00:00:06,240 --> 00:00:08,860
The first one is in the copy constructor itself,
2

3
00:00:08,880 --> 00:00:14,180
remember, it was like the argument const, my number, reference another.
3

4
00:00:14,820 --> 00:00:21,000
So one question is, in general speaking, what would happen if we moved the constructor to the
4

5
00:00:21,000 --> 00:00:26,460
private section of a class, and what would happen if we moved the copy constructor to the private section?
5

6
00:00:27,210 --> 00:00:35,700
Another concern is C++ won't allow you to use a copy constructor without the reference, why? and also
6

7
00:00:35,700 --> 00:00:40,130
C++ doesn't force you to use const, but still a very good practice to use it,
7

8
00:00:40,260 --> 00:00:41,640
Why? think about that.
8

9
00:00:43,350 --> 00:00:47,120
When we presented this my number class, we commented line 17.
9

10
00:00:47,640 --> 00:00:48,690
Why do you think so?
10

11
00:00:49,410 --> 00:00:52,050
So try to guess what's going to happen.
11

12
00:00:54,220 --> 00:00:59,590
One of the coders wrote for us this code, I would like to read it carefully, think about what will happen
12

13
00:00:59,590 --> 00:01:00,620
when we run this code,
13

14
00:01:00,790 --> 00:01:01,600
why so?
14

15
00:01:01,960 --> 00:01:05,650
Think about how to change it to prevent the user from such a wrong usage,
15

16
00:01:05,890 --> 00:01:11,950
and also provide some tips to the coder who wrote this code. 
By the way, here in 1995,
16

17
00:01:12,370 --> 00:01:19,030
whenever we delete a pointer, it's much good to put a null or even better not_pointer.
17

18
00:01:21,040 --> 00:01:24,460
We already coded this class before in one of the previous sessions.
18

19
00:01:24,580 --> 00:01:30,040
I would like you to enhance it, provide a copy constructor. In the get method, I would like you to make
19

20
00:01:30,040 --> 00:01:34,900
sure that we respect the boundaries, provide a method to change the content of the vector, and provide a method
20

21
00:01:34,900 --> 00:01:36,040
to get the array's length.
21

22
00:01:36,850 --> 00:01:40,090
So read it and do that. In a similar way,
22

23
00:01:40,180 --> 00:01:41,530
about this my vector class,
23

24
00:01:41,740 --> 00:01:47,700
one of the developers provided the get_length function as following: integer reference that returns the length.
24

25
00:01:48,160 --> 00:01:50,140
So this is a return by reference.
25

26
00:01:50,140 --> 00:01:53,710
Question number one, which OOP concept is violated this way.
26

27
00:01:54,130 --> 00:01:59,530
Also, develop a main and show how a user can abuse our class with such a mistake.
27

28
00:02:01,870 --> 00:02:08,410
I would like you to read this code and think of the following: which line of this code won't compile
28

29
00:02:08,950 --> 00:02:12,130
and which lines of this code will make a runtime error?
29

30
00:02:12,430 --> 00:02:14,020
So think about that.
30

31
00:02:16,000 --> 00:02:22,930
Finally, let's say you have a coding project, you're on it, and let's say that there is a serious
31

32
00:02:22,930 --> 00:02:24,010
memory leak in the code.
32

33
00:02:24,040 --> 00:02:32,530
A serious memory leak is someone that is that like has a lot of memory not released in this memory leak.
33

34
00:02:33,070 --> 00:02:33,960
Let's say a big array.
34

35
00:02:34,270 --> 00:02:37,890
So if you're running the program a lot, the whole memory machine will be consumed.
35

36
00:02:38,230 --> 00:02:40,690
I would like you to think, how can we know that
36

37
00:02:40,690 --> 00:02:44,140
this code has a memory leak without reading the code itself.
37

38
00:02:44,440 --> 00:02:46,480
You can just only run a code as much as you want.
38

39
00:02:46,510 --> 00:02:49,300
So think about an answer and then check out this link.
39

40
00:02:49,870 --> 00:02:50,380
That's it.
