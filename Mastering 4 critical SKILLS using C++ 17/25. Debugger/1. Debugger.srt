0
1
00:00:01,260 --> 00:00:07,470
In this video, we will learn about the debugger, which is a very strong tool that helps us figuring
1

2
00:00:07,470 --> 00:00:15,270
out the problems that happen in our code. a software bug is an error or failure or fault or whatever that
2

3
00:00:15,270 --> 00:00:16,450
happened in your program.
3

4
00:00:16,710 --> 00:00:25,650
It happens for a lot of reasons if you tried to access an invalid index of an array, that's a bug. If you divided
4

5
00:00:25,650 --> 00:00:32,040
by the zero, if you used the variable that was uninitialized, maybe memory leaks, infinite loops and,
5

6
00:00:32,040 --> 00:00:32,430
so on.
6

7
00:00:32,430 --> 00:00:33,300
A lot of reasons.
7

8
00:00:33,720 --> 00:00:37,360
And even sometimes the logic of your idea itself is wrong.
8

9
00:00:37,710 --> 00:00:42,850
Let's say someone would like to check if the number is odd or not, and he said if N mod 2 equal-equal
9

10
00:00:43,000 --> 00:00:44,740
1, looks so good code,
10

11
00:00:44,760 --> 00:00:46,890
but what if the N is a negative number?
11

12
00:00:47,130 --> 00:00:50,230
If N is negative number in the mod 2 will be negative one not
12

13
00:00:50,290 --> 00:00:50,900
just one.
13

14
00:00:51,180 --> 00:00:52,950
So you need a better condition than that.
14

15
00:00:53,220 --> 00:00:54,600
Sometimes we do implementation
15

16
00:00:54,600 --> 00:00:55,440
bug like that.
16

17
00:00:55,590 --> 00:00:58,450
Sometimes the logic of the idea itself is buggy.
17

18
00:00:58,620 --> 00:01:04,140
So there are a lot of bugs that we introduce in our code, and it really would take a lot of time from
18

19
00:01:04,140 --> 00:01:06,510
you to minimize the bugs in your code.
19

20
00:01:06,780 --> 00:01:12,690
You need to follow the coding guidelines that your team is using, like I remember referring to, for example,
20

21
00:01:12,690 --> 00:01:14,160
Google style in coding guidelines.
21

22
00:01:14,490 --> 00:01:16,730
You need to validate the input that you are using.
22

23
00:01:16,740 --> 00:01:19,380
You need to have a good habit of initializing things.
23

24
00:01:19,770 --> 00:01:24,810
You need to write your code in a modular way where your small functions or classes are handling things.
24

25
00:01:25,110 --> 00:01:27,210
You need to do a lot of testing for your code.
25

26
00:01:27,600 --> 00:01:34,820
One of the very common mistakes that guys do a lot of copy-paste for their code or maybe from stack overflow website
26

27
00:01:34,830 --> 00:01:39,510
or whatever, and they don't read the code, they just do copy-paste, and then they end up with a lot of
27

28
00:01:39,510 --> 00:01:39,900
bugs.
28

29
00:01:42,130 --> 00:01:43,270
Give you a read for that.
29

30
00:01:47,770 --> 00:01:56,500
Sometimes when the operating system has something wrong with the task, it's going to force some
30

31
00:01:56,740 --> 00:02:00,070
, maybe some stopping for it, and send what we call signals.
31

32
00:02:00,340 --> 00:02:01,380
This is a very minor topic.
32

33
00:02:01,390 --> 00:02:05,740
I don't want to go into the details, but I would like you to read it for a future reading just
33

34
00:02:05,740 --> 00:02:10,780
to be familiar with that. So the operating system can stop a task and send some signals,
34

35
00:02:11,050 --> 00:02:15,920
and C++ allows you to register some actions for this signal.
35

36
00:02:16,180 --> 00:02:25,090
So, for example, you define here whatever function, and you register this signal, if it
36

37
00:02:25,100 --> 00:02:29,940
happened from the operating system, called this function. It acts as a logger for you,
37

38
00:02:29,950 --> 00:02:34,210
for example, you can log that your program received a specific signal, anyway,
38

39
00:02:34,320 --> 00:02:35,050
skip it for now.
39

40
00:02:35,090 --> 00:02:40,210
Just wanted you to know that there are signals that come from the operating system and we can have
40

41
00:02:40,210 --> 00:02:42,410
some final handling for them in the program.
41

42
00:02:43,450 --> 00:02:44,620
Let's back to our topic,
42

43
00:02:44,830 --> 00:02:48,070
the debugging. Debugging means to find a bug.
43

44
00:02:48,400 --> 00:02:51,400
There are two approaches that we use to find bugs.
44

45
00:02:51,650 --> 00:02:56,170
The first one is what you were doing through the course, what we call the printing approach,
45

46
00:02:56,590 --> 00:03:01,180
and this is as simple as you print statements where you suspect something is wrong,
46

47
00:03:01,750 --> 00:03:06,640
and although it seems like a naive way of debugging, however, it's still a very strong one,
47

48
00:03:07,000 --> 00:03:14,350
and even in big companies like Google and Facebook, the project might be very, very, very big,
48

49
00:03:14,500 --> 00:03:18,090
and probably printing is the only way to to find a bug.
49

50
00:03:18,520 --> 00:03:20,020
So sometimes it is useful.
50

51
00:03:20,260 --> 00:03:23,320
There's also a relevant topic, what we call loggers.
51

52
00:03:23,650 --> 00:03:31,810
The loggers is something that just log several kinds of information like information, mistakes,
52

53
00:03:31,810 --> 00:03:32,380
and so on.
53

54
00:03:32,710 --> 00:03:40,760
It helps us because in reality, when the system fails, the first thing we do is to go to the logging
54

55
00:03:40,780 --> 00:03:46,960
documents and see what kind of logging statements happened in the program during running
55

56
00:03:47,260 --> 00:03:47,990
to find the bug.
56

57
00:03:48,490 --> 00:03:52,060
Anyway, this is a printing approach and you already did a lot of that.
57

58
00:03:52,660 --> 00:03:59,410
The other approach is the debugger approach, and this one is a tool called Debugger that helps you to
58

59
00:03:59,410 --> 00:04:00,910
trace your code line by line.
59

60
00:04:01,210 --> 00:04:05,830
You probably also did this tracing by yourself, looking at the code and guessing what is in this
60

61
00:04:05,830 --> 00:04:06,780
variable and so on.
61

62
00:04:07,150 --> 00:04:12,550
So the debugger does that for you, which is very powerful and very useful in small and medium projects.
62

63
00:04:15,660 --> 00:04:21,750
There is something that we call the debug symbols. We learned that the compiler generates two
63

64
00:04:21,750 --> 00:04:22,610
simple tables,
64

65
00:04:22,880 --> 00:04:30,540
remember, for the linker later. A debug symbols is another extra kind of symbols that we embed in these
65

66
00:04:30,540 --> 00:04:31,020
tables.
66

67
00:04:31,350 --> 00:04:37,980
The purpose of that is the debugger will use this information so that it gives you a line by line tracing
67

68
00:04:38,160 --> 00:04:46,050
for your code. So the whole purpose of this debug symbols is: just to be able to see the code line by line during
68

69
00:04:46,050 --> 00:04:46,520
tracing.
69

70
00:04:46,890 --> 00:04:50,790
And this takes us to something interesting that the debug mode and the release mode.
70

71
00:04:51,000 --> 00:04:53,690
Remember, when we're installing our program,
71

72
00:04:53,850 --> 00:04:57,390
we had something called debug option and release option in code blocks
72

73
00:04:57,390 --> 00:05:05,000
and in eclipse. The major difference between both of them is: the debug mode is storing the debug
73

74
00:05:05,010 --> 00:05:08,430
symbols, but the release mode doesn't store them.
74

75
00:05:09,270 --> 00:05:14,070
The release mode is, in this case, cannot be used with the debugger,
75

76
00:05:14,320 --> 00:05:17,850
and usually, this is what we use in the production itself.
76

77
00:05:18,340 --> 00:05:22,810
The debug mode is compiled with the debug symbols, and we use it with the debugger.
77

78
00:05:23,160 --> 00:05:25,020
There are a few things to know about it.
78

79
00:05:25,300 --> 00:05:28,680
The generated files is usually bigger than the release files.
79

80
00:05:28,710 --> 00:05:33,900
So, for example, if you have an executable from the release and an executable from the debug, the executable
80

81
00:05:33,900 --> 00:05:39,660
from the debug would be much bigger than the executable from the release, and the execution time from the
81

82
00:05:39,660 --> 00:05:43,020
debugger is bigger than the execution time of the release.
82

83
00:05:43,320 --> 00:05:48,120
That's why the debug mode files are for the development and bugs inspection,
83

84
00:05:48,450 --> 00:05:51,200
but the release mode is for the production,
84

85
00:05:51,540 --> 00:05:54,050
but here is what is much more important than that.
85

86
00:05:54,600 --> 00:06:00,440
Sometimes the behavior of the debug mode isn't the same as the behavior of the release mode,
86

87
00:06:00,840 --> 00:06:02,280
and this is very tricky.
87

88
00:06:02,430 --> 00:06:07,320
And you will find a lot of guys, especially in programming competitions, who complain that
88

89
00:06:07,320 --> 00:06:14,340
the program is working on their machine but doesn't work on the server or doesn't work in reality or
89

90
00:06:14,340 --> 00:06:16,030
production in the same way.
90

91
00:06:16,320 --> 00:06:18,900
This is because there is some difference between them,
91

92
00:06:19,530 --> 00:06:25,860
for example, sometimes the illegal memory access may work in the debug mode, but fails in the release
92

93
00:06:25,860 --> 00:06:26,220
mode,
93

94
00:06:26,490 --> 00:06:28,290
and as you see, the program is working well.
94

95
00:06:28,290 --> 00:06:28,830
You think
95

96
00:06:28,830 --> 00:06:35,190
that everything is OK, but you have some plus one extra access or minus one extra access that will
96

97
00:06:35,190 --> 00:06:36,420
fail in the release mode.
97

98
00:06:37,260 --> 00:06:43,350
Another very tricky case, especially for financing guys, the debugging when we have double values,
98

99
00:06:43,680 --> 00:06:49,140
there is intermediate is storing for the double values that will cause some position loss, which will
99

100
00:06:49,140 --> 00:06:55,140
make your numbers in the debugging a bit different from your numbers in the real release.
100

101
00:06:55,510 --> 00:07:03,480
So anyway, I wanted you to know there is a difference in the behaviour and the release mode is what we use
101

102
00:07:03,480 --> 00:07:04,520
really in the production,
102

103
00:07:04,740 --> 00:07:09,000
by the way, the word production means that we use it with the actual customers.
103

104
00:07:09,030 --> 00:07:14,520
This is what we give to the customers to use, and we need to make our testing in the release mode, not
104

105
00:07:14,520 --> 00:07:15,380
in the debug mood.
105

106
00:07:17,640 --> 00:07:24,380
The debugger is eventually a program, so there will be several ones with different capabilities.
106

107
00:07:24,590 --> 00:07:27,690
The GNU debugger which I'm going to use in the course is a gdb one.
107

108
00:07:29,540 --> 00:07:34,350
There is also the Microsoft visual debugger, which is a very nice one, at least comparing with
108

109
00:07:34,350 --> 00:07:35,530
the old gdb version.
109

110
00:07:35,540 --> 00:07:45,230
The Microsoft visual debugger is very strong. In a similar way, we can debug from the IDE, or we can debug also from
110

111
00:07:45,230 --> 00:07:49,120
the terminal normally, and also even in the future,
111

112
00:07:49,130 --> 00:07:51,890
you know, you can debug locally and even debug remotely.
112

113
00:07:53,120 --> 00:07:53,630
That's it.
113

114
00:07:53,630 --> 00:07:59,240
In the next sessions, we will see how to use the IDE to do some debugging.
114

115
00:07:59,870 --> 00:08:00,200
That's it.
