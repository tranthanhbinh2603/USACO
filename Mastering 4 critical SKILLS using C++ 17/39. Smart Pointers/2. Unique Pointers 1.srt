1
00:00:01,470 --> 00:00:03,100
Let's start with the pointer.

2
00:00:04,290 --> 00:00:08,930
Let's, first of all, share some of the information about all of this, might some pointers?

3
00:00:09,330 --> 00:00:14,840
First of all, every smart pointer is a class that is managing a pointer.

4
00:00:14,860 --> 00:00:16,040
You can imagine it like that.

5
00:00:16,050 --> 00:00:18,590
There is some class that is named the Unique Pointer.

6
00:00:18,990 --> 00:00:25,080
And here is our internal data that we would like to create, but we don't want to delete any more by

7
00:00:25,080 --> 00:00:25,620
ourself.

8
00:00:25,860 --> 00:00:31,020
So we have some class unique pointers that have this data inside it and it has a structure to delete

9
00:00:31,020 --> 00:00:31,170
it.

10
00:00:31,470 --> 00:00:36,830
So when I say a smart pointer, unique pointer, the pointer, I mean, it's actually a pointer.

11
00:00:36,840 --> 00:00:38,130
The class name is Pointer.

12
00:00:38,130 --> 00:00:41,550
OK, so don't confuse a smart pointer.

13
00:00:41,790 --> 00:00:48,390
Is it a pointer is actually an object that has a pointer data inside it and remember and a smart appointers,

14
00:00:48,390 --> 00:00:50,820
you create them but you do not delete them.

15
00:00:51,450 --> 00:00:58,910
The usage of the pointers are very close to the rule pointers like using the asterisk or the the the

16
00:00:59,700 --> 00:01:02,280
arrow greater than a symbol.

17
00:01:02,280 --> 00:01:03,460
I forget the name of that symbol.

18
00:01:04,560 --> 00:01:10,350
So more about the the the unique pointers so that this will be an cheat.

19
00:01:11,040 --> 00:01:13,380
The word unique here means it is one.

20
00:01:13,650 --> 00:01:15,510
There is only one owner.

21
00:01:15,600 --> 00:01:17,160
For one, it points to it.

22
00:01:17,520 --> 00:01:24,810
So we have here the internal data integral pointer and there are no other pointers who can see and accept

23
00:01:24,810 --> 00:01:26,000
this data in a direct way.

24
00:01:26,040 --> 00:01:26,730
They cannot.

25
00:01:27,720 --> 00:01:35,520
So to try to get the intuition behind that, if we have a pointer that only a single object is managing

26
00:01:35,520 --> 00:01:42,210
it, we are avoiding a lot of trouble about the destruction of the multi threading axis, about exceptions,

27
00:01:42,210 --> 00:01:43,140
about a lot of things.

28
00:01:44,280 --> 00:01:46,500
So this is the moral of the word unique.

29
00:01:46,740 --> 00:01:51,270
There is only one ownership to to to achieve that.

30
00:01:51,720 --> 00:01:57,380
We cannot allow the assigning or copying of the pointer of the object here, this much weaker object.

31
00:01:57,510 --> 00:02:02,940
So there is no implicit constructor, there is no copy constructor, there is no operator assignment

32
00:02:02,940 --> 00:02:03,330
equal.

33
00:02:03,480 --> 00:02:10,080
All of that is done to cancel the ability to steal or to exit this internal pointer internally.

34
00:02:10,320 --> 00:02:15,300
The unique pointer is implemented in a very efficient way and in the market.

35
00:02:15,450 --> 00:02:19,950
This is a pointer that you should try to use like 80 or 90 percent of your time.

36
00:02:20,280 --> 00:02:21,210
It is very safe.

37
00:02:21,420 --> 00:02:22,760
It avoids you a lot of trouble.

38
00:02:23,370 --> 00:02:25,160
So let's see some creation example here.

39
00:02:25,170 --> 00:02:27,840
We need to include memory to get the smart pointer.

40
00:02:28,530 --> 00:02:34,500
So the first way here, I'm here creating new integer array using some direct initialization here.

41
00:02:34,650 --> 00:02:38,220
And then you say unique pointer integer.

42
00:02:38,220 --> 00:02:43,410
So it's like you are saying, well, I would like a unique pointer of time into it and that's it.

43
00:02:43,680 --> 00:02:45,390
So what, what do we have here?

44
00:02:45,750 --> 00:02:52,500
We have an object, not a pointer named to be one of type unique pointer which is the end, and its

45
00:02:52,500 --> 00:02:56,070
internal data is now a new integer array here.

46
00:02:56,070 --> 00:02:58,440
And you integer value, you integrate pointer value.

47
00:02:58,860 --> 00:03:03,490
So we have an object that is managing this integrator.

48
00:03:03,930 --> 00:03:08,040
Now, when we see the following, you cannot do something like a unique pointer.

49
00:03:08,040 --> 00:03:10,070
B one equals you end twenty.

50
00:03:10,770 --> 00:03:12,270
These two things are different.

51
00:03:12,300 --> 00:03:17,580
The new end is type and the unique pointer is another time for that to be allowed.

52
00:03:17,700 --> 00:03:20,460
You need an implicit constructor that allows something like that.

53
00:03:20,820 --> 00:03:27,990
But internally, only explicit constructor is used in pointer and pointer to disallow this usage of

54
00:03:27,990 --> 00:03:28,140
this.

55
00:03:28,950 --> 00:03:30,750
So now we created the B1 pointer.

56
00:03:30,990 --> 00:03:33,330
We can like the very normal robo inter.

57
00:03:33,390 --> 00:03:36,300
We can say, oh, it has to be one which will bring the twenty.

58
00:03:36,570 --> 00:03:40,830
I can say astrobee one equal fifty, which is going to do just printed.

59
00:03:42,370 --> 00:03:48,880
Now, here, let's say, I would like to reset the pointer, like changing it to point to something

60
00:03:48,880 --> 00:03:55,280
else, not this new 20 something totally complete, one might say, okay, let's do be one equal at

61
00:03:55,300 --> 00:03:55,800
30.

62
00:03:56,110 --> 00:03:57,140
This is a new pointer.

63
00:03:57,740 --> 00:04:02,300
Now, the unique pointer doesn't allow the ability for equal assignment.

64
00:04:02,320 --> 00:04:03,790
It doesn't allow to assign it.

65
00:04:04,060 --> 00:04:07,330
If you would like to do that, you have to call the reset function.

66
00:04:07,540 --> 00:04:12,230
That is a function internally is going to delete the current pointer and use a new pointer.

67
00:04:12,250 --> 00:04:13,930
So, again, now you can use a new pointer.

68
00:04:14,530 --> 00:04:21,490
What's going to happen in this code once this function go out of the school, be one internally will

69
00:04:21,490 --> 00:04:24,900
destroy its new integer here, the thirty one.

70
00:04:25,540 --> 00:04:30,360
So as you see here, we created the pointer, but we didn't delete it.

71
00:04:30,580 --> 00:04:33,910
And this is a great advantage of the smart pointer you create.

72
00:04:34,090 --> 00:04:37,220
But you didn't leave the syntax a little bit verbose.

73
00:04:37,240 --> 00:04:44,350
Might be a little bit annoying, but otherwise it just handed the deletion for you could be constructed

74
00:04:44,350 --> 00:04:45,540
in a very similar way.

75
00:04:45,700 --> 00:04:47,620
You cannot use a copy constructor.

76
00:04:47,800 --> 00:04:50,670
So let's say that we have here the unique pointer.

77
00:04:50,680 --> 00:04:51,580
Be one of you.

78
00:04:51,580 --> 00:04:55,150
And twenty one might say, OK, let's create another pointer.

79
00:04:55,150 --> 00:04:56,350
B two of B one.

80
00:04:56,380 --> 00:04:57,780
This is a copy constructor.

81
00:04:58,000 --> 00:05:00,120
Again, the copy constructor isn't allowed.

82
00:05:00,400 --> 00:05:02,980
So there are three things that are allowed.

83
00:05:03,130 --> 00:05:06,070
You can use it, use an implicit constructor, you can use that.

84
00:05:06,070 --> 00:05:09,920
You cannot use the copy constructor, you cannot use the assignment operator.

85
00:05:10,120 --> 00:05:15,220
All of that is done to protect as much as possible the internals of the unique pointer.

86
00:05:16,670 --> 00:05:20,910
OK, what if I would like to really give my content to someone else?

87
00:05:21,380 --> 00:05:23,230
Now you have to use some of semantics.

88
00:05:23,390 --> 00:05:27,640
So if you did something like unique points of P2, equal move would be one.

89
00:05:27,830 --> 00:05:35,690
What's going to happen is the C++ is going to move the internal array of B1 to be two in a very efficient

90
00:05:35,690 --> 00:05:35,950
way.

91
00:05:36,260 --> 00:05:40,820
But notes that once we are done with this line and line 15 B.

92
00:05:40,940 --> 00:05:41,450
B.

93
00:05:43,180 --> 00:05:49,600
So this is byone don't use BE1 anymore because BE1 is now is in the value of Bittu.

94
00:05:49,840 --> 00:05:52,790
OK, so B one is gun, like you cannot use it anymore.

95
00:05:53,560 --> 00:05:56,530
So the move semanticist move the content from here to B to.

96
00:05:57,490 --> 00:06:02,550
You can if you try to doublecheck here, if you want equity control pointer, we can do the comparison.

97
00:06:02,560 --> 00:06:06,070
Normally the answer would be, yeah, it is, it's now nailbiter.

98
00:06:06,190 --> 00:06:11,520
That's why we shouldn't use it, because we moved it to content to be to what if I would like to force

99
00:06:11,530 --> 00:06:12,100
a delete.

100
00:06:12,100 --> 00:06:16,210
You can say here equal Boynton's is the only case when you can assign something.

101
00:06:16,220 --> 00:06:20,850
So it's kind of an exception and more popular is to use the reset function like that.

102
00:06:21,640 --> 00:06:23,760
But again, you don't have to do this delete.

103
00:06:23,950 --> 00:06:25,840
It is going to be done automatically

104
00:06:28,750 --> 00:06:32,710
to stress on the idea that the unique pointer is actually an object.

105
00:06:32,710 --> 00:06:36,040
I would like to remember if it's an object and it has its own address.

106
00:06:36,640 --> 00:06:39,010
But remember, inside it there is a pointer.

107
00:06:39,310 --> 00:06:41,770
And from the pointer, you know, there are two addresses.

108
00:06:42,020 --> 00:06:47,680
There is an address for the pointer itself and there is an address for the where where the winter is

109
00:06:47,680 --> 00:06:47,980
looking.

110
00:06:48,340 --> 00:06:51,670
This means that we have three addresses I'm just showing you here.

111
00:06:51,850 --> 00:06:52,960
So how to get that?

112
00:06:53,920 --> 00:06:58,360
The C++ allows you to call it to get function to get the pointer.

113
00:06:59,200 --> 00:07:01,360
Typically, you should avoid doing that.

114
00:07:01,360 --> 00:07:02,320
You should avoid that.

115
00:07:03,550 --> 00:07:07,930
I would like to see that when we needed to get we didn't use the arrow.

116
00:07:07,960 --> 00:07:09,680
We use the dot function here.

117
00:07:09,700 --> 00:07:12,310
OK, so now we have three addresses.

118
00:07:12,520 --> 00:07:16,040
The row pointer itself has its value and address one another.

119
00:07:16,060 --> 00:07:20,980
So as we used to that the object itself B has also its own address.

120
00:07:20,990 --> 00:07:25,030
You can also call the function at this of B if you would like to give the the address.

121
00:07:25,240 --> 00:07:27,940
So as I said, that unique point, that is an object.

122
00:07:27,940 --> 00:07:28,960
It has its own address.

123
00:07:28,960 --> 00:07:31,840
So that makes its word with a pointer like it's a pointer.

124
00:07:31,840 --> 00:07:33,940
Actually, it isn't just an object.

125
00:07:34,600 --> 00:07:35,050
That's it.
