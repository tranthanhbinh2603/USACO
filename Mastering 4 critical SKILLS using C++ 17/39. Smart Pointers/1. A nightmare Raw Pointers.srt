1
00:00:01,380 --> 00:00:08,790
We learned the pointers in C++, which allow us for a direct management, for the memory, like educating

2
00:00:08,790 --> 00:00:11,970
and educating is very strong, but also very dangerous.

3
00:00:12,180 --> 00:00:16,590
Remember the initialised memory, the memory leaks and the dangling pointers, a lot of issues.

4
00:00:17,100 --> 00:00:20,940
I try to help you with the simple rule and educational rule.

5
00:00:20,940 --> 00:00:26,670
I say like who creates a memory deleted something like if you are inside the class, you created a memory,

6
00:00:26,670 --> 00:00:28,530
then use that structure to delete it.

7
00:00:28,890 --> 00:00:32,190
If you are outside the class and some function and you created a memory, try to delete it.

8
00:00:32,790 --> 00:00:35,010
However, this is still very problematic.

9
00:00:35,250 --> 00:00:38,190
For example, what if a function is returning some pointer?

10
00:00:38,340 --> 00:00:39,710
Who is supposed to delete that?

11
00:00:40,200 --> 00:00:43,350
What if there is an exception in the middle of some competitions?

12
00:00:43,710 --> 00:00:45,920
Are we sure that everything is released or not?

13
00:00:46,290 --> 00:00:53,220
So there is a lot of good here to handle the the issues of the role pointers and a lot of issues that

14
00:00:53,470 --> 00:00:56,120
could just go out of the hand, out of the control.

15
00:00:56,940 --> 00:01:04,590
C++ in the modern sense, C++ 11 and then enhance it in 14 and 17 is providing us with what we call

16
00:01:04,950 --> 00:01:08,310
these multiple pointers in languages like Java.

17
00:01:08,320 --> 00:01:12,030
And they have a very strong mechanism called garbage collector.

18
00:01:12,570 --> 00:01:18,960
And in these languages, programmers totally don't care about the memory leaks and dangling pointers

19
00:01:18,960 --> 00:01:22,950
to a large extent, like everything is well handled in this language.

20
00:01:23,250 --> 00:01:31,410
C++ try to like provide a mechanism to do this garbage collection style, what we call the smart goiters

21
00:01:32,550 --> 00:01:33,570
smart appointers.

22
00:01:33,810 --> 00:01:37,650
All of it is about providing smart and automatic memory management.

23
00:01:37,830 --> 00:01:43,770
For your point that, for example, if your pointer is now out of its scope, we are just also deleting

24
00:01:43,770 --> 00:01:43,930
it.

25
00:01:44,310 --> 00:01:49,050
So again, why smart pointers to automatically delete the pointers?

26
00:01:49,350 --> 00:01:52,470
So you are creating pointers, but you don't delete them.

27
00:01:52,830 --> 00:01:56,670
It is a lot of debates about these portable as a garbage collector collection.

28
00:01:56,670 --> 00:01:59,730
The relationships on all of that, this out of scope for now.

29
00:01:59,730 --> 00:02:04,560
I would like you in the far future to come back and read a little about that in C++.

30
00:02:04,590 --> 00:02:06,570
There are three smart pointers.

31
00:02:06,840 --> 00:02:13,530
Share the pointers since C++ even and weak pointers since C++ even ubiquitous also since C++.

32
00:02:13,800 --> 00:02:15,900
But there are some enhancements in for team.

33
00:02:16,350 --> 00:02:18,690
There is also in the best what is good or 2.0.

34
00:02:18,870 --> 00:02:21,020
But this is now removed in 2017.

35
00:02:21,180 --> 00:02:22,580
You don't need to study it at all.

36
00:02:23,190 --> 00:02:24,510
So let's learn about that.
