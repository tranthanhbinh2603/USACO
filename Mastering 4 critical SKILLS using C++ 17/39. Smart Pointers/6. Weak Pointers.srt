1
00:00:00,870 --> 00:00:04,060
The last time appointers is a week is a week pointer.

2
00:00:05,310 --> 00:00:11,780
So when we shoot this good last time when we try to trace it, you probably would notice the problem.

3
00:00:12,120 --> 00:00:14,150
There is a circular reference here.

4
00:00:15,450 --> 00:00:23,070
The Embley object is needing the department object to pointer and the department is needing the Embley

5
00:00:23,490 --> 00:00:24,020
pointer.

6
00:00:24,120 --> 00:00:26,110
It has a vector of at least pointers.

7
00:00:26,580 --> 00:00:34,170
So when you go with the code and you try to do, let's say here we are creating the Embley and then

8
00:00:34,170 --> 00:00:39,220
we creating the department, we put the department at the embassy and we put that embley at the department.

9
00:00:39,570 --> 00:00:42,500
Now the employee has a department which has Embley.

10
00:00:42,780 --> 00:00:44,010
This is a cycle.

11
00:00:44,610 --> 00:00:50,210
And if you try to bring to the use count of most of them, it would be two before the end of the code.

12
00:00:50,490 --> 00:00:51,950
What's what's the problem here?

13
00:00:52,590 --> 00:00:58,620
We we have e waiting for the destruction to be released and we have the waiting for e destruction to

14
00:00:58,620 --> 00:00:59,090
be released.

15
00:00:59,370 --> 00:01:02,310
This is what we call a cycle, a circular reference.

16
00:01:02,970 --> 00:01:05,270
And as a reference account, we remain with zero.

17
00:01:05,760 --> 00:01:07,800
This is going to be a memory leak.

18
00:01:08,250 --> 00:01:09,900
So this is a problem with that code.

19
00:01:10,170 --> 00:01:12,960
And that's why, again, sure, the pointer is a bit problematic.

20
00:01:13,590 --> 00:01:18,450
The C++ tries to relax of this problem, using something we call a pointer.

21
00:01:20,050 --> 00:01:22,670
The weak pointer is a pointer to a pointer.

22
00:01:23,080 --> 00:01:24,800
Let's let's first tease this picture.

23
00:01:24,820 --> 00:01:29,890
This is a problem that we haven't yet have here, A and B, this is looking to this guy.

24
00:01:30,010 --> 00:01:31,200
This is looking to this guy.

25
00:01:31,450 --> 00:01:33,150
They are waiting for each other to be released.

26
00:01:33,160 --> 00:01:34,150
And this would never happen.

27
00:01:34,700 --> 00:01:41,940
The C++ come with the weak points following the B has a shield pointer over it, but it has a weak pointer.

28
00:01:41,950 --> 00:01:48,750
Overbey weak pointer doesn't incremented the reference account.

29
00:01:49,390 --> 00:01:54,780
So if this guy has a reference count from here, this guy doesn't have a reference account to over here.

30
00:01:55,240 --> 00:01:58,490
And this way the cycle has been terminated.

31
00:01:58,660 --> 00:02:06,060
So the moral of the weak pointer is that although it can see the the other pointer, it doesn't increment

32
00:02:06,100 --> 00:02:11,110
the counter because as we see here, the more of that the counter is incremented.

33
00:02:11,110 --> 00:02:15,270
And this was going to be a bigger cycle that we cannot release.

34
00:02:15,460 --> 00:02:24,040
But here now, if it has a pointer weak Overbey and it does it incremented the counter the now B, when

35
00:02:24,040 --> 00:02:26,860
it go out of the scope, it doesn't find anything.

36
00:02:26,890 --> 00:02:30,850
Look into it so we can simply be removed, then it can simply be removed.

37
00:02:31,090 --> 00:02:32,100
This is a model of that.

38
00:02:32,440 --> 00:02:33,400
But be careful.

39
00:02:33,640 --> 00:02:35,230
The cycle sometimes can be careful.

40
00:02:35,410 --> 00:02:39,220
We can have four classes, ABCDE and they are cycling around each other.

41
00:02:40,060 --> 00:02:43,630
Let's go and see how issued a three pointer can be created.

42
00:02:45,030 --> 00:02:50,970
There are two steps to create a three pointer, your first must have assured the pointer, then you

43
00:02:50,970 --> 00:02:53,430
create a weak pointer from the Shield, the pointer.

44
00:02:53,670 --> 00:02:55,730
That's why we call it a pointer to pointer.

45
00:02:55,980 --> 00:02:59,310
So weak pointer is a pointer looking to the shield pointer.

46
00:02:59,310 --> 00:03:04,500
The next finger will clarify that more that we have here, the Embley clause and the department clause.

47
00:03:04,770 --> 00:03:05,640
One question here.

48
00:03:05,970 --> 00:03:09,600
Which one of them to make it the weak pointer, is it the department or the employee?

49
00:03:10,290 --> 00:03:14,970
Personally, I thought like that the department should be the stronger side.

50
00:03:15,150 --> 00:03:20,550
Like I have employees for the purpose of the pointer back from the employee to the department is to

51
00:03:20,550 --> 00:03:21,690
know who is holding me.

52
00:03:21,960 --> 00:03:23,910
So the actual owner here is a department.

53
00:03:24,330 --> 00:03:30,120
That's why I decided the department has a shield of employees, but the employee has a weak point of

54
00:03:30,120 --> 00:03:30,810
department.

55
00:03:31,230 --> 00:03:35,610
Now, here in Good, you are going to create the employee.

56
00:03:35,610 --> 00:03:43,560
Normally you also are going to create normally the department, but you are going to assign these to

57
00:03:43,560 --> 00:03:44,310
this department.

58
00:03:44,430 --> 00:03:47,280
What is the type of this department is weak pointer.

59
00:03:47,520 --> 00:03:50,580
So we are actually assigning share the pointer to weak point.

60
00:03:50,760 --> 00:03:56,580
You can also make it with creation, like you say, e department equal weak pointer of the site, creating

61
00:03:56,580 --> 00:03:59,280
it of should the pointer.

62
00:03:59,610 --> 00:04:01,950
The moral of this three lines here.

63
00:04:02,400 --> 00:04:08,340
You must have assured the pointer first, then assigned or constructed to a weak pointer then now do

64
00:04:08,340 --> 00:04:09,120
the same logic.

65
00:04:09,300 --> 00:04:11,970
If you run the school you will notice is working normally.

66
00:04:12,210 --> 00:04:18,300
This guy is going to be destroyed and this guy is going to be destroyed because the weak pointer here

67
00:04:18,630 --> 00:04:21,810
created doesn't affect the difference account.

68
00:04:21,820 --> 00:04:25,890
But make sure you can trace this code now to visualize it a little more.

69
00:04:26,220 --> 00:04:27,750
This is the pointer that we have.

70
00:04:28,260 --> 00:04:34,050
This is a shared the pointer that is managing the pointer, but the pointer is just pointing to the

71
00:04:34,060 --> 00:04:34,710
straight pointer.

72
00:04:34,710 --> 00:04:36,900
That's why we say it's a pointer to a pointer.

73
00:04:37,530 --> 00:04:43,710
This means that the pointer can can talk to the shield, the pointer, but it cannot talk directly to

74
00:04:43,710 --> 00:04:44,460
the pointer.

75
00:04:44,820 --> 00:04:47,250
OK, but then I would like to access the pointer.

76
00:04:47,580 --> 00:04:49,950
The symbols provide you with the function name the lock.

77
00:04:50,370 --> 00:04:56,340
The word lock is again coming from the concurrency world when we look at object, which means that no

78
00:04:56,340 --> 00:05:02,160
one should destroy this object or play with it or right over its content and in a way that corrupted

79
00:05:02,460 --> 00:05:03,990
till we are done with it.

80
00:05:04,350 --> 00:05:11,310
So when we when you say look here is going to return the the pointer that has been used to create the

81
00:05:11,310 --> 00:05:14,670
weak pointer, now we think the pointer play with it.

82
00:05:14,940 --> 00:05:20,370
And once you are done and go out of the scope, this object now can keep going and maybe can be released.

83
00:05:20,370 --> 00:05:26,220
Also, once you take a look over this pointer, it will not be released from the memory.

84
00:05:26,340 --> 00:05:27,450
So it's safe here.

85
00:05:28,710 --> 00:05:31,980
There is another function here that's more interesting expert function.

86
00:05:32,370 --> 00:05:35,490
What if I have a weak pointer over this?

87
00:05:35,490 --> 00:05:36,330
Should the pointer?

88
00:05:36,750 --> 00:05:41,760
But then at some point someone deleted this pointer and now I came to use the pointer.

89
00:05:41,760 --> 00:05:42,600
I found it.

90
00:05:42,990 --> 00:05:49,560
If it is gone, if you didn't if the C++ doesn't help, that will help us with that.

91
00:05:49,850 --> 00:05:53,370
We are going to fix the dangling pointer for C++ to prevent that.

92
00:05:53,640 --> 00:05:59,490
It provides us with is expired the function, which is simply tell us if this pointer is still alive

93
00:05:59,490 --> 00:06:03,530
or not because the weak pointer doesn't increment the reference count here.

94
00:06:04,110 --> 00:06:10,560
So this guy can now is need an extra mechanism to know if this guy is alive or not.

95
00:06:12,210 --> 00:06:14,310
Let's see some good to the lock and expiring.

96
00:06:14,730 --> 00:06:18,420
We have here a function that's good bread inside this guy.

97
00:06:18,420 --> 00:06:23,760
And I just would like to bring to the number of employees in the department as a side note.

98
00:06:24,810 --> 00:06:29,370
Remember that this print function cannot define itself here because it's incomplete.

99
00:06:29,370 --> 00:06:31,050
You have to take it outside.

100
00:06:31,050 --> 00:06:34,350
You have to split the implementation, the declaration from the definition.

101
00:06:34,650 --> 00:06:41,430
Anyway, we right now writing our printer function, you cannot access directly from the department,

102
00:06:41,430 --> 00:06:45,140
which is a weak pointer, the employee, why it doesn't see it.

103
00:06:45,150 --> 00:06:48,210
Remember here the weak pointer doesn't see the data.

104
00:06:48,420 --> 00:06:51,030
It just see the share the so snow here.

105
00:06:51,030 --> 00:06:51,900
You cannot do that.

106
00:06:51,900 --> 00:06:52,860
You cannot access it.

107
00:06:53,040 --> 00:06:54,450
You have first to get a look over it.

108
00:06:54,840 --> 00:06:58,890
So let's see some logic that some people do in the market, which is wrong all about it right now.

109
00:06:59,700 --> 00:07:04,110
You're seeing as following you, seeing if not department expired.

110
00:07:04,620 --> 00:07:10,590
You are saying if this object isn't removed so far, then you are calling the look function.

111
00:07:11,160 --> 00:07:16,800
The look function is going to return Asgeir the pointer object to here, then you are using it.

112
00:07:17,400 --> 00:07:19,050
So let's see here two scenarios.

113
00:07:19,290 --> 00:07:25,410
In the first scenario I submitted my data and the called the function print so it come here is expired

114
00:07:25,470 --> 00:07:27,810
to get an object, get it printed.

115
00:07:27,810 --> 00:07:30,090
This is done now here.

116
00:07:30,090 --> 00:07:33,030
I'm saying the external pointer now that is gone.

117
00:07:33,450 --> 00:07:36,140
What I say print again it goes here is expired.

118
00:07:36,150 --> 00:07:36,660
Yes.

119
00:07:36,930 --> 00:07:38,640
This one is going to expire.

120
00:07:39,180 --> 00:07:43,680
So the more of that remember the weak pointer cannot access the data directly.

121
00:07:44,060 --> 00:07:50,120
And have to verify if the object is alive or not and have to call the look function to get the actual

122
00:07:50,120 --> 00:07:51,110
object appetizer.

123
00:07:51,150 --> 00:07:52,280
I know, but in a way.

124
00:07:53,680 --> 00:07:59,280
I would like to take this one more step again about the conspiracy, which I do not agree here, like

125
00:07:59,290 --> 00:08:03,690
a lot, of course, is skip this, but I felt for the sake of completeness, I should put it here,

126
00:08:03,880 --> 00:08:07,510
come back in the future to understand it in multithreaded.

127
00:08:07,570 --> 00:08:12,310
As I said, there can be more than a line of code that is working in the same time.

128
00:08:12,610 --> 00:08:17,970
So here is how this could the previous could Israel you here say, is it not expired?

129
00:08:18,250 --> 00:08:18,580
It's it.

130
00:08:18,730 --> 00:08:19,540
Oh, it's alive.

131
00:08:19,960 --> 00:08:24,970
Now you want to go to line twenty two between line to any online line to some good.

132
00:08:25,180 --> 00:08:30,700
But the D was not going to imagine that this is another could that is now corrupting your could now

133
00:08:30,700 --> 00:08:33,790
you got the object to from here which return it an object.

134
00:08:33,790 --> 00:08:41,620
But the object is internally is not a pointer then used it but it's not a pointer a give it you runtime

135
00:08:41,620 --> 00:08:41,920
error.

136
00:08:42,370 --> 00:08:49,330
So the moral of that in a different set of this good is wrong because the look function might return

137
00:08:49,480 --> 00:08:54,520
an object that is actually not a pointer if it was good with an object that has gone.

138
00:08:55,090 --> 00:09:02,170
So be careful even just checking if it's expired or not in the earlier of the code isn't is improper.

139
00:09:02,680 --> 00:09:04,060
OK, let's fix this little more.

140
00:09:05,350 --> 00:09:11,740
The right way actually is after you get an object from the lock function, you are going to verify it

141
00:09:11,740 --> 00:09:12,080
is not.

142
00:09:12,670 --> 00:09:14,440
If it is a null you are using it.

143
00:09:14,620 --> 00:09:16,660
If it is not, then it's actually expired.

144
00:09:16,810 --> 00:09:18,040
So there are two cases here.

145
00:09:18,250 --> 00:09:23,830
Is it early expired or not not expired and were done if not expired.

146
00:09:24,160 --> 00:09:27,280
While we are going inside the function, it could be it expired.

147
00:09:27,490 --> 00:09:28,810
So again, double check again.

148
00:09:29,440 --> 00:09:33,020
If you thought about that for a while, then the expired function doesn't have a need.

149
00:09:33,100 --> 00:09:34,750
We can actually make it much more simpler.

150
00:09:35,050 --> 00:09:41,080
We can do something like that if or two department original equals Department of Luck, which means

151
00:09:41,080 --> 00:09:43,720
bring for me an object from this guy and a check.

152
00:09:43,720 --> 00:09:45,520
If it is not or not, then just use it.

153
00:09:46,390 --> 00:09:51,810
Regards if you understood what I said about the concurrency or not, this is how you should use a weak

154
00:09:51,820 --> 00:09:52,300
pointer.

155
00:09:52,600 --> 00:09:55,900
You should call that lock verify condition.

156
00:09:56,110 --> 00:10:00,790
So if you if you could if you didn't get what I'm saying about the Cucaracha, totally OK.

157
00:10:00,940 --> 00:10:03,540
Just make sure you are using it exactly this way.

158
00:10:04,060 --> 00:10:05,290
Now, this is of a question.

159
00:10:05,500 --> 00:10:06,970
So what is the value of this about?

160
00:10:06,970 --> 00:10:12,100
The function fixed by the function is the purpose of it is more of the cleaner.

161
00:10:12,610 --> 00:10:15,820
It can tell us if the pointer is is alive or not.

162
00:10:15,970 --> 00:10:20,260
So, for example, imagine that you have a queue of weak pointers and every time you are checking if

163
00:10:20,260 --> 00:10:26,710
some of some if some pointer is good, then just remove it from the queue so that the purpose of expire

164
00:10:26,710 --> 00:10:31,990
is just to check if it exists or not without having to return an object instance of it.

165
00:10:33,310 --> 00:10:41,620
Sometimes even there might be intended design to use a weak pointer, although there is no, although

166
00:10:41,620 --> 00:10:42,310
there is no,

167
00:10:45,410 --> 00:10:48,670
although there is no cycles like it's intended.

168
00:10:48,700 --> 00:10:55,930
Now, let's say you have somebody sort of like a DBRS and then you you would like to give this database

169
00:10:55,930 --> 00:10:57,940
to some other classes who would be using it.

170
00:10:58,300 --> 00:11:04,690
But the logic is, if the database got closed again, then whoever is using the database now should

171
00:11:04,690 --> 00:11:05,500
stop using it.

172
00:11:05,770 --> 00:11:07,420
So sometimes this is a bit intended.

173
00:11:07,700 --> 00:11:13,870
In this case, you also go and design the other dependent objects to be weak pointers and then they

174
00:11:13,870 --> 00:11:16,060
are checking if the object exists or not.

175
00:11:16,060 --> 00:11:18,850
If not exists, then they stop using it.

176
00:11:20,750 --> 00:11:25,900
Anyway, also, if you didn't get about this scenario for now, throw it behind your back, it isn't

177
00:11:25,940 --> 00:11:28,510
easy to imagine the moral of what I want to say here.

178
00:11:28,640 --> 00:11:31,440
This is how you should be using the object here.

179
00:11:32,060 --> 00:11:32,600
That's it.
