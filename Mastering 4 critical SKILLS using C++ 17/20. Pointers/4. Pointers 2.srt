0
1
00:00:00,690 --> 00:00:05,400
Let's continue playing with pointers. The only way by the way to be good in pointers is just to
1

2
00:00:05,400 --> 00:00:06,330
keep playing with it.
2

3
00:00:07,470 --> 00:00:12,280
In this example here we have two values, val1 with 5, val2 with 15.
3

4
00:00:12,570 --> 00:00:15,390
So here we are printing the addresses of these two values,
4

5
00:00:15,730 --> 00:00:23,720
then I started to define pointer number one, p1, to look at the address of val1, pointer p2 
5

6
00:00:23,730 --> 00:00:24,660
has no value here
6

7
00:00:24,660 --> 00:00:30,130
but then I assigned the value here to point to the reference of val2.
7

8
00:00:30,840 --> 00:00:38,400
Now, if I started to say asterisk p1 equals 10, asterisk p1 means the value pointed by p1 which
8

9
00:00:38,400 --> 00:00:39,780
is val1 equals 10.
9

10
00:00:40,070 --> 00:00:45,030
OK. So whenever you see asterisk p, start to think, oh, where I am pointing val1,
10

11
00:00:45,040 --> 00:00:46,100
then val1 is 10.
11

12
00:00:46,770 --> 00:00:53,130
On the other side here, I'm saying asterisk p2, which is val2 equals asterisk p1
12

13
00:00:53,400 --> 00:00:55,260
...
13

14
00:00:55,800 --> 00:00:57,980
which is val1 plus 6.
14

15
00:00:58,800 --> 00:01:03,180
So val1 is 10 now plus 6 is 16.
15

16
00:01:03,360 --> 00:01:06,520
So if you printed the two values of val1 and val2, 10 and 16.
16

17
00:01:06,840 --> 00:01:12,150
So advice number one, every time you see asterisk p1, just think, oh,
17

18
00:01:12,270 --> 00:01:18,390
what is the original value of val1 used here? val1 equals 10, val2 equals to val1 plus 6.
18

19
00:01:18,510 --> 00:01:20,820
That's it. Keep going,
19

20
00:01:21,000 --> 00:01:23,960
I'm saying here p1 equals p2.
20

21
00:01:24,870 --> 00:01:31,200
This means that we are going to take the value inside p2 and put it inside the value of p1,
21

22
00:01:31,600 --> 00:01:34,990
but what is in p2? it is a reference val2.
22

23
00:01:35,340 --> 00:01:38,460
So now p1 is looking to the reference of val2.
23

24
00:01:38,460 --> 00:01:43,900
If you tried to print to the address, It would be the address of val2. Now, asterisk p1 equals 20.
24

25
00:01:44,190 --> 00:01:44,940
Wait a second.
25

26
00:01:45,060 --> 00:01:46,290
What is asterisk p1?
26

27
00:01:46,620 --> 00:01:55,110
It is val2. So putting val2 with 20 and printing the two values here, which is now focusing
27

28
00:01:55,110 --> 00:01:56,640
on val2 not val1.
28

29
00:01:58,510 --> 00:02:05,220
Here I am changing again p1 to look at val1. Printing the two values, it will be 10 and 20.
29

30
00:02:05,740 --> 00:02:10,210
I can call the swap function of STL and swap both of them.
30

31
00:02:10,210 --> 00:02:16,480
If I swapped both of them, I'm swapping the address of p1 with the address of p2.
31

32
00:02:16,720 --> 00:02:19,450
So it's now asterisk p1 and asterisk p2, it will be 20
32

33
00:02:19,630 --> 00:02:28,810
and 10. If I define double X equal 10 (I try to make the address p1 to be pointing to
33

34
00:02:28,810 --> 00:02:33,730
the X ) is going to compile-error. It will tell you double-pointer conversion to an integer pointer.
34

35
00:02:34,030 --> 00:02:39,800
It means you are trying to make a pointer of type integer to look at a value of type double.
35

36
00:02:40,210 --> 00:02:40,840
Don't do that.
36

37
00:02:40,840 --> 00:02:42,580
So you need some consistency here.
37

38
00:02:44,310 --> 00:02:50,400
Similar to defining pointers with integers, we can define a pointer with double, I can define a string
38

39
00:02:50,400 --> 00:02:55,260
and then refer to this string. I can have a vector and then pointer to this vector.
39

40
00:02:55,560 --> 00:03:00,040
I can change the value of vector with another value of a new vector.
40

41
00:03:00,240 --> 00:03:05,910
So here the value of the vector, initially of size 3. I changed the content of 10 numbers.
41

42
00:03:06,090 --> 00:03:07,120
Now the size is 10.
42

43
00:03:07,350 --> 00:03:09,420
We are going to play more later with vectors.
43

44
00:03:09,780 --> 00:03:15,970
So the more of that, you can definitely use different pointer variables here.
44

45
00:03:16,230 --> 00:03:18,330
There is a very fundamental information here to know.
45

46
00:03:18,840 --> 00:03:23,280
The size in the memory of all of these pointers is the same.
46

47
00:03:23,760 --> 00:03:26,480
The size doesn't change when you change the data type.
47

48
00:03:26,520 --> 00:03:30,510
Remember, the pointer is just a variable that's looking to an address.
48

49
00:03:30,750 --> 00:03:35,970
So it doesn't care if you are looking to a vector or looking to a very big array or looking to a single
49

50
00:03:35,970 --> 00:03:36,390
number.
50

51
00:03:36,630 --> 00:03:38,070
It's just need an address value.
51

52
00:03:38,080 --> 00:03:41,750
So this is all what is a pointer is, so the size doesn't change.
52

53
00:03:42,960 --> 00:03:46,680
OK. So far, there is a fundamental question.
53

54
00:03:46,680 --> 00:03:49,350
Why do you need to introduce pointers?
54

55
00:03:49,380 --> 00:03:52,470
It seems like just references like another address in memory.
55

56
00:03:52,810 --> 00:03:56,760
OK, here is the fundamental reasons why we have pointers.
56

57
00:03:57,090 --> 00:04:00,140
Pointers allow dynamic memory allocation.
57

58
00:04:00,180 --> 00:04:00,960
What does this mean?
58

59
00:04:01,410 --> 00:04:06,610
If you have an array of size 10, this is a fixed memory allocated array of a change 10.
59

60
00:04:06,630 --> 00:04:10,540
You cannot rechange the array to be bigger, it just 10 nothing more.
60

61
00:04:11,160 --> 00:04:15,120
Remember, something like the vector in STL. The vector is growing up,
61

62
00:04:15,420 --> 00:04:17,070
what is happening behind the scene?
62

63
00:04:17,280 --> 00:04:23,310
There is a pointer to an array, and we keep reallocating the array every time we need.
63

64
00:04:23,670 --> 00:04:26,130
There would be...
64

65
00:04:27,040 --> 00:04:29,880
a video session about dynamic memory allocation.
65

66
00:04:30,000 --> 00:04:31,800
I just wanted you to know
66

67
00:04:31,860 --> 00:04:33,870
why are we introducing pointers?
67

68
00:04:34,320 --> 00:04:39,660
There will be several lectures that will be just exploring a lot about pointer syntax, which will have
68

69
00:04:39,660 --> 00:04:42,030
a lot of correspondence with the references,
69

70
00:04:42,150 --> 00:04:45,530
and after that, we will come back to the memory allocation issue.
70

71
00:04:46,140 --> 00:04:46,640
That's it.
