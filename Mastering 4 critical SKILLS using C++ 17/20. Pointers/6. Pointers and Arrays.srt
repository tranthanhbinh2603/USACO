0
1
00:00:01,350 --> 00:00:04,140
Let's see when pointers come with arrays.
1

2
00:00:04,170 --> 00:00:05,550
There's a lot of nice things here.
2

3
00:00:05,880 --> 00:00:13,170
Before going to the pointers, I would like to refresh with you how the array in memory existsed. If
3

4
00:00:13,170 --> 00:00:15,520
you have an array of four numbers.
4

5
00:00:15,750 --> 00:00:21,180
So, for example, if you say cout array of 2 equals 7, then it would be 7. In memory,
5

6
00:00:21,180 --> 00:00:25,910
C++ has defined 4 integers consecutively in the memory. Consecutively.
6

7
00:00:25,920 --> 00:00:27,220
They must be consecutive.
7

8
00:00:27,480 --> 00:00:30,450
For example, it might define them with the following addresses.
8

9
00:00:30,750 --> 00:00:36,540
If you go to the memory, you'll find the 5th, 6th, 7th, and 8th are consecutive and this is their
9

10
00:00:36,540 --> 00:00:38,740
addresses. In 2D array,
10

11
00:00:38,760 --> 00:00:39,780
It's a bit similar one.
11

12
00:00:39,790 --> 00:00:42,270
Let's say that you have an array here of 3 times 4.
12

13
00:00:42,560 --> 00:00:46,920
Remember, once you did the flattening of the array, if you have an array of 3 times 4, we can
13

14
00:00:46,920 --> 00:00:48,030
flatten it to 12.
14

15
00:00:48,420 --> 00:00:54,930
Now, what happens in memory actually is that we have these 12 numbers consecutively in the memory also.
15

16
00:00:55,380 --> 00:00:57,450
In a row-major order style,
16

17
00:00:57,630 --> 00:00:59,010
They are actually the first row,
17

18
00:00:59,020 --> 00:00:59,870
then the second row,
18

19
00:00:59,890 --> 00:01:01,140
the third row in the memory.
19

20
00:01:01,620 --> 00:01:05,550
There is something that rarely used the column-major order, which is column number 1, column number 2,
20

21
00:01:05,550 --> 00:01:08,110
column number 3. The same logic for 3D arrays.
21

22
00:01:08,490 --> 00:01:09,860
So here is the 2D array.
22

23
00:01:10,080 --> 00:01:15,570
We take the first four numbers, followed by the second four numbers, followed by the third four numbers,
23

24
00:01:15,720 --> 00:01:18,250
all of them consecutive in the memory.
24

25
00:01:18,600 --> 00:01:20,750
What if I have 3D array here?
25

26
00:01:21,000 --> 00:01:26,410
Let's say that you are looping with i, j, and k from 0 to 1, 0 to 2, 0 to 3.
26

27
00:01:26,550 --> 00:01:33,960
OK, the order of accessing the array of i, j, and k is the same order for all of these elements, which
27

28
00:01:33,960 --> 00:01:35,700
will be 24 in the memory.
28

29
00:01:36,600 --> 00:01:38,610
Now, let's go back to the pointers.
29

30
00:01:39,690 --> 00:01:43,250
This is an array. Surprisingly, and we never did that before,
30

31
00:01:43,440 --> 00:01:47,880
If you tried to cout the arr here, it is going to print an address.
31

32
00:01:48,240 --> 00:01:49,470
This is a bit weird thing for you.
32

33
00:01:49,950 --> 00:01:53,570
This is the address of the first element of the array.
33

34
00:01:53,670 --> 00:01:55,740
Remember, all of them are consecutive.
34

35
00:01:56,010 --> 00:01:56,690
Wait a second.
35

36
00:01:56,910 --> 00:02:04,560
If you say this is the first element in the array, then the value here in Array 0 should have a reference
36

37
00:02:04,560 --> 00:02:06,940
array of 0 to also be the same value,
37

38
00:02:07,170 --> 00:02:08,340
and this is what you see here.
38

39
00:02:08,550 --> 00:02:12,780
...The array of zero is just the first integer,
39

40
00:02:12,780 --> 00:02:13,110
Right?
40

41
00:02:13,320 --> 00:02:17,630
So if you said the reference of the first element in the array, it is going to print the first element of the
41

42
00:02:17,640 --> 00:02:23,070
array, which is the same as here. In a similar way, we can have reference value to point to the
42

43
00:02:23,070 --> 00:02:24,320
first element of the array
43

44
00:02:24,330 --> 00:02:27,400
and again, the val would have the same reference as the
44

45
00:02:27,400 --> 00:02:27,610
array.
45

46
00:02:28,200 --> 00:02:29,480
Now, let's go to the pointers.
46

47
00:02:30,090 --> 00:02:37,290
If you defined the pointer, you can put here directly arr. OK, why? because arr array here is an address,
47

48
00:02:37,500 --> 00:02:38,280
actually an address
48

49
00:02:38,310 --> 00:02:41,450
when we see from printing. that's why we can directly assign it.
49

50
00:02:41,820 --> 00:02:47,310
So we see so far when we assign something to the pointer, it has to be addressed. Either array directly or
50

51
00:02:47,310 --> 00:02:50,760
another pointer, or if it's a value, then you have take the reference.
51

52
00:02:50,760 --> 00:02:53,800
So you eventually have to put an address of something.
52

53
00:02:54,450 --> 00:02:57,450
Now, the address of the pointer is looking at the array.
53

54
00:02:57,750 --> 00:02:59,580
Let's print our three common things.
54

55
00:03:00,020 --> 00:03:05,430
Let's print asterisk-ptr and reference of ptr. Reference of ptr is my pointer
55

56
00:03:05,430 --> 00:03:05,870
address.
56

57
00:03:06,120 --> 00:03:07,160
We don't care about that.
57

58
00:03:07,650 --> 00:03:13,860
The ptr itself, which is a value, is the same as the value of the array and the value of it is 3,
58

59
00:03:13,860 --> 00:03:17,550
which is the first element in the array. Now, here is an interesting thing.
59

60
00:03:17,820 --> 00:03:23,190
Once you assigned a pointer to an array, you can deal with the pointer exactly as you deal with the
60

61
00:03:23,190 --> 00:03:23,490
array.
61

62
00:03:23,670 --> 00:03:29,040
So for example, I can say pointer Zero equals 10, pointer 1 equals 20 and I can iterate on the
62

63
00:03:29,040 --> 00:03:32,610
array and print it, then just print it as if it has changed already.
63

64
00:03:33,090 --> 00:03:35,600
So this is an interesting thing about the pointer to array.
64

65
00:03:35,790 --> 00:03:38,160
Please familiarize yourself with this line of code.
65

66
00:03:40,310 --> 00:03:45,730
There is also a fancy thing that you might use from time to time, which we call the offset notation.
66

67
00:03:46,010 --> 00:03:48,630
so here is an area and we define a pointer to it.
67

68
00:03:48,980 --> 00:03:55,520
Now, if we try to print pointer plus zero, pointer plus one, pointer plus two, this is going to give you the
68

69
00:03:55,520 --> 00:04:00,560
same address of the first element in the array, the address of the second element in the array, the
69

70
00:04:00,560 --> 00:04:02,510
address the third element in the array.
70

71
00:04:02,900 --> 00:04:09,650
So pointer plus index, which we call it the offset notation, is just moving cells in the memory, moving
71

72
00:04:09,650 --> 00:04:11,780
cell by cell. In a similar way,
72

73
00:04:12,020 --> 00:04:18,530
If I did here something like asterisk ptr plus zero, asterisk of ptr plus one, notice the parentheses here, asterisk ptr
73

74
00:04:18,540 --> 00:04:19,370
plus two.
74

75
00:04:19,640 --> 00:04:21,950
This is same as array of two here.
75

76
00:04:22,350 --> 00:04:28,850
OK, in a similar way, surprisingly, you can even use the offset notation with the array itself.
76

77
00:04:29,040 --> 00:04:35,550
If you say array plus two-asterisk, it is going to print the value of the array at position 2.
77

78
00:04:35,840 --> 00:04:36,810
So here is the logic.
78

79
00:04:36,980 --> 00:04:39,860
Array is eventually an address in the memory. Array
79

80
00:04:39,860 --> 00:04:42,710
plus 2 means move two cells in the memory.
80

81
00:04:42,920 --> 00:04:49,910
Asterisk means get me the value where this pointer is looking at, which is just the value of the array.
81

82
00:04:50,270 --> 00:04:56,060
So array of index we call it subscript notation using the bracket style and asterisk of pointer plus 2
82

83
00:04:56,060 --> 00:04:58,550
we call it the offset notation.
83

84
00:04:59,120 --> 00:05:00,950
here is one of the common mistakes.
84

85
00:05:01,940 --> 00:05:13,700
What is the difference between asterisk pointer plus 3 and asterisk, open parentheses and put pointer plus
85

86
00:05:13,700 --> 00:05:14,100
3.
86

87
00:05:14,660 --> 00:05:16,130
So here is the logic.
87

88
00:05:16,310 --> 00:05:20,870
Once we used an asterisk, it means to get the value of this address.
88

89
00:05:21,140 --> 00:05:27,330
So asterisk ptr is going to get for you the value 3, which is the first element of the array,
89

90
00:05:27,950 --> 00:05:30,440
then when we have another 3, it would be 3 plus 3,
90

91
00:05:30,470 --> 00:05:31,370
So overall 6.
91

92
00:05:31,970 --> 00:05:37,640
Now, on the other side here, when we say pointer plus 3, it means to move through three cells in
92

93
00:05:37,640 --> 00:05:42,500
the memory, which will be at 9.
93

94
00:05:42,500 --> 00:05:44,630
If you are here one steps, two steps, three steps,
94

95
00:05:44,660 --> 00:05:47,610
We are at now at 9, at the address of 9. Asterisk of
95

96
00:05:47,640 --> 00:05:50,920
that is going to give you the value itself.
96

97
00:05:51,200 --> 00:05:52,280
So be very careful.
97

98
00:05:52,580 --> 00:05:54,350
Where are you applying your asterisk.
98

99
00:05:54,500 --> 00:05:57,580
Is it directly on the pointer or is it on a shifted pointer.
99

100
00:05:57,590 --> 00:05:59,000
Here's a shifted, here directly.
100

101
00:06:00,460 --> 00:06:06,370
Pointers arithmetic, remember the i++, and ++i, you can do the same arithmetic
101

102
00:06:06,370 --> 00:06:11,650
on the pointers, for example, if you have a pointer here( A few minutes ago,
102

103
00:06:11,680 --> 00:06:18,250
we said that pointer plus one is moving one cell in the memory) plus-plus pointer is moving one step
103

104
00:06:18,250 --> 00:06:20,570
in the memory so that we can print it.
104

105
00:06:20,590 --> 00:06:25,510
So if you are here at 3, plus-plus pointer is moving one cell in the memory. We are here now printing it comes
105

106
00:06:25,510 --> 00:06:25,800
5.
106

107
00:06:26,410 --> 00:06:33,010
If you said asterisk-ptr plus-plus, this means to print the value where this pointer that is pointing,
107

108
00:06:33,160 --> 00:06:34,420
then increment the pointer.
108

109
00:06:34,690 --> 00:06:36,780
So asterisk-ptr here is now at 5,
109

110
00:06:36,820 --> 00:06:37,780
we are going to print it,
110

111
00:06:37,960 --> 00:06:39,250
then it moved to the next cell,
111

112
00:06:39,280 --> 00:06:40,980
It would be at 7 then asterisk
112

113
00:06:41,000 --> 00:06:46,570
ptr is printing 7 again. Now asterisk plus plus ptr,
113

114
00:06:46,990 --> 00:06:51,600
this is going to Increment the pointer to the next cell first, then get the value of it.
114

115
00:06:51,700 --> 00:06:58,300
So we are here at 7, move to 9 first, then print the value 9, print the value 9. Similar way,
115

116
00:06:58,300 --> 00:07:00,670
we can use the minus minus to go steps back.
116

117
00:07:01,060 --> 00:07:05,410
Also in a very similar way, you can say plus equals 2, minus equals 3.
117

118
00:07:05,440 --> 00:07:07,840
You can move positions in the memory.
118

119
00:07:08,140 --> 00:07:15,310
So if know we were here, if you moved two steps back, It is going
119

120
00:07:15,310 --> 00:07:16,120
to be one step,
120

121
00:07:16,120 --> 00:07:18,190
two steps is going to be back at 3.
121

122
00:07:20,500 --> 00:07:27,250
OK, now if we get another minus-minus pointer, it's going to go one step before the first element
122

123
00:07:27,250 --> 00:07:27,790
in the array.
123

124
00:07:28,150 --> 00:07:29,110
Be very careful.
124

125
00:07:29,140 --> 00:07:30,760
You are now out of the boundaries.
125

126
00:07:31,270 --> 00:07:33,160
OK, back to pointers,
126

127
00:07:33,190 --> 00:07:40,030
Let's say I said pointer equals array plus 3, given the pointer is an address and array is an address, if you
127

128
00:07:40,720 --> 00:07:46,300
subtracted them from each other, the compiler will compute the number of shifted cells from here to
128

129
00:07:46,300 --> 00:07:46,570
there.
129

130
00:07:46,900 --> 00:07:52,030
So the pointer minus array is there are 3 cells pointers difference.
130

131
00:07:54,200 --> 00:07:58,780
OK, let's do one more thing.
131

132
00:07:59,800 --> 00:08:06,150
If I said here pointer is an array at the beginning, then I say plus-plus asterisk pointer.
132

133
00:08:06,640 --> 00:08:09,730
Remember, we have here the syntax of asterisk plus-plus pointer.
133

134
00:08:09,940 --> 00:08:12,580
Again, think of the pointer and do it step by step.
134

135
00:08:12,880 --> 00:08:20,100
The first thing applied here is an asterisk, asterisk pointer is getting the value of the current
135

136
00:08:20,100 --> 00:08:22,410
cell, which is the first element, which is 3.
136

137
00:08:22,750 --> 00:08:26,960
So the value is now 3, now 3 plus-plus is 4.
137

138
00:08:27,610 --> 00:08:28,870
Now here's an interesting thing.
138

139
00:08:29,110 --> 00:08:33,670
If you tried to subtract, the pointer from the array, it would be zero.
139

140
00:08:33,850 --> 00:08:34,960
The pointer didn't move.
140

141
00:08:35,260 --> 00:08:36,250
So be very careful.
141

142
00:08:36,460 --> 00:08:43,030
There is a difference between asterisk plus-plus pointer and plus-plus asterisk pointer, both of them are
142

143
00:08:43,030 --> 00:08:43,660
prefix,
143

144
00:08:43,900 --> 00:08:45,370
but which one is applied first?
144

145
00:08:45,370 --> 00:08:47,320
Look to the pointer, here
145

146
00:08:47,410 --> 00:08:52,540
the plus-plus first then you get the value. Here you get the value then you increment it.
146

147
00:08:52,780 --> 00:08:55,510
OK, so this one is playing with the address in the memory.
147

148
00:08:55,510 --> 00:08:57,220
It's moving it one cell forward.
148

149
00:08:57,430 --> 00:08:59,320
This one didn't move the pointer at all.
149

150
00:09:00,370 --> 00:09:03,580
As you see, it could be a bit puzzling and tricky.
150

151
00:09:03,790 --> 00:09:09,220
I would like you to play a lot with this Syntex to make sure you are familiar when you apply minus
151

152
00:09:09,220 --> 00:09:10,240
minus and plus-plus,
152

153
00:09:10,270 --> 00:09:12,820
What really happens to the pointer?
153

154
00:09:13,970 --> 00:09:15,010
A few interesting things,
154

155
00:09:15,250 --> 00:09:18,760
We can iterate over an array using the pointer just for fun.
155

156
00:09:18,970 --> 00:09:21,700
Let's say we defined here asterisk-pointer to be here.
156

157
00:09:22,030 --> 00:09:27,940
We can now do the following: while pointer not equals array plus 4. What is pointer? it is an address.
157

158
00:09:28,090 --> 00:09:29,800
What is the array? array is an address.
158

159
00:09:29,980 --> 00:09:37,900
So as long as the pointer didn't reach the address of one element after the array,
159

160
00:09:38,260 --> 00:09:41,470
then we are simply we can print the numbers.
160

161
00:09:41,800 --> 00:09:43,120
So this way we are printing them.
161

162
00:09:43,300 --> 00:09:49,590
If you tried to print five elements, It is going to give you definitely here a wrong garbage value so be careful.
162

163
00:09:49,750 --> 00:09:51,070
So one lesson here,
163

164
00:09:51,070 --> 00:09:56,770
you can use the pointer and you are now comparing addresses together, which is a very fun thing
164

165
00:09:57,460 --> 00:09:58,450
In a similar way,
165

166
00:09:58,630 --> 00:10:05,050
If you defined an array of characters and you defined an asterisk to point to it, you can also keep printing
166

167
00:10:05,050 --> 00:10:05,350
it,
167

168
00:10:05,530 --> 00:10:10,570
but in an easier way here, we know that this hello will have a  null character in its end.
168

169
00:10:10,810 --> 00:10:18,310
So we can as long as the str not equals the back-slash zero, just go and print it and move to the next pointer.
169

170
00:10:19,360 --> 00:10:20,610
Comparing pointers,
170

171
00:10:20,650 --> 00:10:22,870
this is a bit very tricky and a common mistake.
171

172
00:10:23,230 --> 00:10:25,840
Let's say you have str1 and str2, which both are
172

173
00:10:25,840 --> 00:10:30,760
Mostafa. If you tried to say str1 equals-equals str2, it would definitely say true.
173

174
00:10:31,540 --> 00:10:36,400
Now, let's say we defined 2 pointers, pointer p1 is looking to str1, pointer p2
174

175
00:10:36,520 --> 00:10:41,610
is looking to str2. I'm here using the initializer list style, which is more preferred in C++ style.
175

176
00:10:42,910 --> 00:10:49,810
Now if I tried to say p1 equal-equal p2, this would be false. Wait a second, p1 is an address, p2
176

177
00:10:49,810 --> 00:10:51,400
is another address.
177

178
00:10:51,400 --> 00:10:52,720
Are they equal addresses?
178

179
00:10:52,720 --> 00:10:53,020
No.
179

180
00:10:53,410 --> 00:10:57,550
OK, but we didn't target to compare addresses, we want to compare values.
180

181
00:10:57,790 --> 00:11:03,220
So if I said asterisk p1 equal-equal asterisk p2, it would be true. So be very careful.
181

182
00:11:03,670 --> 00:11:06,730
Do you really want to compare addresses or compare values?
182

183
00:11:06,730 --> 00:11:08,590
You have to be careful to avoid mistakes.
183

184
00:11:09,280 --> 00:11:09,880
That's it.
