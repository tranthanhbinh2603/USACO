WEBVTT

00:00:00.810 --> 00:00:08.220
Trong phần này, chúng tôi sẽ
giới thiệu mẫu, đây là một trong

00:00:08.220 --> 00:00:10.430
những chức năng trong C++, nó có
hai loại mẫu chức năng và mẫu lớp.

00:00:10.800 --> 00:00:15.150
Vì vậy, hãy giới thiệu vấn đề khuyến khích ý tưởng về các mẫu,

00:00:15.540 --> 00:00:21.570
nếu bạn đang tìm kiếm chức
năng này ở đây, Tối đa của A và B,

00:00:21.570 --> 00:00:22.920
thì đó chỉ là chức năng bình
thường là.... A và B, bây giờ

00:00:23.100 --> 00:00:28.440
nếu tôi cố gắng gọi hàm này chỉ với các giá
trị kép, tôi sẽ tải độ chính xác nên cách tiêu

00:00:28.440 --> 00:00:33.570
chuẩn để xử lý theo cách này là sao chép mã
này như ở đây và chỉ cần thay thế hai loại

00:00:33.570 --> 00:00:34.570
với Max và sử dụng nó.

00:00:35.160 --> 00:00:38.820
Bây giờ, giả sử bạn muốn
sử dụng nhiều loại dữ liệu

00:00:38.820 --> 00:00:40.080
hơn, giả sử muốn lấy giá
trị tối đa giữa hai ký tự, v.v.

00:00:40.440 --> 00:00:43.710
Bạn phải tiếp tục tạo các bản sao và bản sao mã trùng lặp,

00:00:44.250 --> 00:00:50.940
nhưng hãy quan sát rằng chúng hoàn toàn
giống logic, đối với kiểu dữ liệu ở đây,

00:00:50.940 --> 00:00:55.210
bất kể số kép hay số nguyên hay ký tự hay
bất cứ thứ gì, nó hoàn toàn giống logic,

00:00:55.680 --> 00:01:01.140
hãy tưởng tượng trong một thời gian rằng chúng tôi phát
hiện ra một lỗi trong chức năng này hoặc chúng tôi thấy

00:01:01.140 --> 00:01:08.700
rằng có một cách triển khai nhanh hơn nó, chúng tôi phải
tìm mọi chức năng trùng lặp của mình và chỉ cần lấy nó và

00:01:08.820 --> 00:01:09.990
thực hiện một sửa đổi cho nó.

00:01:10.800 --> 00:01:16.050
Khi nói đến sự trùng lặp trong
mã, trong công nghệ phần mềm,

00:01:16.050 --> 00:01:16.400
chúng tôi.... rất nhiều điều
rằng có điều gì đó không ổn.

00:01:16.830 --> 00:01:23.910
Bây giờ các mẫu đến để giúp chúng tôi giải quyết vấn đề này như sau, trình biên dịch sẽ đọc

00:01:24.240 --> 00:01:25.350
một cái gì đó như thế,

00:01:25.530 --> 00:01:28.320
Tôi đang xác định ở đây một số chức năng mà tôi đặt tên ở đây là "MyMax",

00:01:28.620 --> 00:01:33.750
hãy tưởng tượng một lúc rằng chúng ta có một số cấu trúc có tên "Type" và chúng ta có loại A và loại B,

00:01:34.500 --> 00:01:40.830
bây giờ khi C++ thấy từ
này "kiểu tên kiểu mẫu"

00:01:40.830 --> 00:01:42.530
thì có nghĩa là hàm này
sẽ được gọi với một số kiểu

00:01:42.540 --> 00:01:45.300
nó có thể là số nguyên, nó có thể là gấp đôi, nó có thể là bất cứ thứ gì,

00:01:45.780 --> 00:01:49.970
và tất cả chúng thực sự chia sẻ cùng một logic, chúng chia sẻ cùng một logic,

00:01:50.310 --> 00:01:56.700
Vì vậy, thay vì người dùng tự thực hiện sao chép-dán, trình biên dịch sẽ thực hiện sao chép-dán bằng cách

00:01:56.700 --> 00:01:57.180
bản thân anh ấy.

00:01:57.600 --> 00:02:01.560
Ví dụ, hãy xem ở đây, MayMax hai và năm,

00:02:01.920 --> 00:02:09.330
vì vậy Memex là một chức năng mong đợi một loại dữ liệu chung từ mẫu từ,

00:02:09.870 --> 00:02:12.720
bạn có thể nghĩ về
nó như một hướng dẫn

00:02:12.720 --> 00:02:14.070
chung, nó không phải
là một cái gì đó cụ thể,

00:02:14.070 --> 00:02:15.870
nó sẽ không tồn tại trong mã cuối cùng của chúng tôi,

00:02:16.170 --> 00:02:17.860
nó chỉ là một cách để hỗ trợ một mã
chung, khi chúng tôi nói một mã chung,

00:02:17.880 --> 00:02:25.350
chúng tôi muốn nói rằng nó là một thứ
tốt hoạt động giống như nói chung, bất kể

00:02:25.350 --> 00:02:27.240
của các chi tiết bên trong.

00:02:28.700 --> 00:02:35.000
Vì vậy, ở đây bộ kết hợp thấy tối đa của tôi là
hai và năm và biết rằng đây là hàm mẫu, vì vậy

00:02:35.000 --> 00:02:39.250
bây giờ tôi đang nói ở đây, này, bạn biết chúng
ta có thể gọi hàm này là gì với hai và năm không.

00:02:39.680 --> 00:02:46.460
Vì vậy, bây giờ chúng tôi nhập vào thực tế trong thời gian chạy sẽ được phân giải thành số nguyên và số nguyên,

00:02:46.760 --> 00:02:51.740
Bây giờ, bạn có thể hình dung
chính xác hàm này trong thời gian

00:02:51.740 --> 00:02:52.370
chạy như hàm này với hai tích
phân và trả về một số nguyên.

00:02:55.340 --> 00:03:02.030
OK, vậy nếu tôi muốn buộc các loại trường hợp khác thì sao?

00:03:02.450 --> 00:03:05.750
C++ cho phép bạn sử dụng ký
hiệu này, nếu bạn đã làm ở đây &lt;

00:03:05.750 --> 00:03:13.670
từ int, &gt;, bạn đang nói với trình
biên dịch, này, tôi muốn bạn

00:03:14.150 --> 00:03:16.870
chuẩn bị cho tôi chức năng này, nhưng sử dụng int,

00:03:17.210 --> 00:03:21.470
vì vậy nó sẽ thay thế loại này bằng int và loại này bằng int và loại này bằng int và loại này bằng int,

00:03:21.860 --> 00:03:24.030
bây giờ chúng tôi đang gửi tối đa từ hai đến năm,

00:03:24.320 --> 00:03:25.680
nó lại đây, năm.

00:03:25.940 --> 00:03:31.500
Vì vậy, sự khác biệt giữa dòng chín 15 và dòng 16 là gì?  ở dòng 15 bạn đang sử dụng hai số nguyên,

00:03:31.760 --> 00:03:34.670
vì vậy trình biên dịch đoán rằng bạn có thể sẽ không....

00:03:34.820 --> 00:03:40.810
một bản sao của hàm này
với loại là tích phân trong dòng

00:03:40.820 --> 00:03:44.300
17, chúng tôi nói, này, tôi
muốn hàm này có loại gấp đôi,

00:03:44.870 --> 00:03:50.660
vì vậy khi chúng ta nhấn, trình
biên dịch sẽ tạo một bản sao cho

00:03:50.660 --> 00:03:53.630
bạn với từ đó, kiểu được thay
thế bằng double, double và double,

00:03:54.140 --> 00:03:56.480
vì vậy đạo đức của điều đó như sau,

00:03:56.930 --> 00:04:03.260
thay vì bạn đang tự mình thực hiện sao chép-dán và giữ số nguyên, số nguyên, số nguyên, gấp đôi

00:04:03.260 --> 00:04:08.160
nhân đôi, nhân đôi, ký tự, ký tự, ký tự, trình biên dịch sẽ thực hiện việc sao chép-dán cho bạn,

00:04:08.540 --> 00:04:10.550
vậy thực ra là đang trong thời gian
thi đấu, điều này đang xảy ra với

00:04:10.730 --> 00:04:18.170
các bạn ở dòng 18 đang định nghĩa
Memex hoặc giữa ký tự E và ký tự

00:04:18.170 --> 00:04:18.560
x..

00:04:18.890 --> 00:04:24.530
Vì vậy, trong thực tế, loại ký tự sẽ được thay thế bằng một ký tự, ký tự và ký tự.

00:04:26.210 --> 00:04:27.510
OK, chúng ta hãy tiếp tục đi nhiều hơn nữa.

00:04:28.070 --> 00:04:35.080
Điều gì sẽ xảy ra nếu tôi nói ở đây và với bất kỳ memex
nào của hai và năm điểm bốn, điều này sẽ gây ra lỗi

00:04:35.270 --> 00:04:41.000
biên dịch y vì trình biên dịch hiện nhìn thấy một số
nguyên ở đây và nhân đôi nó sẽ bị nhầm lẫn nếu chúng tạo ra

00:04:41.000 --> 00:04:44.090
cho bạn hàm với loại là số nguyên hoặc loại là gấp đôi.

00:04:44.150 --> 00:04:50.660
Điều này gây nhầm lẫn vì vậy nó sẽ không hoạt động khi phía bên kia tôi có thể tạo hàm với số nguyên.

00:04:50.660 --> 00:04:52.030
Tôi ở đây cụ thể hơn.

00:04:52.580 --> 00:04:53.890
Bây giờ hãy nghĩ về điều đó.

00:04:54.470 --> 00:04:59.420
Hãy tưởng tượng rằng chúng ta
có một hàm với tính toàn vẹn của

00:04:59.420 --> 00:05:00.140
số nguyên hoặc nếu bạn đang
gửi hai đến tám, thì nó sẽ là hai.

00:05:00.260 --> 00:05:04.510
Nếu bạn đang gửi năm phẩy bốn đến B, không phải là số nguyên, thì nó sẽ là năm.

00:05:04.760 --> 00:05:08.210
Vì vậy, Mexia giữa hai và năm phẩy bốn sẽ là năm.

00:05:08.210 --> 00:05:11.020
Đó là năm phẩy bốn ở phía bên kia.

00:05:11.180 --> 00:05:17.360
Nếu tôi nói với anh ấy, này, bạn tạo một bản sao cho tôi là từ, loại được thay thế bằng mà tôi gấp đôi

00:05:17.780 --> 00:05:23.260
nó sẽ là 2 phẩy 5, 4 sẽ là 5 đối với một người phức tạp hơn.

00:05:23.510 --> 00:05:30.620
Điều gì sẽ xảy ra nếu tôi có một cấu trúc được đặt tên là E và B và tôi đã nói mức tối đa của mình giữa A và B thuộc loại Embley,

00:05:30.950 --> 00:05:32.510
điều này sẽ tạo ra một lỗi thành phần.

00:05:32.870 --> 00:05:37.010
Chúng tôi không biết làm thế nào để so sánh với Embley đang sử dụng cái lớn hơn.

00:05:37.250 --> 00:05:41.870
Vì vậy, nó sẽ cho bạn biết, này, tôi không biết cách thực hiện thao tác này nếu tôi cố tạo một bản sao của chức năng này.

00:05:42.260 --> 00:05:46.460
Vì vậy, để hiểu nó, hãy tưởng
tượng rằng chúng ta lấy chức năng

00:05:46.460 --> 00:05:47.480
này có thể được xây dựng và
thay thế mọi lúc bằng từ hoàn thành.

00:05:47.840 --> 00:05:49.820
Trình biên dịch có thể kết hợp điều này không.

00:05:50.060 --> 00:05:50.810
Không, nó không thể.

00:05:53.360 --> 00:05:59.080
Vì vậy, việc tạo các loại hàm memex khác nhau sẽ được tạo theo thời gian.

00:05:59.420 --> 00:06:07.370
OK, vì vậy đối với các trường hợp sử dụng mà ví
dụ: nếu bạn có thể sử dụng the trong trường hợp

00:06:07.370 --> 00:06:09.400
trước của chúng tôi, chúng tôi có một số nguyên và
chúng tôi có một số kép và chúng tôi có một ký tự.

00:06:09.590 --> 00:06:11.210
Vì vậy, có ba trường hợp sử dụng ở đây.

00:06:11.390 --> 00:06:14.720
Chức năng này sẽ được thay thế bằng ba chức năng.

00:06:14.900 --> 00:06:20.180
Một ý định n tối đa, nhân đôi, nhân đôi, nhân đôi nhân vật, nhân vật, nhân vật của tôi.

00:06:20.900 --> 00:06:22.400
Một quan sát khác ở đây.

00:06:22.400 --> 00:06:24.260
Tôi đã không sử dụng tên hàm là Max.

00:06:24.260 --> 00:06:25.310
Tôi sử dụng nó như Max của tôi.

00:06:25.310 --> 00:06:25.670
Tại sao?

00:06:25.910 --> 00:06:29.210
Bởi vì C++ đã định nghĩa hàm max làm mẫu.

00:06:29.390 --> 00:06:31.670
Vì vậy, bây giờ tôi đang xác định một cái gì đó chính xác như nó đang làm.

00:06:31.670 --> 00:06:33.770
Vì vậy, đây là những gì sẽ cung cấp cho một cuộc thi.

00:06:34.370 --> 00:06:39.800
Vui lòng thử thay thế chức năng bằng Max và xem điều gì sẽ xảy ra trong thực tế.

00:06:41.030 --> 00:06:47.990
Nó đôi khi thực sự rất khó và thực sự phức tạp, nhưng điều tồi tệ nhất là sai sót.

00:06:47.990 --> 00:06:52.070
Thông báo của các mẫu thường rất khó hiểu và khó hiểu.

00:06:52.430 --> 00:06:55.490
Cố gắng tạo ra những sai lầm và xem một số thông báo này.

00:06:56.960 --> 00:06:58.520
Hãy tiến thêm một bước nữa.

00:06:59.510 --> 00:07:06.650
Chúng tôi có hàm sao cho chúng tôi mong
muốn tham số đầu tiên thuộc loại và tham

00:07:06.650 --> 00:07:12.770
số thứ hai thuộc loại khác và sẽ trả về
một thứ thuộc loại của hàm đầu tiên, ví dụ:

00:07:12.920 --> 00:07:13.800
của chức năng này.

00:07:13.800 --> 00:07:18.770
Lấy một số nguyên ở đây và
nhân đôi ở đây sẽ thực hiện nhiệm

00:07:18.770 --> 00:07:19.640
vụ như vậy và trả về kết quả
là R, đây sẽ là loại số nguyên.

00:07:19.910 --> 00:07:21.290
Hãy xem các ví dụ ở đây.

00:07:22.190 --> 00:07:23.390
Mô hình của ví dụ này.

00:07:23.390 --> 00:07:25.940
Bạn có thể định nghĩa nhiều hơn một biến.

00:07:26.120 --> 00:07:27.620
Chúng tôi nói ở đây mẫu đó.

00:07:27.730 --> 00:07:33.060
Một người bắt gặp hai cái
đó với cái thứ hai có tính hữu

00:07:33.070 --> 00:07:33.430
hạn là tên loại và bây giờ
là một lớp, điều gì khác biệt?

00:07:33.460 --> 00:07:33.790
Không.

00:07:33.790 --> 00:07:35.330
Tôi chỉ cho bạn thấy thêm Sirtex.

00:07:35.530 --> 00:07:37.990
Bạn có thể sử dụng lớp và bạn có thể sử dụng từ để nhập tên.

00:07:38.450 --> 00:07:43.400
Tôi ở đây nói rằng chức năng mẫu này có thể nhận được hai loại khác nhau.

00:07:43.720 --> 00:07:45.780
Vì vậy, ở đây tôi đang nói một số một trong 10.

00:07:46.300 --> 00:07:52.270
Và điều này sẽ được đoán rằng trình
biên dịch sẽ biết rằng loại một là số

00:07:52.270 --> 00:07:54.520
nguyên và loại 10, loại hai chỉ là
những gì một số trong số chúng là 11.

00:07:55.390 --> 00:07:59.290
Mặt khác, tôi đang gửi ở đây một và sau đó là Tenebrae năm.

00:07:59.590 --> 00:08:03.320
Vì vậy, loại một sẽ là số nguyên, loại hai sẽ được xây dựng sẽ là gấp đôi.

00:08:03.850 --> 00:08:08.130
Bây giờ, khi bạn thêm một điểm mười cuối cùng vào năm, nó sẽ là mười một điểm năm.

00:08:08.440 --> 00:08:12.480
Nhưng chờ đã, kết quả trả về ở đây thuộc loại một, là số nguyên.

00:08:12.730 --> 00:08:15.610
Vì vậy, chúng tôi đang trả về mười một điểm năm dưới dạng số nguyên.

00:08:15.790 --> 00:08:18.490
Kết quả sẽ là số nguyên ở phía bên kia.

00:08:18.490 --> 00:08:21.610
Nếu tôi đặt cả hai dưới dạng gấp đôi, thì chúng sẽ là một số trả lại như.

00:08:22.780 --> 00:08:27.490
Bây giờ ở đây nếu tôi, tôi đã nói rằng cái đầu tiên là gấp đôi và cái thứ hai là số nguyên.

00:08:27.970 --> 00:08:31.720
Vì vậy, bây giờ đệ trình sẽ là mười một điểm hai và chúng tôi trả về gấp đôi.

00:08:31.730 --> 00:08:37.690
Vì vậy, để trả lại nó như một
cách khác với nó cho cùng một lệnh

00:08:37.690 --> 00:08:39.060
gọi, tôi đã nói, này, bạn biết
không, tôi sẽ biết bạn lần đầu tiên.

00:08:39.160 --> 00:08:41.690
Đầu tiên, loại là số nguyên và loại thứ hai là số nguyên.

00:08:42.100 --> 00:08:43.690
Bây giờ một điểm để làm là tốn kém.

00:08:43.690 --> 00:08:44.510
Để tích hợp.

00:08:44.530 --> 00:08:46.570
Để trở thành một trong một blastin là 11.

00:08:46.570 --> 00:08:48.790
Aldy Nó vui hơn.

00:08:48.790 --> 00:08:57.220
Cú pháp Nếu bạn nói nếu bạn gửi một và tám sẽ là một ký tự và B sẽ là một ký tự.

00:08:57.430 --> 00:08:59.470
Vì vậy, trình của họ là sáu mươi sáu.

00:08:59.830 --> 00:09:03.360
Nếu bạn quay lại đây từ cái này thì sẽ rất tốn kém cho tính cách.

00:09:03.790 --> 00:09:10.450
Vì vậy, nó sẽ trả về biến, ký tự
B nhưng nếu bạn đã làm một và

00:09:10.450 --> 00:09:15.310
tám thì biến đó sẽ là số nguyên
và E sẽ là, bạn sẽ là một ký tự.

00:09:15.490 --> 00:09:20.100
Bạn tính tổng chúng, nó sẽ là sáu mươi sáu nhưng bạn trả về số nguyên nên nó sẽ là sáu mươi sáu.

00:09:21.370 --> 00:09:27.820
OK, chức năng này là Bloss và hãy nhớ rằng
chuỗi giclas chúng ta có thể nối chuỗi nếu tôi

00:09:27.820 --> 00:09:32.740
có chuỗi Mustafa và chuỗi ra và tôi có thể
nối chúng, tôi có thể nối chúng để không phải

00:09:32.740 --> 00:09:33.730
làm việc trên tất cả các số nguyên.

00:09:33.940 --> 00:09:35.050
Vì vậy, phù hợp với bất kỳ.

00:09:35.290 --> 00:09:39.560
Tôi đang thấy một số chuỗi không gian ayam với nội dung chuỗi.

00:09:39.970 --> 00:09:45.430
Câu hỏi ở đây, hàm có thể
không, trình biên dịch có thể

00:09:45.430 --> 00:09:46.060
lấy một bản sao của hàm
này và tạo ra hai chuỗi không.

00:09:46.310 --> 00:09:47.380
Câu trả lời là có.

00:09:47.530 --> 00:09:48.930
Vì vậy, nó sẽ thêm chúng vào bản in.

00:09:48.940 --> 00:09:49.700
Tôi là quả cầu vũ trụ.

00:09:49.720 --> 00:09:52.550
Những thứ như 19 sẽ đến đó.

00:09:52.900 --> 00:09:57.940
Sự khác biệt giữa dòng mười chín được căn
chỉnh với bất kỳ dòng mười chín nào ở đây

00:09:57.940 --> 00:10:00.180
được sử dụng là sử dụng một con trỏ ký tự,
nhưng dòng này đang sử dụng một mệnh đề.

00:10:00.220 --> 00:10:04.110
Câu hỏi ở đây là một mảng ký tự cộng được xác định?

00:10:04.480 --> 00:10:07.260
Câu trả lời là không chỉ được xác định trên một chuỗi mệnh đề.

00:10:07.270 --> 00:10:08.890
Chúng ta sẽ biết thêm về điều đó trong tương lai.

00:10:10.900 --> 00:10:12.520
Biến tĩnh.

00:10:12.770 --> 00:10:18.760
Một điều thú vị ở đây, nếu bạn định nghĩa
một biến tĩnh bên trong hàm mẫu, thì mọi

00:10:18.800 --> 00:10:28.570
hàm Turnblad sẽ có biến tĩnh y bởi vì nó nếu
chúng ta có số gia của bạn đối với tôi là

00:10:28.570 --> 00:10:33.550
số nguyên và số gia tăng, chúng tôi muốn bạn
hiểu rằng trên thực tế, trình biên dịch sẽ nhận

00:10:33.550 --> 00:10:39.570
chức năng này, tạo hai bản sao từ nó, một bản
sao cho số nguyên, một bản sao cho số kép.

00:10:39.760 --> 00:10:45.790
Vì vậy, trong thực tế, có một tôi tích phân tôn giáo và một tập tích phân I khác với phiên bản kép.

00:10:46.120 --> 00:10:51.580
Vì vậy, nếu bạn đã thử ở đây để tạo
một mục tiêu tĩnh và đây là một biến toàn

00:10:51.580 --> 00:10:53.170
cục, thì các mục tiêu tĩnh sẽ là một,
hai, ba và một lần nữa, một, hai, ba.

00:10:53.380 --> 00:10:55.480
Nhưng toàn cầu sẽ được tăng lên.

00:10:57.100 --> 00:10:59.020
OK, một điều nữa.

00:10:59.170 --> 00:11:02.410
Cái mà chúng tôi gọi là chức năng chuyên môn hóa Turnblad.

00:11:03.100 --> 00:11:09.850
Câu hỏi ở đây là nếu tôi muốn
chức năng hoạt động giống

00:11:09.850 --> 00:11:10.890
nhau cho mọi loại ngoại
trừ loại dữ liệu cụ thể thì sao?

00:11:11.230 --> 00:11:13.120
Hãy lấy một ví dụ ở đây.

00:11:13.420 --> 00:11:15.130
Hãy nghĩ về hàm ADD.

00:11:15.130 --> 00:11:18.400
Nếu tôi cộng ở đây, nó phải giống như tổng mà chúng ta vừa làm.

00:11:18.760 --> 00:11:20.260
Nó hoạt động tốt cho số nguyên.

00:11:20.260 --> 00:11:21.320
Nó hoạt động tốt cho một số.

00:11:21.340 --> 00:11:22.180
Mọi người đều hạnh phúc.

00:11:22.630 --> 00:11:27.880
Bây giờ hãy nghĩ về hàm nhân Tôi có ở đây hàm nhân nhân lên.

00:11:28.960 --> 00:11:30.970
Cái đầu tiên là một số nguyên.

00:11:30.970 --> 00:11:35.800
Vì vậy, chúng tôi đang gửi nơi chúng tôi chỉ muốn một loại D và chúng tôi có một yếu tố.

00:11:36.190 --> 00:11:40.030
Điều này sẽ bằng với số nguyên sẽ là gấp đôi được thu thập mọi thứ.

00:11:40.300 --> 00:11:43.200
Nhưng nó sẽ thất bại bốn ký tự đối với Estrich.

00:11:43.540 --> 00:11:48.790
Giả sử tôi muốn đăng ký Estrich
theo một cách cụ thể và chúng

00:11:48.790 --> 00:11:50.260
tôi biết rằng hàng hóa này sẽ
kết hợp nếu nó chỉ là một chuỗi.

00:11:50.680 --> 00:11:55.620
Vì vậy, cách để làm điều đó là
nói, này, bạn biết không, tôi muốn

00:11:55.630 --> 00:11:58.120
phép nhân này áp dụng cho
mọi loại nhỏ ngoại trừ loại cụ thể.

00:11:58.600 --> 00:12:01.510
Vì vậy, cú pháp để chỉ định một cái gì đó như sau.

00:12:01.930 --> 00:12:07.210
Bạn viết từ mẫu, nhưng bạn viết tại một thời
điểm ở đây và sau đó bạn viết hàm di chúc

00:12:07.210 --> 00:12:11.480
của mình giống như bạn viết nó trong trường
hợp bình thường, đó là hàm sẽ nhân một chuỗi.

00:12:11.480 --> 00:12:13.630
Vâng, đã có một số yếu tố và trở lại chuỗi.

00:12:14.050 --> 00:12:15.070
Điều này cũng giống như điều đó.

00:12:15.070 --> 00:12:16.840
Nhưng chúng tôi chỉ nghĩ mọi thứ là một chuỗi.

00:12:17.110 --> 00:12:21.400
Tôi đang ngồi đây, bạn biết không, đối với trường hợp chuỗi, tôi sẽ xử lý nó theo một cách khác,

00:12:21.970 --> 00:12:23.110
đó là tiết niệu.

00:12:23.470 --> 00:12:27.570
Và tôi đoán ở đây, tôi đã lặp lại số lượng các yếu tố và nối ở đó.

00:12:28.040 --> 00:12:32.990
Cho từ Mustafa ba lần, nó
sẽ làm vợ lẽ Mustafa ba lần,

00:12:32.990 --> 00:12:33.350
đây là logic phiên bản
của tôi, người ta có thể nói.

00:12:33.350 --> 00:12:33.860
Bạn biết gì?

00:12:33.860 --> 00:12:35.870
Tôi cũng muốn có một logic cụ thể cho David.

00:12:36.110 --> 00:12:39.980
Sau đó, anh ấy sẽ nhân đôi nhân đôi, nhân đôi một cái gì đó và thừa số.

00:12:40.460 --> 00:12:46.370
Vì vậy, đạo đức của điều đó là nếu trong trường
hợp bạn muốn có một cuộc giao bóng cụ thể cho một

00:12:46.370 --> 00:12:52.220
loại dữ liệu cụ thể, thì bạn sẽ sử dụng chuyên môn
hóa mẫu theo nghĩa mà chúng tôi có thể nghe thấy.

00:12:52.220 --> 00:12:57.950
Thông thường, bạn chỉ cần tiếp
tục gọi phép cộng và phép nhân theo

00:12:57.950 --> 00:12:58.550
cách bình thường ở đây trong phần
cộng, trong phần bên trong và chuỗi.

00:12:58.610 --> 00:13:02.150
Cái này sẽ tốt ở đây trong nội thất, cái này sẽ rất tuyệt.

00:13:02.300 --> 00:13:04.910
Nhưng cái này ở đây trong chuỗi, cái này sẽ tốt.

00:13:05.690 --> 00:13:06.230
Đó là nó.