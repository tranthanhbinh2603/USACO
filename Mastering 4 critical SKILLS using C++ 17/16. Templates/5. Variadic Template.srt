0
1
00:00:01,170 --> 00:00:07,890
The variadic template is one of the very nice features of C++. Let's motivate that. So far in our functions,
1

2
00:00:07,890 --> 00:00:10,760
We typically used a fixed number of parameters.
2

3
00:00:10,770 --> 00:00:16,050
For example, If you have a function like sum, it's receiving, It has two parameters A and B, So it's
3

4
00:00:16,050 --> 00:00:19,880
just maximum receiving two arguments, One value for A and one value for B.
4

5
00:00:20,610 --> 00:00:25,950
Now, What if I would like to go something like 2, 5, 6, 7, 9, Which is passing five arguments.
5

6
00:00:26,310 --> 00:00:30,420
This would not work. In modern C++,
6

7
00:00:30,570 --> 00:00:38,790
We can use at least two mechanisms to allow a variable number of arguments and we can use the initializer
7

8
00:00:38,790 --> 00:00:39,870
list in C++,
8

9
00:00:39,870 --> 00:00:46,470
but our two cases are more about today, The C++11 variadic template, Which typically needs a couple of functions to be
9

10
00:00:46,470 --> 00:00:53,820
implemented. In C++ 17, There is a simpler mechanism named fold expression, Which is simpler
10

11
00:00:53,820 --> 00:01:00,360
for a specific 32 binary operators as we will you know in the next sessions. Let's motivate this more.
11

12
00:01:00,840 --> 00:01:04,290
The word variadic is common in several programming languages.
12

13
00:01:04,530 --> 00:01:11,690
It mainly when we say the parameter is a variadic parameter, It means it accepts zero or more values.
13

14
00:01:12,210 --> 00:01:18,180
So typically, If the function has one of these parameters, It typically has at most one of the parameters
14

15
00:01:18,180 --> 00:01:21,570
that are variadic and typically its the right most parameter.
15

16
00:01:21,960 --> 00:01:28,500
You will always note as using these three periods (...), Which is the ellipsis syntax to indicate that this
16

17
00:01:28,500 --> 00:01:35,850
is a variadic parameter and again a variadic parameter this time is expecting a single value like with it.
17

18
00:01:35,850 --> 00:01:43,620
It's accepting zero or more values. Before C++ 11, There was also what's named in C++ as variadic
18

19
00:01:43,650 --> 00:01:44,190
functions 
19

20
00:01:44,370 --> 00:01:47,490
and they are functions that take a variable number of arguments.
20

21
00:01:47,820 --> 00:01:49,260
The printf function,
21

22
00:01:49,260 --> 00:01:52,620
If you tried to open its syntax, You will notice these three dots.
22

23
00:01:52,980 --> 00:01:54,880
It's a old style and it is unsafe.
23

24
00:01:55,320 --> 00:02:00,860
Now, the variadic template is a new thing in C++ 11,  modern and safe way to do that.
24

25
00:02:02,340 --> 00:02:04,250
Let's get a little about the basics of it.
25

26
00:02:04,650 --> 00:02:08,850
So here is we are defining a function named hello.
26

27
00:02:09,300 --> 00:02:15,900
It has here something called some args, some name for us and have also a name here args and it has
27

28
00:02:15,900 --> 00:02:16,650
three dots.
28

29
00:02:17,070 --> 00:02:23,790
If you try to inspect some args, You will notice it's a template type but it also has here this prefix
29

30
00:02:23,790 --> 00:02:28,590
of three dots. This some args we call it a template parameter pack.
30

31
00:02:29,310 --> 00:02:35,460
I think of it like a bunch of things together and this is not a data type, It is a template parameter
31

32
00:02:35,460 --> 00:02:41,230
pack, Pack of a bunch of values, And the args itself is what we call a function parameter
32

33
00:02:41,280 --> 00:02:45,450
pack. Now, When you try to call, let's go here to the main.
33

34
00:02:45,960 --> 00:02:53,970
If you tried to call the function hello with four arguments, 1, 2, 3, 4 am, I'm here using
34

35
00:02:53,970 --> 00:02:57,570
the size of operator size of also dot, dot, dot.
35

36
00:02:57,780 --> 00:03:01,040
args, it is going to show you that the size is four.
36

37
00:03:01,380 --> 00:03:06,480
It means that this variadic argument received four different values.
37

38
00:03:06,870 --> 00:03:12,690
If you pass hello, Mustafa, 5, 2.5, Which are three arguments and of different
38

39
00:03:12,690 --> 00:03:16,260
data types, You will notice that this size is three.
39

40
00:03:16,560 --> 00:03:20,850
If you passed the c character single character, It will be the size of one.
40

41
00:03:21,000 --> 00:03:24,120
If you passed something that is very empty, it will be zero.
41

42
00:03:24,570 --> 00:03:30,180
I'm using here something called pretty function which is printing a fine name for this function.
42

43
00:03:30,540 --> 00:03:31,980
I do not think this is redundant.
43

44
00:03:31,980 --> 00:03:33,270
It is more of the GCC.
44

45
00:03:33,300 --> 00:03:36,660
If you are using the Microsoft visual compiler, It will not probably work.
45

46
00:03:36,870 --> 00:03:41,940
So you see here, In this case, It's showing you that the arguments that we received are four integers
46

47
00:03:42,270 --> 00:03:42,560
here
47

48
00:03:42,570 --> 00:03:45,490
arguments that we received are character pointer, an integer
48

49
00:03:45,510 --> 00:03:53,340
and double. So again going back to this new syntax style that we call the parameter pack, This guy
49

50
00:03:53,580 --> 00:04:02,220
is expecting zero like here or more arguments and they are all stored in this args thing and throw its size
50

51
00:04:02,220 --> 00:04:05,640
If you can know about the number of arguments that we received.
51

52
00:04:06,840 --> 00:04:13,050
Please make sure that your eyes are very familiar with this new syntax and this use of three
52

53
00:04:13,050 --> 00:04:13,380
dots.
53

54
00:04:13,620 --> 00:04:18,840
So one more time, The sum args here is a template parameter pack, It's an indicator that we are
54

55
00:04:18,840 --> 00:04:24,000
going to receive a bunch of items together and in a very flexible way.
55

56
00:04:25,850 --> 00:04:32,350
Let's go one more step to indicate something, I am here having a function, It has two normal parameters
56

57
00:04:32,360 --> 00:04:34,250
integer A and a string name.
57

58
00:04:34,550 --> 00:04:41,840
And you see it has here the template parameter pack on the most right parameter.
58

59
00:04:42,040 --> 00:04:43,950
OK!, Then when you call here,
59

60
00:04:43,970 --> 00:04:44,870
Hello, one,
60

61
00:04:44,870 --> 00:04:48,590
and belal, the value one is matching A so A is one.
61

62
00:04:49,010 --> 00:04:53,570
The value belal is matching the name and then there is nothing to send it to args.
62

63
00:04:53,570 --> 00:04:55,380
So the size of args here is zero.
63

64
00:04:55,850 --> 00:05:02,420
In another case, If you are sending one, belal, 2.5, 1 is with A, belal is with name and the
64

65
00:05:02,420 --> 00:05:04,610
args is 2.5 only,
65

66
00:05:04,610 --> 00:05:06,830
So the size is one, Here the size would be two.
66

67
00:05:07,130 --> 00:05:13,520
That's why you typically have at most one parameter Pack and you typically have it in the most right
67

68
00:05:13,520 --> 00:05:14,060
parameter.
68

69
00:05:16,190 --> 00:05:19,040
Now, let's send this.
69

70
00:05:19,250 --> 00:05:20,290
We have a function
70

71
00:05:20,300 --> 00:05:26,480
that takes a single integer and the remaining of the args, If you sent from 1 to 5, A is 1 and the
71

72
00:05:26,480 --> 00:05:28,580
remaining of 2, 3, 4, 5 is with args.
72

73
00:05:29,000 --> 00:05:31,880
If you sent 2, 3, 4, 5, A is 2,
73

74
00:05:32,090 --> 00:05:37,010
and the remaining 3, 4, 5, if you sent 3, 4, 5, A is 3 and the args is 4,
74

75
00:05:37,010 --> 00:05:43,430
5. If you understood this logic, You can think for a while about how we could really make use of this
75

76
00:05:43,430 --> 00:05:45,370
args because we cannot print it directly.
76

77
00:05:45,590 --> 00:05:47,030
How can we make use of it?
77

78
00:05:47,480 --> 00:05:54,830
It seems like we need to use some, some recursive style to be able to use the args, This is something like we
78

79
00:05:54,830 --> 00:06:01,010
pass 1 to here and then the args are from 2 to 5, Then we pass args again to the function, then 2
79

80
00:06:01,010 --> 00:06:01,880
is A and so on.
80

81
00:06:02,840 --> 00:06:07,460
Let's try to review something about recursion before we proceed more.
81

82
00:06:09,200 --> 00:06:11,150
We did this exercise before.
82

83
00:06:11,150 --> 00:06:15,950
If you have an array of 5 numbers and you would like to sum its values in a recursive way.
83

84
00:06:16,340 --> 00:06:21,800
So one way here I'm sending the sum array and sending the array and the current length, Which is 5.
84

85
00:06:22,280 --> 00:06:25,520
I'm saying if the length is zero, Which is a base case, We are returning zero.
85

86
00:06:25,940 --> 00:06:30,140
Otherwise, I'm taking the last element of the array plus the array
86

87
00:06:30,140 --> 00:06:35,270
but with a length value minus 1. Thinking about that, I hope you understand it.
87

88
00:06:35,270 --> 00:06:41,570
I remember refreshing from the recursion. The array here has a very close relationship with the args, It is
88

89
00:06:41,570 --> 00:06:47,250
very dynamic but we have explicitly the length. We would like to do something like that with the variadic
89

90
00:06:47,250 --> 00:06:50,570
template to be able to use it to do operations for us.
90

91
00:06:51,110 --> 00:06:56,150
So here we would like to define a function sum that take a variable number of arguments and return
91

92
00:06:56,150 --> 00:06:56,690
to the sum.
92

93
00:06:57,200 --> 00:06:59,150
So sum 1, 2, 3, 4 is returning
93

94
00:06:59,150 --> 00:07:01,570
3, 4, 7, 9, 10.
94

95
00:07:02,240 --> 00:07:03,500
So here what's going to happen.
95

96
00:07:04,100 --> 00:07:06,200
We are calling sum from 1 to 4.
96

97
00:07:06,350 --> 00:07:13,010
The function is going to take A with 1 and the args is going to be the remaining, which is 2,
97

98
00:07:13,010 --> 00:07:13,540
3, 4.
98

99
00:07:14,030 --> 00:07:20,360
Now, I would like to make a bigger sum, so I'm going to recursively call the function sum with the
99

100
00:07:20,360 --> 00:07:22,570
remaining args, which are now 2, 3, 4.
100

101
00:07:22,580 --> 00:07:28,490
So we are calling sum 2, 3, 4. Again, 2 would be assigned to the value of A and args
101

102
00:07:28,490 --> 00:07:35,390
would have the value of 3 and 4. we are adding the value of 2 plus the return from sending these
102

103
00:07:35,390 --> 00:07:36,620
two values only 3, 4.
103

104
00:07:36,920 --> 00:07:41,840
So again, 3 would be A and the answer would be 4, Recursively call with 4.
104

105
00:07:41,990 --> 00:07:45,740
So 4 is going to be A and args is going to be empty.
105

106
00:07:46,190 --> 00:07:51,440
Now, When you call sum with empty, This function is expecting a single integer at least.
106

107
00:07:51,650 --> 00:07:53,240
So this would be a compilation error.
107

108
00:07:53,510 --> 00:07:55,670
That's why we have a base case function
108

109
00:07:55,670 --> 00:07:56,990
for us that has nothing.
109

110
00:07:58,900 --> 00:08:04,270
If you tried to inspect the values, It's kind of generated like 1 plus 2 plus the return from here
110

111
00:08:04,540 --> 00:08:10,070
3, 4. As if we are expanding from the right to the one in the right.  
111

112
00:08:10,090 --> 00:08:13,900
This recursion here is more of the left side, But here we are expanding more in the right direction.
112

113
00:08:14,590 --> 00:08:17,170
The variadic template is typically two functions.
113

114
00:08:17,440 --> 00:08:24,670
One of them, The your function with an args parameter and another without the args parameter to be
114

115
00:08:24,670 --> 00:08:26,070
able to use it recursively,
115

116
00:08:26,200 --> 00:08:29,440
and we typically code the variadic template in a recursive way.
116

117
00:08:31,600 --> 00:08:35,680
Now let's try to make our function more generic.
117

118
00:08:35,680 --> 00:08:38,160
So we are going to use a another kind of templates here.
118

119
00:08:38,440 --> 00:08:40,270
We are going to template the variable a.
119

120
00:08:40,420 --> 00:08:48,230
So A will be of type T now and this function now  need to call this sum function here but we will
120

121
00:08:48,700 --> 00:08:52,290
at some point, we are going to call the base class here,
121

122
00:08:52,690 --> 00:08:59,320
So we need to cast the function here using the template parameter, We need to instantiate something using based
122

123
00:08:59,320 --> 00:09:02,830
on the used T. That's why you are adding T here.
123

124
00:09:03,100 --> 00:09:08,890
So this sum is taking variable type a and then some of T is recursively calling this guy, this
124

125
00:09:08,890 --> 00:09:11,110
guy, Then calling the base case with some of T.
125

126
00:09:11,770 --> 00:09:12,850
Now let's use it here.
126

127
00:09:12,850 --> 00:09:13,810
It's small generic now.
127

128
00:09:13,990 --> 00:09:14,770
1, 2, 3, 4,
128

129
00:09:14,780 --> 00:09:17,020
give us 10,  Bunch of double numbers 
129

130
00:09:17,020 --> 00:09:19,210
give 2.6. Notice here,
130

131
00:09:19,900 --> 00:09:23,280
I removed this 0.2 , and shifted it here to the 4.
131

132
00:09:23,290 --> 00:09:27,280
So the submission should be again 10.6 but it is just 10.
132

133
00:09:27,970 --> 00:09:29,650
Stop the video for one minute and think while.
133

134
00:09:31,420 --> 00:09:37,600
The reason is when we send the function sum with this bunch of numbers, The first number is an integer.
134

135
00:09:37,930 --> 00:09:40,060
So the template T here will be an integer.
135

136
00:09:40,420 --> 00:09:43,210
The consecutive calls here would be of type integer.
136

137
00:09:43,210 --> 00:09:44,620
That's why it's going to be an integer
137

138
00:09:44,920 --> 00:09:49,510
but if we would like to force it to be all of double, We just instantiated from the beginning of double, So
138

139
00:09:49,510 --> 00:09:53,170
it doesn't have to deduce the type of the first parameter.
139

140
00:09:53,320 --> 00:09:54,820
This how we made it more generic.
140

141
00:09:57,320 --> 00:10:04,280
Let's see how variadic can be very powerful when you not only have a variable number of arguments,
141

142
00:10:04,400 --> 00:10:06,890
You can even have them of different types.
142

143
00:10:07,100 --> 00:10:12,950
So here I am defining a function to print 1, 2, 3, 4, four integers would be printed with
143

144
00:10:12,950 --> 00:10:13,730
comma separated.
144

145
00:10:13,970 --> 00:10:18,970
Here I have another list but with a bunch of different data types.
145

146
00:10:19,580 --> 00:10:22,610
So the idea here, again, I'm defining two functions.
146

147
00:10:22,790 --> 00:10:30,920
One of them is empty and the second one has here the first element to much of the first element and
147

148
00:10:30,930 --> 00:10:32,120
adds to much of the remaining list.
148

149
00:10:32,210 --> 00:10:36,810
Now would like to print it, comma-separated but we don't want to print a comma after the
149

150
00:10:36,840 --> 00:10:38,410
last number.
150

151
00:10:38,690 --> 00:10:42,980
So I'm taking the size of the current list, Which initially would be 3, then 2, then 1
151

152
00:10:43,490 --> 00:10:51,410
and say if this isn't the last element, Print a comma here and then recursively print values.
152

153
00:10:51,500 --> 00:10:56,210
So we are printing the current and then printing the remaining one on the right side.
153

154
00:10:57,200 --> 00:11:02,780
As with any printing function, It doesn't make sense to allow the parameters to be changed.
154

155
00:11:02,780 --> 00:11:06,490
So I'm adding here also const and I'm adding here also
155

156
00:11:06,510 --> 00:11:06,920
const.
156

157
00:11:07,160 --> 00:11:07,990
So far so good
157

158
00:11:07,990 --> 00:11:18,170
end C++11. Now C++ 14 allows even you to get rid of the template parameter pack here, dot, dot, dot args  and you can
158

159
00:11:18,170 --> 00:11:21,610
make it more similar and just use the auto parameter here.
159

160
00:11:22,910 --> 00:11:26,950
That's all about the variadic template, The coding of variadic template
160

161
00:11:27,530 --> 00:11:28,610
is very standard
161

162
00:11:28,610 --> 00:11:30,380
as you see a couple of functions.
162

163
00:11:30,800 --> 00:11:34,790
You typically take the first parameter, then the remaining with recursion, and that's on, Nothing
163

164
00:11:34,790 --> 00:11:35,030
more.
164

165
00:11:35,990 --> 00:11:42,230
Like any template-something, Remember, The templates are generated in the completion time, So the code
165

166
00:11:42,230 --> 00:11:48,920
has some mechanism behind the scene to read your template and then instantiate all the needed examples
166

167
00:11:49,430 --> 00:11:50,410
before you even run.
167

168
00:11:50,630 --> 00:11:53,750
And sadly, You are going to face a bunch of ugly compilation errors,
168

169
00:11:53,750 --> 00:11:56,830
If you have some mistakes, that's it.
