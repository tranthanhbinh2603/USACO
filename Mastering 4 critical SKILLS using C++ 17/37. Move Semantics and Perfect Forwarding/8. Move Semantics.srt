1
00:00:01,050 --> 00:00:06,900
In this video, you will see one of these very strong reasons and use it for the R value differences.

2
00:00:07,970 --> 00:00:13,160
So far, we learned what is an L value, which is mainly something that has an identity, has a name,

3
00:00:13,160 --> 00:00:18,830
for example, and we learned about the P r values, which are temporary, that will be destroyed soon

4
00:00:18,830 --> 00:00:19,440
in the memory.

5
00:00:20,180 --> 00:00:26,540
We knew that 11 year difference binds always to an L value, and our very reference binds always to

6
00:00:26,540 --> 00:00:27,180
our value.

7
00:00:27,950 --> 00:00:33,830
We learned that the Arborio difference avoid us unnecessary copies that might have it in the memory,

8
00:00:33,830 --> 00:00:34,880
which might be very good.

9
00:00:35,540 --> 00:00:40,710
We learned a very important to note that the variable time doesn't equal the value category.

10
00:00:41,450 --> 00:00:43,010
We learned this golden rule.

11
00:00:43,130 --> 00:00:48,140
Every variable name is elder value, regardless of its type.

12
00:00:49,340 --> 00:00:54,510
And also we learned something interesting about overloading functions when there is an R value difference

13
00:00:54,510 --> 00:01:02,750
and provided the R value reference when is provided is Matchett first if provided because it allows

14
00:01:02,750 --> 00:01:04,290
more efficient processing.

15
00:01:05,030 --> 00:01:08,660
Today we'll see one more strong usage for the R value difference.

16
00:01:10,160 --> 00:01:16,060
Recall we talked before the Kobe constructor, something like complete, simply a reference because

17
00:01:16,100 --> 00:01:19,380
there is an optional if a class has pointers.

18
00:01:19,400 --> 00:01:26,090
We said before that the default copy constructor will just copy the pointers and this is a big problem

19
00:01:26,090 --> 00:01:28,580
because it will create a lingering pointer point across.

20
00:01:28,940 --> 00:01:34,930
The first destructor will destroy the data, but the second will try to destroy data that already destroyed.

21
00:01:35,390 --> 00:01:40,930
And we said that the copy constructor is our way to provide a DB copy of the data.

22
00:01:43,040 --> 00:01:47,300
But there is a notice here in in many in many codes.

23
00:01:47,600 --> 00:01:50,870
The copy constructor is actually called a lot of times.

24
00:01:51,230 --> 00:01:52,580
And there are two cases here.

25
00:01:52,730 --> 00:01:55,040
You are either copying from an L.A. value.

26
00:01:56,560 --> 00:02:00,730
Or either coming from and out of value, if you are coming from an early.

27
00:02:01,190 --> 00:02:03,940
There is no way except just copying the data from it.

28
00:02:04,490 --> 00:02:07,380
However, what if you are coming from another value?

29
00:02:07,660 --> 00:02:13,750
We know that this our value data will be destroyed soon in the memory, any way that we can make use

30
00:02:13,750 --> 00:02:16,780
of them to avoid unnecessary copying of data.

31
00:02:17,740 --> 00:02:20,340
This is what more semantic will tell us about.

32
00:02:20,340 --> 00:02:22,420
That's it for an administration.

33
00:02:22,510 --> 00:02:27,790
I have here the middle class, but I switched it from two years to two printers.

34
00:02:28,090 --> 00:02:30,970
Please take a minute to read the whole class here.

35
00:02:32,530 --> 00:02:38,930
I'm showing here the copy constructor, a default constructor and also the set first function.

36
00:02:38,950 --> 00:02:43,180
Notice it's a structure here, a check first for the pointer and we have instructor.

37
00:02:45,970 --> 00:02:48,580
Let's now start to use this class.

38
00:02:48,970 --> 00:02:55,210
I'm creating here a vector V and I started to push my beer line.

39
00:02:55,210 --> 00:02:55,780
Fifty one.

40
00:02:56,200 --> 00:03:02,740
I would like to stop the video for the minute and trace all the Allwood that would come from this single

41
00:03:02,740 --> 00:03:03,100
step.

42
00:03:03,310 --> 00:03:06,280
OK, this is a bit tricky, so would like to think about that.

43
00:03:07,330 --> 00:03:09,890
It is what's going to happen, first of all.

44
00:03:10,090 --> 00:03:14,050
Notice that my beer three and six is a right value.

45
00:03:14,050 --> 00:03:14,730
It is tamburri.

46
00:03:14,740 --> 00:03:22,060
It has no name when you try to create this constructor to integers or we are going to be created from

47
00:03:22,060 --> 00:03:25,340
this set first and second in using the line you enter.

48
00:03:26,680 --> 00:03:32,770
After that, you are calling the function to push back in the vector.

49
00:03:33,310 --> 00:03:37,480
So the vector have to call the copy constructor to Cobbe.

50
00:03:37,810 --> 00:03:40,270
You provided Meyerbeer.

51
00:03:41,510 --> 00:03:44,520
To its internal element in the array.

52
00:03:44,840 --> 00:03:48,110
So this is going to create other two copies in the deed.

53
00:03:48,590 --> 00:03:50,170
Now we have two objects here.

54
00:03:50,450 --> 00:03:56,510
We have the object that we best improve here and we have the object that was Cobbett to it inside the

55
00:03:56,510 --> 00:04:02,750
vector itself in the destruction, we're going to destroy, destroy the first object and then we are

56
00:04:02,750 --> 00:04:04,350
going to destroy their second object.

57
00:04:04,790 --> 00:04:08,750
Overall, there were two copies and there were two deleting.

58
00:04:09,140 --> 00:04:12,940
Now let's see how the semantic might help us to improve this problem.

59
00:04:14,990 --> 00:04:17,190
That is what we call a move constructor.

60
00:04:17,240 --> 00:04:21,650
The idea is very simple, we know that the constructor is something like my beer reference.

61
00:04:21,700 --> 00:04:27,620
But remember, the constructor and the structure and the operators are just functions so we can overload

62
00:04:27,620 --> 00:04:27,890
them.

63
00:04:28,220 --> 00:04:30,490
So now let's provide another constructor.

64
00:04:30,500 --> 00:04:40,340
But this time we'll use the R value reference and end here or reference reference as this is a function

65
00:04:40,350 --> 00:04:40,880
overloading.

66
00:04:40,910 --> 00:04:47,900
Now, if you best tamburri object and r value, the function with the R value reference will be Matchett

67
00:04:47,900 --> 00:04:48,420
first.

68
00:04:48,770 --> 00:04:50,540
So this is so far interesting.

69
00:04:50,550 --> 00:04:52,640
We we call this a constructor.

70
00:04:52,650 --> 00:04:55,370
We will know right now what we, what we call it a constructor.

71
00:04:56,810 --> 00:05:02,660
I would if you would like to take a step and think about yourself, how can we make use of this constructor

72
00:05:02,660 --> 00:05:03,620
to make it more efficient.

73
00:05:03,650 --> 00:05:03,980
Go ahead.

74
00:05:04,220 --> 00:05:10,280
But anyway, I'm going to say right now, we will see how can we avoid the extra creation and Cubby's

75
00:05:10,280 --> 00:05:15,870
for the pointers and data using this our value reference constructor.

76
00:05:16,400 --> 00:05:17,660
The idea is following.

77
00:05:18,270 --> 00:05:25,570
Instead of cabbing the data from the BEA, we know that B will be destroyed soon in the memory.

78
00:05:25,880 --> 00:05:33,700
So the idea is let's remove its appointers to my object and steal them and just not them.

79
00:05:34,460 --> 00:05:42,200
So we are going to do what we are going to take the the pointers in this guy to us just could be the

80
00:05:42,200 --> 00:05:49,250
pointer themselves, not copying the data and then set the pointer internal pointer of this object to

81
00:05:49,250 --> 00:05:49,550
null.

82
00:05:50,090 --> 00:05:51,390
Then what then.

83
00:05:51,410 --> 00:05:52,040
This way.

84
00:05:52,070 --> 00:05:57,110
I took a copy from the whole data but without really copying them it just the reference of them.

85
00:05:57,530 --> 00:06:01,490
And when we said them to null then this guy in the destructor will do nothing.

86
00:06:01,790 --> 00:06:05,540
So this way we skip the akabi and we skip that delete.

87
00:06:06,050 --> 00:06:11,140
However, notice that it now the structure of my beer should be very careful.

88
00:06:11,360 --> 00:06:14,250
You have to check first if something is not pointed or not.

89
00:06:14,840 --> 00:06:16,460
Let's see some code for that.

90
00:06:17,800 --> 00:06:24,070
This is the normal cubicle constructor, 915 in line to any we are providing the overloaded constructor

91
00:06:24,070 --> 00:06:26,750
with the reference reference, which we call a move constructor.

92
00:06:27,460 --> 00:06:31,160
We are going to make exactly two steps to implement the move constructor.

93
00:06:31,630 --> 00:06:35,490
The first step will be the pointer addresses.

94
00:06:35,860 --> 00:06:43,090
So I have a first pointer I'm going to take after the first pointer here and taking the other the second

95
00:06:43,090 --> 00:06:44,020
pointer here.

96
00:06:44,500 --> 00:06:48,720
I now steal the pointer of the other guy.

97
00:06:49,090 --> 00:06:52,680
The second step, I am removing the data from the other guy.

98
00:06:53,230 --> 00:06:57,730
Now, comparing this with the move constructor in the constructor, we actually create a new entity

99
00:06:57,730 --> 00:07:01,960
for this guy and copy the data and create a new entity and could be the data.

100
00:07:02,230 --> 00:07:09,220
But now we are just moving the pointer from here to here and removing the pointer from this guy looking

101
00:07:09,220 --> 00:07:11,080
to the destructor.

102
00:07:11,770 --> 00:07:17,380
The what happened in line 34 is we are checking first if this pointer exist or not.

103
00:07:17,620 --> 00:07:19,770
If not exists, we are going to remove it.

104
00:07:20,530 --> 00:07:24,250
This is now very important because we still the data of this guy.

105
00:07:24,250 --> 00:07:29,470
We don't just want it to go and say, hey, delete first pointer, which, you know, is not worth checking.

106
00:07:29,470 --> 00:07:31,270
First line thirty four.

107
00:07:31,420 --> 00:07:37,660
That's why it is very important before deleting anything to double check if it doesn't exist or not,

108
00:07:38,350 --> 00:07:40,000
I'm adding here an interesting check.

109
00:07:40,000 --> 00:07:46,600
I'm saying if the first pointer is the null and the second pointer is not, please inform us that this

110
00:07:46,600 --> 00:07:49,160
already has been freed somehow, which is typical here.

111
00:07:50,230 --> 00:07:57,160
Let's try to see what's going to happen when we try to use this code like the first time we are basing

112
00:07:57,160 --> 00:08:03,640
the our value here and our value will be created a constructor for it, which will create two integers.

113
00:08:04,240 --> 00:08:12,340
But as now we are basing on our value, the move constructor would be called and there would be no creation

114
00:08:12,340 --> 00:08:13,720
or cabbing for this guy.

115
00:08:14,320 --> 00:08:18,490
So we just still it's a appointers for our Boynton's.

116
00:08:19,450 --> 00:08:26,320
After that, the temperature data will go to be destroyed, but it will notice that it's appointer data

117
00:08:26,320 --> 00:08:34,480
is already null at the point the Ergun and then the original V object here, the object inside the V

118
00:08:34,720 --> 00:08:35,590
will be deleted.

119
00:08:35,890 --> 00:08:40,870
If you noticed, we created only two integers and we removed only to integers.

120
00:08:41,050 --> 00:08:47,440
There is no extra copy for the pointer here due to the date of the pointers and there is no delete for

121
00:08:47,440 --> 00:08:49,870
them on the other side.

122
00:08:49,990 --> 00:08:54,560
If you try to have a B one here and B two from the one, B one is an L value.

123
00:08:54,700 --> 00:08:56,910
So this guy will call the copy constructor.

124
00:08:57,220 --> 00:08:58,690
So this guy is temporary.

125
00:08:58,690 --> 00:09:04,360
It will go the move constructor and this guy will call the copy constructor and this guy will steal

126
00:09:04,360 --> 00:09:13,120
the data instead of doing an actual copy in a very similar way, we can provide the assignment operator

127
00:09:13,750 --> 00:09:14,920
very similar logic.

128
00:09:15,070 --> 00:09:19,810
The right hand side of an assignment operator can be something like B one equals B two, which is an

129
00:09:19,810 --> 00:09:25,810
L value we have to copy anyway, or it can be a temporary value, like B an equal number of something.

130
00:09:26,170 --> 00:09:32,470
So we overload the assignment operator, which will be have higher, higher priority in matching and

131
00:09:32,470 --> 00:09:36,620
we steal the data for us, which is going in a way to be destroyed very soon.

132
00:09:37,360 --> 00:09:40,720
So here is the old assignment operator side.

133
00:09:41,050 --> 00:09:44,410
You check first if it is the same object or not.

134
00:09:44,660 --> 00:09:50,970
If it isn't, you are going to if the other guy is a null, you are going to set first.

135
00:09:50,980 --> 00:09:52,090
You are going to sit second.

136
00:09:52,330 --> 00:09:57,100
Remember, sit first and second were written such that a check first.

137
00:09:57,100 --> 00:10:01,490
If the first point that exists or not, if it doesn't exist, it creates it then copied it.

138
00:10:01,990 --> 00:10:03,520
So this is a good thing for us.

139
00:10:04,120 --> 00:10:08,290
Now the assignment operator here is going to do the following.

140
00:10:10,070 --> 00:10:16,490
First of all, you need to free your own data, you need to free your own pointers because you are going

141
00:10:16,490 --> 00:10:19,390
to take the other side if the other side is not.

142
00:10:19,450 --> 00:10:20,220
You need to take it.

143
00:10:20,540 --> 00:10:23,120
So anyway, we have to free our own data first.

144
00:10:23,750 --> 00:10:25,880
The second we have to steal the appointers.

145
00:10:25,910 --> 00:10:32,210
The third, we have to nullify the the pointers that we that we have.

146
00:10:33,920 --> 00:10:37,040
Again, you notice there is a big difference between these two guys.

147
00:10:37,340 --> 00:10:41,810
This guy here is going to do a lot of copies if the object is very heavy.

148
00:10:41,990 --> 00:10:45,530
But this guy is just stealing the printers, which will be removed soon.

149
00:10:45,770 --> 00:10:47,780
And then just to notify them here

150
00:10:50,720 --> 00:10:56,540
in terms of cooling, let's say that we define here be one which will call the constructor, then we

151
00:10:56,540 --> 00:10:59,120
say want equal Meyerbeer, this is an R value.

152
00:10:59,570 --> 00:11:05,450
So the MBT one would be constructed, then the assignment or value would be called to steal the data

153
00:11:05,780 --> 00:11:11,450
and the destructor would notice that the data is already moved and then another distractor.

154
00:11:11,460 --> 00:11:14,560
So we don't make extra copies on the other side.

155
00:11:14,570 --> 00:11:18,890
If you say something like B to equal we, this will call the assignment value case.

156
00:11:21,020 --> 00:11:23,480
Let's try the blusterous operators for fun here.

157
00:11:24,630 --> 00:11:31,170
Remember, the prefix operator is returning by reference so it doesn't really value the operator plus

158
00:11:31,190 --> 00:11:33,550
plus here is returning by value.

159
00:11:33,560 --> 00:11:37,790
So it is an R value the operator plus plus for the specifics.

160
00:11:37,790 --> 00:11:41,150
Have to call the copy constructor in a way to make a copy for it.

161
00:11:41,180 --> 00:11:42,400
This is an L value here.

162
00:11:42,980 --> 00:11:43,830
Let's make a usage.

163
00:11:43,850 --> 00:11:49,100
Now if we have B1 and B2, if we say B2 equal blu's must be one.

164
00:11:49,370 --> 00:11:52,370
The plus plus B one is an value.

165
00:11:52,370 --> 00:11:53,950
The return the is reference.

166
00:11:53,960 --> 00:12:00,260
So it's going to call the assignment to DeLaval it if you call B1 plus plus the plus is returning this

167
00:12:00,260 --> 00:12:05,240
by this is returning now by value which is assignment or value.

168
00:12:06,520 --> 00:12:09,490
That's all I would like you to keep this in mind.

169
00:12:09,670 --> 00:12:15,370
There are five things to consider when you create a class that has internally appointed three of them

170
00:12:15,370 --> 00:12:20,680
are must you are a master to provide a copy constructor, assignment operator and instructor to handle

171
00:12:20,680 --> 00:12:26,200
the data to avoid both memory leaks and dangling pointers for efficiency.

172
00:12:26,210 --> 00:12:31,130
You are highly recommended to provide move constructor and move assignment operator.

173
00:12:31,330 --> 00:12:36,700
This would be Matchett first for our values and will provide you a way to have a more efficient code.

174
00:12:37,180 --> 00:12:42,040
Right now with the SDL is fully complete with mathematics.

175
00:12:42,070 --> 00:12:47,650
So when you provide the assignment, the move semantic, you are making use of them to have a great

176
00:12:47,650 --> 00:12:48,550
efficient good.

177
00:12:49,510 --> 00:12:51,400
Here is one more covid.

178
00:12:51,760 --> 00:12:57,400
If you try some of the code by yourself to play with the semantics, you would notice sometimes even

179
00:12:57,400 --> 00:13:03,510
the copy constructor and the constructor has it because we say this before when we're studying the classes.

180
00:13:03,820 --> 00:13:06,880
This is something called return value optimization.

181
00:13:07,300 --> 00:13:13,780
The compiler do things behind the scene for the return values only, not for the function calls to return

182
00:13:13,780 --> 00:13:15,960
the bodies, only to optimize things behind the scene.

183
00:13:16,150 --> 00:13:19,610
The compiler is doing a lot behind the scenes that can be heard much faster.

184
00:13:19,660 --> 00:13:24,220
So if you didn't see some of the output, then this is just because of the return value optimization.

185
00:13:24,940 --> 00:13:25,480
That's it.
