0
1
00:00:01,830 --> 00:00:06,300
Let's continue, for problem number three, we would like to find the maximum, but it should be less than
1

2
00:00:06,300 --> 00:00:06,900
one hundred.
2

3
00:00:07,350 --> 00:00:08,400
And one question here.
3

4
00:00:08,580 --> 00:00:13,010
Did you consider that the integers might be negative values or not, if you didn't,
4

5
00:00:13,020 --> 00:00:15,530
then this is a wrong conclusion.
5

6
00:00:15,870 --> 00:00:20,100
All of the examples here that I provided for you were only for positive examples.
6

7
00:00:20,100 --> 00:00:21,570
But this might not be the case.
7

8
00:00:21,810 --> 00:00:23,770
And it depends on your solution.
8

9
00:00:23,790 --> 00:00:24,850
How good is your solution?
9

10
00:00:24,870 --> 00:00:30,240
Does it consider something that might make the negative values wrong or not? For simplicity,
10

11
00:00:30,240 --> 00:00:33,690
Let's assume for now that all of the numbers are greater than or equal zero.
11

12
00:00:34,470 --> 00:00:40,560
I start here by initializing the result to be minus one and I have three if condition.
12

13
00:00:40,950 --> 00:00:44,810
Every if condition is trying to maximize over the current result.
13

14
00:00:45,060 --> 00:00:51,570
But I would like to make sure I'm maximizing over something that is greater than or equal to 100, is greater
14

15
00:00:51,570 --> 00:00:54,060
than or equal to 100.
15

16
00:00:55,110 --> 00:00:59,200
So we starting, is it less than 100?
16

17
00:00:59,250 --> 00:01:00,810
If so, this is a valid number.
17

18
00:01:01,200 --> 00:01:04,970
If it is greater than our number, then this is a good number, take it.
18

19
00:01:05,160 --> 00:01:08,270
Doing the same logic with B and the same logic with C..
19

20
00:01:08,610 --> 00:01:14,490
So the overall of that is we are maximizing, but I'm first making sure I am maximizing with a valid
20

21
00:01:14,490 --> 00:01:14,900
number.
21

22
00:01:15,390 --> 00:01:22,440
Where is the problem with this code? If any of these values like A is less than zero,
22

23
00:01:25,590 --> 00:01:29,010
There might be some troubles for some negative values
23

24
00:01:32,190 --> 00:01:35,460
because I'm stating here the result with negative one.
24

25
00:01:35,910 --> 00:01:40,940
So maybe we'll get to give an example here.
25

26
00:01:41,460 --> 00:01:43,640
Let's see what's happening if we provided
26

27
00:01:45,140 --> 00:01:54,020
Something like minus 10 and minus 20 and minus 30, the answer would be minus one.
27

28
00:01:54,410 --> 00:01:54,880
Why?
28

29
00:01:54,920 --> 00:01:56,810
Because of my bad initialization here.
29

30
00:01:57,980 --> 00:02:04,670
One way, one might decide to use a very, very, very small negative value here, something like the
30

31
00:02:05,060 --> 00:02:06,310
the lowest integer value.
31

32
00:02:06,470 --> 00:02:08,470
Then this code is going probably to be correct.
32

33
00:02:08,690 --> 00:02:10,310
But here is a handling.
33

34
00:02:10,430 --> 00:02:14,000
If we don't want to do that. just a one hundred, it's a bit longer,
34

35
00:02:14,000 --> 00:02:15,760
But there is an idea behind it that
35

36
00:02:15,770 --> 00:02:22,910
I would like to share with you, the idea here is as following, I'm going to check if any one of the
36

37
00:02:22,910 --> 00:02:25,680
the three variables is a valid starting point or not.
37

38
00:02:26,000 --> 00:02:30,410
So I'm checking if this is valid or this is valid or this is valid, if any of them is valid, I
38

39
00:02:30,410 --> 00:02:33,140
just would like to to initialize my result with it.
39

40
00:02:33,710 --> 00:02:38,390
If all of them are invalid, the result would be invalid and all of these conditions will not work.
40

41
00:02:39,320 --> 00:02:42,030
If any of them is valid, then it's a good initialization one.
41

42
00:02:42,290 --> 00:02:47,120
So the moral of that is the previous code has a problem with the initialization, like the way that
42

43
00:02:47,120 --> 00:02:51,800
I initialized it isn't wise enough and this code is trying to solve this problem.
43

44
00:02:51,810 --> 00:02:55,520
So this is one way. In other programming languages,
44

45
00:02:55,520 --> 00:02:57,470
It could be easier to handle this problem.
45

46
00:02:57,470 --> 00:03:04,340
Or as I said, you might use something that's very, very small value so that it fits with whatever inputs
46

47
00:03:04,340 --> 00:03:04,640
here.
47

48
00:03:06,710 --> 00:03:12,460
In the last problem, we would like to make a conditional count, which is mainly checking how
48

49
00:03:12,470 --> 00:03:17,050
many numbers greater or less than, for a while you might think, OK, let's do some If else condition.
49

50
00:03:17,120 --> 00:03:18,020
This is totally valid.
50

51
00:03:18,320 --> 00:03:20,410
But I wanted to go in a different direction.
51

52
00:03:20,900 --> 00:03:28,340
I just here initialized a counter and then a less than or equal X, a2 and a3.
52

53
00:03:28,670 --> 00:03:32,540
Observe that this is Boolean, which is ending up with either one or zero.
53

54
00:03:32,870 --> 00:03:37,660
So whatever is less than or equal X will be an added value as a word.
54

55
00:03:38,090 --> 00:03:43,190
And clearly the relationship between the two numbers that this is count, then the second number is
55

56
00:03:43,190 --> 00:03:43,680
five minus count.
56

57
00:03:43,710 --> 00:03:45,740
So this is the relationship between both of them.
57

58
00:03:46,220 --> 00:03:49,360
And you can definitely do that with an if else condition.
58

59
00:03:49,370 --> 00:03:50,000
That's OK.
59

60
00:03:51,620 --> 00:03:51,950
Yeah.
