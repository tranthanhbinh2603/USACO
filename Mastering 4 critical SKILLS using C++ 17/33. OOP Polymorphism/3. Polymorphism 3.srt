0
1
00:00:01,410 --> 00:00:07,870
Starting from this video, we will start to see why polymorphism is really a very strong feature.
1

2
00:00:08,340 --> 00:00:10,330
So let's define a shape class.
2

3
00:00:10,350 --> 00:00:17,250
We have a shape that has some name and has some area function and get_name function and a destructor.
3

4
00:00:17,250 --> 00:00:17,910
As an advice,
4

5
00:00:18,090 --> 00:00:24,900
whenever you create a virtual function, you have to provide the virtual destructor so that the actual
5

6
00:00:24,990 --> 00:00:27,610
destructor of the object will be always called.
6

7
00:00:28,440 --> 00:00:31,120
Now, thinking about the virtual area as a side note.
7

8
00:00:31,320 --> 00:00:33,140
What is a virtual area of the shape class?
8

9
00:00:33,510 --> 00:00:34,620
We actually don't know
9

10
00:00:34,740 --> 00:00:36,800
so maybe we can throw an error.
10

11
00:00:36,840 --> 00:00:41,340
We can return -1 for now, but in the future, we'll see a better treatment than that.
11

12
00:00:41,670 --> 00:00:44,700
So we don't want to implement a function that we know nothing about it.
12

13
00:00:45,000 --> 00:00:46,620
We definitely can return to the name,
13

14
00:00:46,980 --> 00:00:49,030
but do we need it as a virtual function?
14

15
00:00:49,380 --> 00:00:50,550
The answer is no.
15

16
00:00:50,820 --> 00:00:53,380
What does it mean when you make a function not private?
16

17
00:00:53,400 --> 00:00:57,030
It means the actual object will be called here.
17

18
00:00:57,080 --> 00:01:04,830
OK, so as a designer, if I design a function that isn't virtual, I am seeing a message that I expected
18

19
00:01:04,830 --> 00:01:06,660
that this parent class would be called.
19

20
00:01:06,960 --> 00:01:12,050
If I'm providing a function that is virtual, I'm giving a message that this function should be overridden.
20

21
00:01:12,090 --> 00:01:12,320
...
21

22
00:01:12,350 --> 00:01:14,820
Now, here is a rectangle class.
22

23
00:01:14,820 --> 00:01:20,880
It has its own name, width, and height parameters, and calling the constructor of the above class like inheritance,
23

24
00:01:21,090 --> 00:01:26,190
and now defining its own virtual function area to return width times height.
24

25
00:01:27,150 --> 00:01:34,590
Now, let's think about what exactly the virtual function gives us in terms of compile versus runtime behavior.
25

26
00:01:34,590 --> 00:01:40,170
Let's say we have a function that named process shape. The function knows nothing about the
26

27
00:01:40,170 --> 00:01:40,530
shape.
27

28
00:01:40,530 --> 00:01:42,840
It doesn't know which which kind of shape,
28

29
00:01:42,840 --> 00:01:43,590
Is it circle?
29

30
00:01:43,620 --> 00:01:45,080
Is it triangle? Is it rectangle?
30

31
00:01:45,270 --> 00:01:45,600
Is it polygon?
31

32
00:01:45,990 --> 00:01:47,210
It is what? it doesn't know.
32

33
00:01:47,670 --> 00:01:52,160
So the printing here, cout the name and then cout the area.
33

34
00:01:52,620 --> 00:01:57,150
Now we created a rectangle, we send it by reference to be a pointer, and then it is used.
34

35
00:01:57,570 --> 00:02:05,430
Let's say that we provided this function to someone who extended the shape to polygon and called the process function.
35

36
00:02:05,790 --> 00:02:08,790
When we implemented this function, we didn't know about the polygon,
36

37
00:02:08,790 --> 00:02:09,020
...
37

38
00:02:09,300 --> 00:02:11,670
and we didn't know about the future data types.
38

39
00:02:12,030 --> 00:02:15,060
All we know that it has an area function that is virtual.
39

40
00:02:15,510 --> 00:02:24,030
So the power here is that what happens in this function is actually determined by the runtime, is actually
40

41
00:02:24,210 --> 00:02:25,800
determined by the runtime.
41

42
00:02:26,130 --> 00:02:32,850
Only in the runtime, we will know exactly what will be the area of the class. On the other side, the
42

43
00:02:32,850 --> 00:02:33,960
get shape function,
43

44
00:02:34,170 --> 00:02:38,610
this is well known from the compile-time because this function isn't virtual.
44

45
00:02:38,790 --> 00:02:43,410
So we definitely know the shape parent class name function would be called,
45

46
00:02:43,620 --> 00:02:44,880
but the area is virtual.
46

47
00:02:45,000 --> 00:02:48,840
We have no idea which function is going to be called.
47

48
00:02:49,080 --> 00:02:55,020
So this actually defined a compile-time behavior versus runtime behavior.
48

49
00:02:55,350 --> 00:03:05,190
The real strength in polymorphism is the ability to be more dynamic and that we can extend a lot of
49

50
00:03:05,190 --> 00:03:09,410
the code functionalities without making changes for it. As terminology,
50

51
00:03:09,630 --> 00:03:11,370
the non-virtual function,
51

52
00:03:11,370 --> 00:03:15,150
we call them compile-time polymorphism because we know in compile time
52

53
00:03:15,150 --> 00:03:18,180
the answer. Also called static or early binding.
53

54
00:03:18,390 --> 00:03:20,910
The word bind refers to like a connection,
54

55
00:03:21,120 --> 00:03:26,510
So we know that this get_shape_name is connected with the shape parent class.
55

56
00:03:27,180 --> 00:03:29,210
The virtual we call it run-time polymorphism
56

57
00:03:29,460 --> 00:03:32,400
because what will happen is mainly determined in the runtime.
57

58
00:03:32,610 --> 00:03:35,130
We call it also dynamic binding or late binding.
58

59
00:03:35,340 --> 00:03:38,580
It means later, at some point we will connect this area
59

60
00:03:38,580 --> 00:03:41,550
shape with the actual object that we used it.
60

61
00:03:41,880 --> 00:03:45,510
So this is how the compiler runtime is determined
61

62
00:03:45,780 --> 00:03:50,220
in general. The word polymorphism means we have many forms.
62

63
00:03:50,460 --> 00:03:58,020
So if you have a chain of K classes in inheritance, in runtime,...
63

64
00:03:58,020 --> 00:04:01,710
a pointer calling function either would base or derived
64

65
00:04:01,800 --> 00:04:03,390
so you see here we have two forms.
65

66
00:04:03,420 --> 00:04:12,090
That's why we call it polymorphism. This dynamic binding is the core feature of how polymorphism provides generic code.
66

67
00:04:12,330 --> 00:04:15,600
The process shape function knows nothing about the exact children
67

68
00:04:15,810 --> 00:04:21,990
so this provides a very, very powerful key for extensibility and for flexibility.
68

69
00:04:22,530 --> 00:04:30,270
In return, the runtime polymorphism is a bit slower and little extra memory than the standard
69

70
00:04:30,510 --> 00:04:31,170
binding.
70

71
00:04:33,240 --> 00:04:34,980
Let's administrate that with an example.
71

72
00:04:35,160 --> 00:04:40,710
We already provided the homework for the package delivery service, and when we checked out the solution,
72

73
00:04:41,070 --> 00:04:43,620
you'll notice that there are different package types.
73

74
00:04:43,800 --> 00:04:48,700
Every one of them is added to the code. Old card types added the code.
74

75
00:04:48,840 --> 00:04:50,550
So the code was flexible.
75

76
00:04:50,760 --> 00:04:54,840
This is how we had here a set of packages of credit cards
76

77
00:04:55,230 --> 00:04:59,850
but when it came to the shipment, we have to make a vector for the standard package, vector
77

78
00:04:59,960 --> 00:05:05,180
with the two day package, vector to the heavy package, credit card for this guy, and debit card
78

79
00:05:05,180 --> 00:05:10,820
for this guy, boolean for which card is used. We have to define a function for every time, we have to set
79

80
00:05:10,820 --> 00:05:12,640
every credit type.
80

81
00:05:13,100 --> 00:05:19,910
If the company decided to add one more package type, we will add another function
81

82
00:05:20,060 --> 00:05:21,230
and we add a vector.
82

83
00:05:21,440 --> 00:05:27,020
If they decided to add prepaid cards, we will add a function here, will add an object here.
83

84
00:05:27,320 --> 00:05:31,490
As you see a lot of extensions to the code with minor changes,
84

85
00:05:31,490 --> 00:05:32,040
we change request.
85

86
00:05:32,720 --> 00:05:34,820
So how polymorphism is changing all of that?
86

87
00:05:35,210 --> 00:05:42,020
You define a package class which is just virtual function to total cost and destructor, and then
87

88
00:05:42,830 --> 00:05:49,040
your standard package, two day package and the heavy package are extending from this class. 
88

89
00:05:49,040 --> 00:05:52,340
In the shipment class, we have vector of package pointer.
89

90
00:05:52,850 --> 00:05:59,240
Now thinking about that, we removed all of the vectors here with a single vector only for the package.
90

91
00:05:59,540 --> 00:06:06,040
We removed all the credit cards types here with a single card here.
91

92
00:06:06,350 --> 00:06:08,090
We removed all the add functions
92

93
00:06:08,090 --> 00:06:11,180
here with a single function here and one function here.
93

94
00:06:11,760 --> 00:06:16,310
This class has no idea about the packages or the payment card types.
94

95
00:06:16,490 --> 00:06:23,150
If in the future we have one more package type or payment card type, we aren't affected at all. The total
95

96
00:06:23,150 --> 00:06:27,880
cost function iterates every package and says package total cost and that's it.
96

97
00:06:28,190 --> 00:06:31,380
The customer have vector of payment cards also
97

98
00:06:31,400 --> 00:06:38,690
so it just using it as pointers. I hope you started to realize how the polymorphism is making our life
98

99
00:06:38,690 --> 00:06:42,620
much easier when it comes to the generic code. That's it.
