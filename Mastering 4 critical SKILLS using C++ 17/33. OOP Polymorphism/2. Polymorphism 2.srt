0
1
00:00:01,020 --> 00:00:07,470
Let's administrate more on the polymorphism syntax. In this example, we have four classes. Take
1

2
00:00:07,470 --> 00:00:09,900
a moment to just read all of it.
2

3
00:00:12,170 --> 00:00:19,460
So Class A has a virtual function void f1, class B is inheriting from A, and it has f1
3

4
00:00:19,730 --> 00:00:21,050
f1, f1.
4

5
00:00:21,650 --> 00:00:23,090
Now remember the rule,
5

6
00:00:24,490 --> 00:00:31,990
if there is a virtual function, every child class is also virtual in this function even if it
6

7
00:00:31,990 --> 00:00:33,820
didn't put the virtual function.
7

8
00:00:34,000 --> 00:00:41,800
So now f1 here is virtual, f1 here is also virtual, but there is no virtual keyword, but it is virtual.
8

9
00:00:42,340 --> 00:00:45,280
F1 here is virtual, f1 here is virtual too.
9

10
00:00:47,250 --> 00:00:54,180
Now, f2 here isn't a virtual function, but f2 here is starting to be defined as a virtual function.
10

11
00:00:54,600 --> 00:00:58,140
Every child of B will be also virtual at f2.
11

12
00:00:58,410 --> 00:01:01,590
So this f2 will be virtual, and this f2 would be virtual.
12

13
00:01:02,830 --> 00:01:08,860
F3 here isn't virtual function and here isn't virtual function, but f3 here is now a
13

14
00:01:08,860 --> 00:01:14,170
visual function, so it is virtual here and also virtual here.
14

15
00:01:15,370 --> 00:01:16,600
So this is number one.
15

16
00:01:16,630 --> 00:01:18,640
Now, let's make some tracing to make sure
16

17
00:01:18,850 --> 00:01:23,080
how does this help us to understand the polymorphism behavior.
17

18
00:01:24,820 --> 00:01:31,030
We are defining two D pointers, one of them assigned to a B class and one of them assigned to the
18

19
00:01:31,080 --> 00:01:31,600
A class.
19

20
00:01:32,080 --> 00:01:37,860
So starting from the B class, the d1 is calling f1
20

21
00:01:38,350 --> 00:01:44,010
so we go to class B, which is here, is f1 a virtual function?
21

22
00:01:44,050 --> 00:01:44,590
Yes.
22

23
00:01:44,890 --> 00:01:49,510
Then call based on the actual object. To the actual object is D.
23

24
00:01:49,780 --> 00:01:51,100
So what's going to be printed
24

25
00:01:51,100 --> 00:01:54,670
is d f1. Now moving to f2,
25

26
00:01:55,950 --> 00:02:02,270
going to B. Is B f2 is a virtual function? Yes.
26

27
00:02:02,460 --> 00:02:06,270
Call based on the actual object, which is D
27

28
00:02:06,360 --> 00:02:07,940
so d f2 is going to be called.
28

29
00:02:08,790 --> 00:02:18,000
Now, calling f3, go to the B. Is it a virtual function? No, make a call based on the pointer type which is
29

30
00:02:18,000 --> 00:02:27,430
going to print B f3. Let's administrate more. We are creating now class D, and we are using an A pointer. Let's call
30

31
00:02:27,450 --> 00:02:31,380
f1, it goes to A. Is f1 virtual?
31

32
00:02:31,440 --> 00:02:31,980
Yes.
32

33
00:02:32,130 --> 00:02:35,290
Call based on the actual object.
33

34
00:02:35,310 --> 00:02:43,280
So it's going to print d_f1. Call f2. Is f2 virtual? no, call based on the pointer type A_f2. 
34

35
00:02:43,420 --> 00:02:44,010
Call f3.
35

36
00:02:44,040 --> 00:02:44,850
Is it virtual?
36

37
00:02:44,850 --> 00:02:47,220
No, call based on the pointer type.
37

38
00:02:47,640 --> 00:02:49,680
So which is A_f3.
38

39
00:02:49,680 --> 00:02:56,370
I hope by tracing this example, you now exactly know the polymorphism behavior that will happen from
39

40
00:02:56,370 --> 00:02:58,300
the different course. That's it.
